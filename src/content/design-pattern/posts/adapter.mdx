---
layout: post
title: Adapter Design Pattern
difficulty: easy
tags: [structural]
langs: [java, py, cpp]
companies: []
gfg: system-design/adapter-pattern
refactoring: adapter
sourcemaking: adapter
wikipedia: Adapter_pattern
scaler: design-patterns/adapter-design-pattern/
---

## Intent
- Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.
- Wrap an existing class with a new interface.
- Impedance match an old component to a new system

## Problem
An "off the shelf" component offers compelling functionality that you would like to reuse, but its "view of the world" is not compatible with the philosophy and architecture of the system currently being developed.

## Structure

Below, a legacy Rectangle component's `display()` method expects to receive "x, y, w, h" parameters. But the client wants to pass "upper left x and y" and "lower right x and y". 
This incongruity can be reconciled by adding an additional level of indirection â€“ i.e. an Adapter object.

<MdxImage src="https://sourcemaking.com/files/v2/content/patterns/Adapter_1-2x.png" />

The Adapter could also be thought of as a "wrapper".

<MdxImage src="https://sourcemaking.com/files/v2/content/patterns/Adapter-2x.png" />

## Example

The Adapter pattern allows otherwise incompatible classes to work together by converting the interface of one class into an interface expected by the clients. 
Socket wrenches provide an example of the Adapter. A socket attaches to a ratchet, provided that the size of the drive is the same. 
Typical drive sizes in the United States are 1/2" and 1/4". 
Obviously, a 1/2" drive ratchet will not fit into a 1/4" drive socket unless an adapter is used. 
A 1/2" to 1/4" adapter has a 1/2" female connection to fit on the 1/2" drive ratchet, and a 1/4" male connection to fit in the 1/4" drive socket.

<MdxImage src="https://sourcemaking.com/files/v2/content/patterns/Adapter_example1-2x.png" />

## Checklist

1. Identify the players: the component(s) that want to be accommodated (i.e. the client), and the component that needs to adapt (i.e. the adaptee).
2. Identify the interface that the client requires.
3. Design a "wrapper" class that can "impedance match" the adaptee to the client.
4. The adapter/wrapper class "has a" instance of the adaptee class.
5. The adapter/wrapper class "maps" the client interface to the adaptee interface.
6. The client uses (is coupled to) the new interface

## Rule of thumb

- Adapter makes things work after they're designed; Bridge makes them work before they are.
- Bridge is designed up-front to let the abstraction and the implementation vary independently. Adapter is retrofitted to make unrelated classes work together.
- Adapter provides a different interface to its subject. Proxy provides the same interface. Decorator provides an enhanced interface.
- Adapter is meant to change the interface of an existing object. Decorator enhances another object without changing its interface. Decorator is thus more transparent to the application than an adapter is. As a consequence, Decorator supports recursive composition, which isn't possible with pure Adapters.
- Facade defines a new interface, whereas Adapter reuses an old interface. Remember that Adapter makes two existing interfaces work together as opposed to defining an entirely new one.