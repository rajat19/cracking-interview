---
layout: post
title: Abstract Factory Design Pattern
difficulty: hard
tags: [creational]
langs: [java, py, cpp]
companies: []
gfg: system-design/abstract-factory-pattern
refactoring: abstract-factory
sourcemaking: abstract_factory
wikipedia: Abstract_factory_pattern
scaler: design-patterns/abstract-factory-design-pattern/
---

## Intent
- Provide an interface for creating families of related or dependent objects without specifying their concrete classes
- A hierarchy that encapsulates many possible platforms and the construction of a suite of products
- The "new" operator considered harmful when creating objects of concrete classes

## Problem

Imagine you're creating a furniture shop simulator. Your code consists of classes that represent a family of related products, say: Chair + Sofa + CoffeeTable. You need several variants of this family. For example, you have products Chair + Sofa + CoffeeTable available in these variants: Modern, Victorian, ArtDeco.

You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture. Also, you don't want to change existing code when adding new products or families of products to the program.

## Structure

The Abstract Factory pattern suggests explicitly declaring interfaces for each distinct product of the product family. Then you can make all variants of products follow those interfaces.

<MdxImage src="https://refactoring.guru/images/patterns/diagrams/abstract-factory/structure.png" />

The next step is to declare the Abstract Factoryâ€”an interface with a list of creation methods for all products that are part of the product family. These methods must return abstract product types represented by the interfaces we extracted previously.

<MdxImage src="https://refactoring.guru/images/patterns/content/abstract-factory/abstract-factory-en.png" />

## Example

Think of the Abstract Factory as a factory that produces other factories. Each factory type corresponds to a certain product variety. For instance, a Modern Furniture Factory can create Modern Chairs, Modern Sofas, and Modern Coffee Tables. A Victorian Furniture Factory produces Victorian-style furniture, and so on.

The client code can work with any concrete factory, as long as it communicates with its products via abstract interfaces. This allows the client code to be independent of the actual type of products it gets from a factory object.

## Implementation Checklist

1. Map out a matrix of distinct product types versus variants of these products
2. Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces
3. Declare the abstract factory interface with a set of creation methods for all abstract products
4. Implement a set of concrete factory classes, one for each product variant
5. Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment
6. Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object

## Pros and Cons

**Pros:**
- Ensures that the products you get from a factory are compatible with each other
- Avoids tight coupling between concrete products and client code
- Single Responsibility Principle. You can extract the product creation code into one place
- Open/Closed Principle. You can introduce new variants of products without breaking existing client code

**Cons:**
- Code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern

## Rules of Thumb

- Abstract Factory can serve as an alternative to Facade when you only want to hide the way the subsystem objects are created from the client code
- You can use Abstract Factory along with Bridge. This pairing is useful when some abstractions defined by Bridge can only work with specific implementations
- Abstract Factories, Builders and Prototypes can all be implemented as Singletons
- Abstract Factory is often based on a set of Factory Methods, but you can also use Prototype to compose the methods on these classes
- Factory Method is a specialization of Template Method. At the same time, a Factory Method may serve as a step in a large Template Method
