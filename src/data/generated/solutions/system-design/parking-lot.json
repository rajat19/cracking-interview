{
  "accounts_java": {
    "language": "java",
    "code": "// For simplicity, we are not defining getter and setter functions. The reader can\n// assume that all class attributes are private and accessed through their respective\n// public getter methods and modified only through their public methods function.\n\npublic abstract class Account {\n  private String userName;\n  private String password;\n  private AccountStatus status;\n  private Person person;\n\n  public boolean resetPassword();\n}\n\npublic class Admin extends Account {\n  public bool addParkingFloor(ParkingFloor floor);\n  public bool addParkingSpot(String floorName, ParkingSpot spot);\n  public bool addParkingDisplayBoard(String floorName, ParkingDisplayBoard displayBoard);\n  public bool addCustomerInfoPanel(String floorName, CustomerInfoPanel infoPanel);\n\n  public bool addEntrancePanel(EntrancePanel entrancePanel);\n  public bool addExitPanel(ExitPanel exitPanel);\n}\n\npublic class ParkingAttendant extends Account {\n  public bool processTicket(string TicketNumber);\n}",
    "subPath": "accounts",
    "fileName": "solution.java"
  },
  "accounts_py": {
    "language": "py",
    "code": "class Account:\n  def __init__(self, user_name, password, person, status=AccountStatus.Active):\n    self.__user_name = user_name\n    self.__password = password\n    self.__person = person\n    self.__status = status\n\n  def reset_password(self):\n    None\n\n\nclass Admin(Account):\n  def __init__(self, user_name, password, person, status=AccountStatus.Active):\n    super().__init__(user_name, password, person, status)\n\n  def add_parking_floor(self, floor):\n    None\n\n  def add_parking_spot(self, floor_name, spot):\n    None\n\n  def add_parking_display_board(self, floor_name, display_board):\n    None\n\n  def add_customer_info_panel(self, floor_name, info_panel):\n    None\n\n  def add_entrance_panel(self, entrance_panel):\n    None\n\n  def add_exit_panel(self, exit_panel):\n    None\n\n\nclass ParkingAttendant(Account):\n  def __init__(self, user_name, password, person, status=AccountStatus.Active):\n    super().__init__(user_name, password, person, status)\n\n  def process_ticket(self, ticket_number):\n    None",
    "subPath": "accounts",
    "fileName": "solution.py"
  },
  "enums_java": {
    "language": "java",
    "code": "public enum VehicleType {\n  CAR, TRUCK, ELECTRIC, VAN, MOTORBIKE\n}\n\npublic enum ParkingSpotType {\n  HANDICAPPED, COMPACT, LARGE, MOTORBIKE, ELECTRIC\n}\n\npublic enum AccountStatus {\n  ACTIVE, BLOCKED, BANNED, COMPROMISED, ARCHIVED, UNKNOWN\n}\n\npublic enum ParkingTicketStatus {\n  ACTIVE, PAID, LOST\n}\n\npublic class Address {\n  private String streetAddress;\n  private String city;\n  private String state;\n  private String zipCode;\n  private String country;\n}\n\npublic class Person {\n  private String name;\n  private Address address;\n  private String email;\n  private String phone;\n}",
    "subPath": "enums",
    "fileName": "solution.java"
  },
  "enums_py": {
    "language": "py",
    "code": "class VehicleType(Enum):\n  CAR, TRUCK, ELECTRIC, VAN, MOTORBIKE = 1, 2, 3, 4, 5\n\n\nclass ParkingSpotType(Enum):\n  HANDICAPPED, COMPACT, LARGE, MOTORBIKE, ELECTRIC = 1, 2, 3, 4, 5\n\n\nclass AccountStatus(Enum):\n  ACTIVE, BLOCKED, BANNED, COMPROMISED, ARCHIVED, UNKNOWN = 1, 2, 3, 4, 5, 6\n\n\nclass ParkingTicketStatus(Enum):\n  ACTIVE, PAID, LOST = 1, 2, 3\n\n\nclass Address:\n  def __init__(self, street, city, state, zip_code, country):\n    self.__street_address = street\n    self.__city = city\n    self.__state = state\n    self.__zip_code = zip_code\n    self.__country = country\n\n\nclass Person():\n  def __init__(self, name, address, email, phone):\n    self.__name = name\n    self.__address = address\n    self.__email = email\n    self.__phone = phone",
    "subPath": "enums",
    "fileName": "solution.py"
  },
  "parkingDisplay_java": {
    "language": "java",
    "code": "public class ParkingDisplayBoard {\n  private String id;\n  private HandicappedSpot handicappedFreeSpot;\n  private CompactSpot compactFreeSpot;\n  private LargeSpot largeFreeSpot;\n  private MotorbikeSpot motorbikeFreeSpot;\n  private ElectricSpot electricFreeSpot;\n\n  public void showEmptySpotNumber() {\n    String message = \"\";\n    if(handicappedFreeSpot.IsFree()){\n      message += \"Free Handicapped: \" + handicappedFreeSpot.getNumber();\n    } else {\n      message += \"Handicapped is full\";\n    }\n    message += System.lineSeparator();\n\n    if(compactFreeSpot.IsFree()){\n      message += \"Free Compact: \" + compactFreeSpot.getNumber();\n    } else {\n      message += \"Compact is full\";\n    }\n    message += System.lineSeparator();\n\n    if(largeFreeSpot.IsFree()){\n      message += \"Free Large: \" + largeFreeSpot.getNumber();\n    } else {\n      message += \"Large is full\";\n    }\n    message += System.lineSeparator();\n\n    if(motorbikeFreeSpot.IsFree()){\n      message += \"Free Motorbike: \" + motorbikeFreeSpot.getNumber();\n    } else {\n      message += \"Motorbike is full\";\n    }\n    message += System.lineSeparator();\n\n    if(electricFreeSpot.IsFree()){\n      message += \"Free Electric: \" + electricFreeSpot.getNumber();\n    } else {\n      message += \"Electric is full\";\n    }\n\n    Show(message);\n  }\n}",
    "subPath": "parkingDisplay",
    "fileName": "solution.java"
  },
  "parkingDisplay_py": {
    "language": "py",
    "code": "class ParkingDisplayBoard:\n  def __init__(self, id):\n    self.__id = id\n    self.__handicapped_free_spot = None\n    self.__compact_free_spot = None\n    self.__large_free_spot = None\n    self.__motorbike_free_spot = None\n    self.__electric_free_spot = None\n\n  def show_empty_spot_number(self):\n    message = \"\"\n    if self.__handicapped_free_spot.is_free():\n      message += \"Free Handicapped: \" + self.__handicapped_free_spot.get_number()\n    else:\n      message += \"Handicapped is full\"\n    message += \"\\n\"\n\n    if self.__compact_free_spot.is_free():\n      message += \"Free Compact: \" + self.__compact_free_spot.get_number()\n    else:\n      message += \"Compact is full\"\n    message += \"\\n\"\n\n    if self.__large_free_spot.is_free():\n      message += \"Free Large: \" + self.__large_free_spot.get_number()\n    else:\n      message += \"Large is full\"\n    message += \"\\n\"\n\n    if self.__motorbike_free_spot.is_free():\n      message += \"Free Motorbike: \" + self.__motorbike_free_spot.get_number()\n    else:\n      message += \"Motorbike is full\"\n    message += \"\\n\"\n\n    if self.__electric_free_spot.is_free():\n      message += \"Free Electric: \" + self.__electric_free_spot.get_number()\n    else:\n      message += \"Electric is full\"\n\n    print(message)",
    "subPath": "parkingDisplay",
    "fileName": "solution.py"
  },
  "parkingFloor_java": {
    "language": "java",
    "code": "public class ParkingFloor {\n  private String name;\n  private HashMap<String, HandicappedSpot> handicappedSpots;\n  private HashMap<String, CompactSpot> compactSpots;\n  private HashMap<String, LargeSpot> largeSpots;\n  private HashMap<String, MotorbikeSpot> motorbikeSpots;\n  private HashMap<String, ElectricSpot> electricSpots;\n  private HashMap<String, CustomerInfoPortal> infoPortals;\n  private ParkingDisplayBoard displayBoard;\n\n  public ParkingFloor(String name) {\n    this.name = name;\n  }\n\n  public void addParkingSpot(ParkingSpot spot) {\n    switch (spot.getType()) {\n    case ParkingSpotType.HANDICAPPED:\n      handicappedSpots.put(spot.getNumber(), spot);\n      break;\n    case ParkingSpotType.COMPACT:\n      compactSpots.put(spot.getNumber(), spot);\n      break;\n    case ParkingSpotType.LARGE:\n      largeSpots.put(spot.getNumber(), spot);\n      break;\n    case ParkingSpotType.MOTORBIKE:\n      motorbikeSpots.put(spot.getNumber(), spot);\n      break;\n    case ParkingSpotType.ELECTRIC:\n      electricSpots.put(spot.getNumber(), spot);\n      break;\n    default:\n      print(\"Wrong parking spot type!\");\n    }\n  }\n\n  public void assignVehicleToSpot(Vehicle vehicle, ParkingSpot spot) {\n    spot.assignVehicle(vehicle);\n    switch (spot.getType()) {\n    case ParkingSpotType.HANDICAPPED:\n      updateDisplayBoardForHandicapped(spot);\n      break;\n    case ParkingSpotType.COMPACT:\n      updateDisplayBoardForCompact(spot);\n      break;\n    case ParkingSpotType.LARGE:\n      updateDisplayBoardForLarge(spot);\n      break;\n    case ParkingSpotType.MOTORBIKE:\n      updateDisplayBoardForMotorbike(spot);\n      break;\n    case ParkingSpotType.ELECTRIC:\n      updateDisplayBoardForElectric(spot);\n      break;\n    default:\n      print(\"Wrong parking spot type!\");\n    }\n  }\n\n  private void updateDisplayBoardForHandicapped(ParkingSpot spot) {\n    if (this.displayBoard.getHandicappedFreeSpot().getNumber() == spot.getNumber()) {\n      // find another free handicapped parking and assign to displayBoard\n      for (String key : handicappedSpots.keySet()) {\n        if (handicappedSpots.get(key).isFree()) {\n          this.displayBoard.setHandicappedFreeSpot(handicappedSpots.get(key));\n        }\n      }\n      this.displayBoard.showEmptySpotNumber();\n    }\n  }\n\n  private void updateDisplayBoardForCompact(ParkingSpot spot) {\n    if (this.displayBoard.getCompactFreeSpot().getNumber() == spot.getNumber()) {\n      // find another free compact parking and assign to displayBoard\n      for (String key : compactSpots.keySet()) {\n        if (compactSpots.get(key).isFree()) {\n          this.displayBoard.setCompactFreeSpot(compactSpots.get(key));\n        }\n      }\n      this.displayBoard.showEmptySpotNumber();\n    }\n  }\n\n  public void freeSpot(ParkingSpot spot) {\n    spot.removeVehicle();\n    switch (spot.getType()) {\n    case ParkingSpotType.HANDICAPPED:\n      freeHandicappedSpotCount++;\n      break;\n    case ParkingSpotType.COMPACT:\n      freeCompactSpotCount++;\n      break;\n    case ParkingSpotType.LARGE:\n      freeLargeSpotCount++;\n      break;\n    case ParkingSpotType.MOTORBIKE:\n      freeMotorbikeSpotCount++;\n      break;\n    case ParkingSpotType.ELECTRIC:\n      freeElectricSpotCount++;\n      break;\n    default:\n      print(\"Wrong parking spot type!\");\n    }\n  }\n}",
    "subPath": "parkingFloor",
    "fileName": "solution.java"
  },
  "parkingFloor_py": {
    "language": "py",
    "code": "class ParkingFloor:\n  def __init__(self, name):\n    self.__name = name\n    self.__handicapped_spots = {}\n    self.__compact_spots = {}\n    self.__large_spots = {}\n    self.__motorbike_spots = {}\n    self.__electric_spots = {}\n    self.__info_portals = {}\n    self.__display_board = ParkingDisplayBoard()\n\n  def add_parking_spot(self, spot):\n    switcher = {\n      ParkingSpotType.HANDICAPPED: self.__handicapped_spots.put(spot.get_number(), spot),\n      ParkingSpotType.COMPACT: __compact_spots.put(spot.get_number(), spot),\n      ParkingSpotType.LARGE: __large_spots.put(spot.get_number(), spot),\n      ParkingSpotType.MOTORBIKE: __motorbike_spots.put(spot.get_number(), spot),\n      ParkingSpotType.ELECTRIC: __electric_spots.put(spot.get_number(), spot),\n    }\n    switcher.get(spot.get_type(), 'Wrong parking spot type')\n\n  def assign_vehicleToSpot(self, vehicle, spot):\n    spot.assign_vehicle(vehicle)\n    switcher = {\n      ParkingSpotType.HANDICAPPED: self.update_display_board_for_handicapped(spot),\n      ParkingSpotType.COMPACT: self.update_display_board_for_compact(spot),\n      ParkingSpotType.LARGE: self.update_display_board_for_large(spot),\n      ParkingSpotType.MOTORBIKE: self.update_display_board_for_motorbike(spot),\n      ParkingSpotType.ELECTRIC: self.update_display_board_for_electric(spot),\n    }\n    switcher(spot.get_type(), 'Wrong parking spot type!')\n\n  def update_display_board_for_handicapped(self, spot):\n    if self.__display_board.get_handicapped_free_spot().get_number() == spot.get_number():\n      # find another free handicapped parking and assign to display_board\n      for key in self.__handicapped_spots:\n        if self.__handicapped_spots.get(key).is_free():\n          self.__display_board.set_handicapped_free_spot(\n            self.__handicapped_spots.get(key))\n\n      self.__display_board.show_empty_spot_number()\n\n  def update_display_board_for_compact(self, spot):\n    if self.__display_board.get_compact_free_spot().get_number() == spot.get_number():\n      # find another free compact parking and assign to display_board\n      for key in self.__compact_spots.key_set():\n        if self.__compact_spots.get(key).is_free():\n          self.__display_board.set_compact_free_spot(\n            self.__compact_spots.get(key))\n\n      self.__display_board.show_empty_spot_number()\n\n  def free_spot(self, spot):\n    spot.remove_vehicle()\n    switcher = {\n      ParkingSpotType.HANDICAPPED: self.__free_handicapped_spot_count += 1,\n      ParkingSpotType.COMPACT: self.__free_compact_spot_count += 1,\n      ParkingSpotType.LARGE: self.__free_large_spot_count += 1,\n      ParkingSpotType.MOTORBIKE: self.__free_motorbike_spot_count += 1,\n      ParkingSpotType.ELECTRIC: self.__free_electric_spot_count += 1,\n    }\n\n    switcher(spot.get_type(), 'Wrong parking spot type!')",
    "subPath": "parkingFloor",
    "fileName": "solution.py"
  },
  "parkingLot_java": {
    "language": "java",
    "code": "public class ParkingLot {\n  private String name;\n  private Location address;\n  private ParkingRate parkingRate;\n\n  private int compactSpotCount;\n  private int largeSpotCount;\n  private int motorbikeSpotCount;\n  private int electricSpotCount;\n  private final int maxCompactCount;\n  private final int maxLargeCount;\n  private final int maxMotorbikeCount;\n  private final int maxElectricCount;\n\n  private HashMap<String, EntrancePanel> entrancePanels;\n  private HashMap<String, ExitPanel> exitPanels;\n  private HashMap<String, ParkingFloor> parkingFloors;\n\n  // all active parking tickets, identified by their ticketNumber\n  private HashMap<String, ParkingTicket> activeTickets;\n\n  // singleton ParkingLot to ensure only one object of ParkingLot in the system,\n  // all entrance panels will use this object to create new parking ticket: getNewParkingTicket(),\n  // similarly exit panels will also use this object to close parking tickets\n  private static ParkingLot parkingLot = null;\n\n  // private constructor to restrict for singleton\n  private ParkingLot() {\n    // 1. initialize variables: read name, address and parkingRate from database\n    // 2. initialize parking floors: read the parking floor map from database,\n    //  this map should tell how many parking spots are there on each floor. This\n    //  should also initialize max spot counts too.\n    // 3. initialize parking spot counts by reading all active tickets from database\n    // 4. initialize entrance and exit panels: read from database\n  }\n\n  // static method to get the singleton instance of StockExchange\n  public static ParkingLot getInstance() {\n    if (parkingLot == null) {\n      parkingLot = new ParkingLot();\n    }\n    return parkingLot;\n  }\n\n  // note that the following method is 'synchronized' to allow multiple entrances\n  // panels to issue a new parking ticket without interfering with each other\n  public synchronized ParkingTicket getNewParkingTicket(Vehicle vehicle) throws ParkingFullException {\n    if (this.isFull(vehicle.getType())) {\n      throw new ParkingFullException();\n    }\n    ParkingTicket ticket = new ParkingTicket();\n    vehicle.assignTicket(ticket);\n    ticket.saveInDB();\n    // if the ticket is successfully saved in the database, we can increment the parking spot count\n    this.incrementSpotCount(vehicle.getType());\n    this.activeTickets.put(ticket.getTicketNumber(), ticket);\n    return ticket;\n  }\n\n  public boolean isFull(VehicleType type) {\n    // trucks and vans can only be parked in LargeSpot\n    if (type == VehicleType.Truck || type == VehicleType.Van) {\n      return largeSpotCount >= maxLargeCount;\n    }\n\n    // motorbikes can only be parked at motorbike spots\n    if (type == VehicleType.Motorbike) {\n      return motorbikeSpotCount >= maxMotorbikeCount;\n    }\n\n    // cars can be parked at compact or large spots\n    if (type == VehicleType.Car) {\n      return (compactSpotCount + largeSpotCount) >= (maxCompactCount + maxLargeCount);\n    }\n\n    // electric car can be parked at compact, large or electric spots\n    return (compactSpotCount + largeSpotCount + electricSpotCount) >= (maxCompactCount + maxLargeCount\n        + maxElectricCount);\n  }\n\n  // increment the parking spot count based on the vehicle type\n  private boolean incrementSpotCount(VehicleType type) {\n    if (type == VehicleType.Truck || type == VehicleType.Van) {\n      largeSpotCount++;\n    } else if (type == VehicleType.Motorbike) {\n      motorbikeSpotCount++;\n    } else if (type == VehicleType.Car) {\n      if (compactSpotCount < maxCompactCount) {\n        compactSpotCount++;\n      } else {\n        largeSpotCount++;\n      }\n    } else { // electric car\n      if (electricSpotCount < maxElectricCount) {\n        electricSpotCount++;\n      } else if (compactSpotCount < maxCompactCount) {\n        compactSpotCount++;\n      } else {\n        largeSpotCount++;\n      }\n    }\n  }\n\n  public boolean isFull() {\n    for (String key : parkingFloors.keySet()) {\n      if (!parkingFloors.get(key).isFull()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public void addParkingFloor(ParkingFloor floor) {\n    /* store in database */ }\n\n  public void addEntrancePanel(EntrancePanel entrancePanel) {\n    /* store in database */ }\n\n  public void addExitPanel(ExitPanel exitPanel) {\n    /* store in database */ }\n}",
    "subPath": "parkingLot",
    "fileName": "solution.java"
  },
  "parkingLot_py": {
    "language": "py",
    "code": "import threading\n\nclass ParkingLot:\n  # singleton ParkingLot to ensure only one object of ParkingLot in the system,\n  # all entrance panels will use this object to create new parking ticket: get_new_parking_ticket(),\n  # similarly exit panels will also use this object to close parking tickets\n  instance = None\n\n  class __OnlyOne:\n    def __init__(self, name, address):\n      # 1. initialize variables: read name, address and parking_rate from database\n      # 2. initialize parking floors: read the parking floor map from database,\n      #    this map should tell how many parking spots are there on each floor. This\n      #    should also initialize max spot counts too.\n      # 3. initialize parking spot counts by reading all active tickets from database\n      # 4. initialize entrance and exit panels: read from database\n\n      self.__name = name\n      self.__address = address\n      self.__parking_rate = ParkingRate()\n\n      self.__compact_spot_count = 0\n      self.__large_spot_count = 0\n      self.__motorbike_spot_count = 0\n      self.__electric_spot_count = 0\n      self.__max_compact_count = 0\n      self.__max_large_count = 0\n      self.__max_motorbike_count = 0\n      self.__max_electric_count = 0\n\n      self.__entrance_panels = {}\n      self.__exit_panels = {}\n      self.__parking_floors = {}\n\n      # all active parking tickets, identified by their ticket_number\n      self.__active_tickets = {}\n\n      self.__lock = threading.Lock()\n\n  def __init__(self, name, address):\n    if not ParkingLot.instance:\n      ParkingLot.instance = ParkingLot.__OnlyOne(name, address)\n    else:\n      ParkingLot.instance.__name = name\n      ParkingLot.instance.__address = address\n\n  def __getattr__(self, name):\n    return getattr(self.instance, name)\n\n  def get_new_parking_ticket(self, vehicle):\n    if self.is_full(vehicle.get_type()):\n      raise Exception('Parking full!')\n    # synchronizing to allow multiple entrances panels to issue a new\n    # parking ticket without interfering with each other\n    self.__lock.acquire()\n    ticket = ParkingTicket()\n    vehicle.assign_ticket(ticket)\n    ticket.save_in_DB()\n    # if the ticket is successfully saved in the database, we can increment the parking spot count\n    self.__increment_spot_count(vehicle.get_type())\n    self.__active_tickets.put(ticket.get_ticket_number(), ticket)\n    self.__lock.release()\n    return ticket\n\n  def is_full(self, type):\n    # trucks and vans can only be parked in LargeSpot\n    if type == VehicleType.Truck or type == VehicleType.Van:\n      return self.__large_spot_count >= self.__max_large_count\n\n    # motorbikes can only be parked at motorbike spots\n    if type == VehicleType.Motorbike:\n      return self.__motorbike_spot_count >= self.__max_motorbike_count\n\n    # cars can be parked at compact or large spots\n    if type == VehicleType.Car:\n      return (self.__compact_spot_count + self.__large_spot_count) >= (self.__max_compact_count + self.__max_large_count)\n\n    # electric car can be parked at compact, large or electric spots\n    return (self.__compact_spot_count + self.__large_spot_count + self.__electric_spot_count) >= (self.__max_compact_count + self.__max_large_count + self.__max_electric_count)\n\n  # increment the parking spot count based on the vehicle type\n  def increment_spot_count(self, type):\n    if type == VehicleType.Truck or type == VehicleType.Van:\n      large_spot_count += 1\n    elif type == VehicleType.Motorbike:\n      motorbike_spot_count += 1\n    elif type == VehicleType.Car:\n      if self.__compact_spot_count < self.__max_compact_count:\n        compact_spot_count += 1\n      else:\n        large_spot_count += 1\n    else:  # electric car\n      if self.__electric_spot_count < self.__max_electric_count:\n        electric_spot_count += 1\n      elif self.__compact_spot_count < self.__max_compact_count:\n        compact_spot_count += 1\n      else:\n        large_spot_count += 1\n\n  def is_full(self):\n    for key in self.__parking_floors:\n      if not self.__parking_floors.get(key).is_full():\n        return False\n    return True\n\n  def add_parking_floor(self, floor):\n    # store in database\n    None\n\n  def add_entrance_panel(self, entrance_panel):\n    # store in database\n    None\n\n  def add_exit_panel(self,  exit_panel):\n    # store in database\n    None",
    "subPath": "parkingLot",
    "fileName": "solution.py"
  },
  "parkingSpot_java": {
    "language": "java",
    "code": "public abstract class ParkingSpot {\n  private String number;\n  private boolean free;\n  private Vehicle vehicle;\n  private final ParkingSpotType type;\n\n  public boolean IsFree();\n\n  public ParkingSpot(ParkingSpotType type) {\n    this.type = type;\n  }\n\n  public boolean assignVehicle(Vehicle vehicle) {\n    this.vehicle = vehicle;\n    free = false;\n  }\n\n  public boolean removeVehicle() {\n    this.vehicle = null;\n    free = true;\n  }\n}\n\npublic class HandicappedSpot extends ParkingSpot {\n  public HandicappedSpot() {\n    super(ParkingSpotType.HANDICAPPED);\n  }\n}\n\npublic class CompactSpot extends ParkingSpot {\n  public CompactSpot() {\n    super(ParkingSpotType.COMPACT);\n  }\n}\n\npublic class LargeSpot extends ParkingSpot {\n  public LargeSpot() {\n    super(ParkingSpotType.LARGE);\n  }\n}\n\npublic class MotorbikeSpot extends ParkingSpot {\n  public MotorbikeSpot() {\n    super(ParkingSpotType.MOTORBIKE);\n  }\n}\n\npublic class ElectricSpot extends ParkingSpot {\n  public ElectricSpot() {\n    super(ParkingSpotType.ELECTRIC);\n  }\n}",
    "subPath": "parkingSpot",
    "fileName": "solution.java"
  },
  "parkingSpot_py": {
    "language": "py",
    "code": "class ParkingSpot(ABC):\n  def __init__(self, number, parking_spot_type):\n    self.__number = number\n    self.__free = True\n    self.__vehicle = None\n    self.__parking_spot_type = parking_spot_type\n\n  def is_free(self):\n    return self.__free\n\n  def assign_vehicle(self, vehicle):\n    self.__vehicle = vehicle\n    free = False\n\n  def remove_vehicle(self):\n    self.__vehicle = None\n    free = True\n\n\nclass HandicappedSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.HANDICAPPED)\n\n\nclass CompactSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.COMPACT)\n\n\nclass LargeSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.LARGE)\n\n\nclass MotorbikeSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.MOTORBIKE)\n\n\nclass ElectricSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.ELECTRIC)",
    "subPath": "parkingSpot",
    "fileName": "solution.py"
  },
  "vehicle_java": {
    "language": "java",
    "code": "public abstract class Vehicle {\n  private String licenseNumber;\n  private final VehicleType type;\n  private ParkingTicket ticket;\n\n  public Vehicle(VehicleType type) {\n    this.type = type;\n  }\n\n  public void assignTicket(ParkingTicket ticket) {\n    this.ticket = ticket;\n  }\n}\n\npublic class Car extends Vehicle {\n  public Car() {\n    super(VehicleType.CAR);\n  }\n}\n\npublic class Van extends Vehicle {\n  public Van() {\n    super(VehicleType.VAN);\n  }\n}\n\npublic class Truck extends Vehicle {\n  public Truck() {\n    super(VehicleType.TRUCK);\n  }\n}\n\n// Similarly we can define classes for Motorcycle and Electric vehicles",
    "subPath": "vehicle",
    "fileName": "solution.java"
  },
  "vehicle_py": {
    "language": "py",
    "code": "from abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n  def __init__(self, license_number, vehicle_type, ticket=None):\n    self.__license_number = license_number\n    self.__type = vehicle_type\n    self.__ticket = ticket\n\n  def assign_ticket(self, ticket):\n    self.__ticket = ticket\n\n\nclass Car(Vehicle):\n  def __init__(self, license_number, ticket=None):\n    super().__init__(license_number, VehicleType.CAR, ticket)\n\n\nclass Van(Vehicle):\n  def __init__(self, license_number, ticket=None):\n    super().__init__(license_number, VehicleType.VAN, ticket)\n\n\nclass Truck(Vehicle):\n  def __init__(self, license_number, ticket=None):\n    super().__init__(license_number, VehicleType.TRUCK, ticket)\n\n# Similarly we can define classes for Motorcycle and Electric vehicles",
    "subPath": "vehicle",
    "fileName": "solution.py"
  }
}