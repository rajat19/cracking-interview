{
  "accounts_java": {
    "language": "java",
    "code": "// For simplicity, we are not defining getter and setter functions. The reader can\n// assume that all class attributes are private and accessed through their respective\n// public getter methods and modified only through their public methods function.\n\npublic abstract class Account {\n  private String id;\n  private String password;\n  private AccountStatus status;\n  private Person person;\n\n  public boolean resetPassword();\n}\n\npublic class Librarian extends Account {\n  public boolean addBookItem(BookItem bookItem);\n\n  public boolean blockMember(Member member);\n\n  public boolean unBlockMember(Member member);\n}\n\npublic class Member extends Account {\n  private Date dateOfMembership;\n  private int totalBooksCheckedout;\n\n  public int getTotalBooksCheckedout();\n\n  public boolean reserveBookItem(BookItem bookItem);\n\n  private void incrementTotalBooksCheckedout();\n\n  public boolean checkoutBookItem(BookItem bookItem) {\n\tif (this.getTotalBooksCheckedOut() >= Constants.MAX_BOOKS_ISSUED_TO_A_USER) {\n\t  ShowError(\"The user has already checked-out maximum number of books\");\n\t  return false;\n\t}\n\tBookReservation bookReservation = BookReservation.fetchReservationDetails(bookItem.getBarcode());\n\tif (bookReservation != null && bookReservation.getMemberId() != this.getId()) {\n\t  // book item has a pending reservation from another user\n\t  ShowError(\"This book is reserved by another member\");\n\t  return false;\n\t} else if (bookReservation != null) {\n\t  // book item has a pending reservation from the give member, update it\n\t  bookReservation.updateStatus(ReservationStatus.COMPLETED);\n\t}\n\n\tif (!bookItem.checkout(this.getId())) {\n\t  return false;\n\t}\n\n\tthis.incrementTotalBooksCheckedout();\n\treturn true;\n  }\n\n  private void checkForFine(String bookItemBarcode) {\n\tBookLending bookLending = BookLending.fetchLendingDetails(bookItemBarcode);\n\tDate dueDate = bookLending.getDueDate();\n\tDate today = new Date();\n\t// check if the book has been returned within the due date\n\tif (today.compareTo(dueDate) > 0) {\n\t  long diff = todayDate.getTime() - dueDate.getTime();\n\t  long diffDays = diff / (24 * 60 * 60 * 1000);\n\t  Fine.collectFine(memberId, diffDays);\n\t}\n  }\n\n  public void returnBookItem(BookItem bookItem) {\n\tthis.checkForFine(bookItem.getBarcode());\n\tBookReservation bookReservation = BookReservation.fetchReservationDetails(bookItem.getBarcode());\n\tif (bookReservation != null) {\n\t  // book item has a pending reservation\n\t  bookItem.updateBookItemStatus(BookStatus.RESERVED);\n\t  bookReservation.sendBookAvailableNotification();\n\t}\n\tbookItem.updateBookItemStatus(BookStatus.AVAILABLE);\n  }\n\n  public bool renewBookItem(BookItem bookItem) {\n\tthis.checkForFine(bookItem.getBarcode());\n\tBookReservation bookReservation = BookReservation.fetchReservationDetails(bookItem.getBarcode());\n\t// check if this book item has a pending reservation from another member\n\tif (bookReservation != null && bookReservation.getMemberId() != this.getMemberId()) {\n\t  ShowError(\"This book is reserved by another member\");\n\t  member.decrementTotalBooksCheckedout();\n\t  bookItem.updateBookItemState(BookStatus.RESERVED);\n\t  bookReservation.sendBookAvailableNotification();\n\t  return false;\n\t} else if (bookReservation != null) {\n\t  // book item has a pending reservation from this member\n\t  bookReservation.updateStatus(ReservationStatus.COMPLETED);\n\t}\n\tBookLending.lendBook(bookItem.getBarCode(), this.getMemberId());\n\tbookItem.updateDueDate(LocalDate.now().plusDays(Constants.MAX_LENDING_DAYS));\n\treturn true;\n  }\n}",
    "subPath": "accounts",
    "fileName": "solution.java"
  },
  "accounts_py": {
    "language": "py",
    "code": "# For simplicity, we are not defining getter and setter functions. The reader can\n# assume that all class attributes are private and accessed through their respective\n# public getter methods and modified only through their public methods function.\n\nfrom abc import ABC, abstractmethod\n\nclass Account(ABC):\n  def __init__(self, id, password, person, status=AccountStatus.Active):\n    self.__id = id\n    self.__password = password\n    self.__status = status\n    self.__person = person\n\n  def reset_password(self):\n    None\n\n\nclass Librarian(Account):\n  def __init__(self, id, password, person, status=AccountStatus.Active):\n    super().__init__(id, password, person, status)\n\n  def add_book_item(self, book_item):\n    None\n\n  def block_member(self, member):\n    None\n\n  def un_block_member(self, member):\n    None\n\n\nclass Member(Account):\n  def __init__(self, id, password, person, status=AccountStatus.Active):\n    super().__init__(id, password, person, status)\n    self.__date_of_membership = datetime.date.today()\n    self.__total_books_checkedout = 0\n\n  def get_total_books_checkedout(self):\n    return self.__total_books_checkedout\n\n  def reserve_book_item(self, book_item):\n    None\n\n  def increment_total_books_checkedout(self):\n    None\n\n  def renew_book_item(self, book_item):\n    None\n\n  def checkout_book_item(self, book_item):\n    if self.get_total_books_checked_out() >= Constants.MAX_BOOKS_ISSUED_TO_A_USER:\n      print(\"The user has already checked-out maximum number of books\")\n      return False\n    book_reservation = BookReservation.fetch_reservation_details(\n      book_item.get_barcode())\n    if book_reservation != None and book_reservation.get_member_id() != self.get_id():\n      # book item has a pending reservation from another user\n      print(\"self book is reserved by another member\")\n      return False\n    elif book_reservation != None:\n      # book item has a pending reservation from the give member, update it\n      book_reservation.update_status(ReservationStatus.COMPLETED)\n\n    if not book_item.checkout(self.get_id()):\n      return False\n\n    self.increment_total_books_checkedout()\n    return True\n\n  def check_for_fine(self, book_item_barcode):\n    book_lending = BookLending.fetch_lending_details(book_item_barcode)\n    due_date = book_lending.get_due_date()\n    today = datetime.date.today()\n    # check if the book has been returned within the due date\n    if today > due_date:\n      diff = today - due_date\n      diff_days = diff.days\n      Fine.collect_fine(self.get_member_id(), diff_days)\n\n  def return_book_item(self, book_item):\n    self.check_for_fine(book_item.get_barcode())\n    book_reservation = BookReservation.fetch_reservation_details(\n      book_item.get_barcode())\n    if book_reservation != None:\n      # book item has a pending reservation\n      book_item.update_book_item_status(BookStatus.RESERVED)\n      book_reservation.send_book_available_notification()\n    book_item.update_book_item_status(BookStatus.AVAILABLE)\n\n  def renew_book_item(self, book_item):\n    self.check_for_fine(book_item.get_barcode())\n    book_reservation = BookReservation.fetch_reservation_details(\n      book_item.get_barcode())\n    # check if self book item has a pending reservation from another member\n    if book_reservation != None and book_reservation.get_member_id() != self.get_member_id():\n      print(\"self book is reserved by another member\")\n      self.decrement_total_books_checkedout()\n      book_item.update_book_item_state(BookStatus.RESERVED)\n      book_reservation.send_book_available_notification()\n      return False\n    elif book_reservation != None:\n      # book item has a pending reservation from self member\n      book_reservation.update_status(ReservationStatus.COMPLETED)\n    BookLending.lend_book(book_item.get_bar_code(), self.get_member_id())\n    book_item.update_due_date(\n      datetime.datetime.now().AddDays(Constants.MAX_LENDING_DAYS))\n    return True",
    "subPath": "accounts",
    "fileName": "solution.py"
  },
  "books_java": {
    "language": "java",
    "code": "public abstract class Book {\n  private String ISBN;\n  private String title;\n  private String subject;\n  private String publisher;\n  private String language;\n  private int numberOfPages;\n  private List<Author> authors;\n}\n\npublic class BookItem extends Book {\n  private String barcode;\n  private boolean isReferenceOnly;\n  private Date borrowed;\n  private Date dueDate;\n  private double price;\n  private BookFormat format;\n  private BookStatus status;\n  private Date dateOfPurchase;\n  private Date publicationDate;\n  private Rack placedAt;\n\n  public boolean checkout(String memberId) {\n    if(bookItem.getIsReferenceOnly()) {\n      ShowError(\"This book is Reference only and can't be issued\");\n      return false;\n    }\n    if(!BookLending.lendBook(this.getBarCode(), memberId)){\n      return false;\n    }\n    this.updateBookItemStatus(BookStatus.LOANED);\n    return true;\n  }\n}\n\npublic class Rack {\n  private int number;\n  private String locationIdentifier;\n}",
    "subPath": "books",
    "fileName": "solution.java"
  },
  "books_py": {
    "language": "py",
    "code": "from abc import ABC, abstractmethod\n\nclass Book(ABC):\n  def check_for_fine(self, ISBN, title, subject, publisher, language, number_of_pages):\n    self.__ISBN = ISBN\n    self.__title = title\n    self.__subject = subject\n    self.__publisher = publisher\n    self.__language = language\n    self.__number_of_pages = number_of_pages\n    self.__authors = []\n\n\nclass BookItem(Book):\n  def check_for_fine(self, barcode, is_reference_only, borrowed, due_date, price, book_format, status, date_of_purchase, publication_date, placed_at):\n    self.__barcode = barcode\n    self.__is_reference_only = is_reference_only\n    self.__borrowed = borrowed\n    self.__due_date = due_date\n    self.__price = price\n    self.__format = book_format\n    self.__status = status\n    self.__date_of_purchase = date_of_purchase\n    self.__publication_date = publication_date\n    self.__placed_at = placed_at\n\n  def checkout(self, member_id):\n    if self.get_is_reference_only():\n      print(\"self book is Reference only and can't be issued\")\n      return False\n    if not BookLending.lend_book(self.get_bar_code(), member_id):\n      return False\n    self.update_book_item_status(BookStatus.LOANED)\n    return True\n\n\nclass Rack:\n  def check_for_fine(self, number, location_identifier):\n    self.__number = number\n    self.__location_identifier = location_identifier",
    "subPath": "books",
    "fileName": "solution.py"
  },
  "enums_java": {
    "language": "java",
    "code": "public enum BookFormat {\n    HARDCOVER,\n    PAPERBACK,\n    AUDIO_BOOK,\n    EBOOK,\n    NEWSPAPER,\n    MAGAZINE,\n    JOURNAL\n}\n\npublic enum BookStatus {\n    AVAILABLE,\n    RESERVED,\n    LOANED,\n    LOST\n}\n\npublic enum ReservationStatus{\n    WAITING,\n    PENDING,\n    CANCELED,\n    NONE\n}\n\npublic enum AccountStatus{\n    ACTIVE,\n    CLOSED,\n    CANCELED,\n    BLACKLISTED,\n    NONE\n}\n\npublic class Address {\n    private String streetAddress;\n    private String city;\n    private String state;\n    private String zipCode;\n    private String country;\n}\n\npublic class Person {\n    private String name;\n    private Address address;\n    private String email;\n    private String phone;\n}\n\npublic class Constants {\n    public static final int MAX_BOOKS_ISSUED_TO_A_USER = 5;\n    public static final int MAX_LENDING_DAYS = 10;\n}",
    "subPath": "enums",
    "fileName": "solution.java"
  },
  "enums_py": {
    "language": "py",
    "code": "class BookFormat(Enum):\n  HARDCOVER, PAPERBACK, AUDIO_BOOK, EBOOK, NEWSPAPER, MAGAZINE, JOURNAL = 1, 2, 3, 4, 5, 6, 7\n\n\nclass BookStatus(Enum):\n  AVAILABLE, RESERVED, LOANED, LOST = 1, 2, 3, 4\n\n\nclass ReservationStatus(Enum):\n  WAITING, PENDING, CANCELED, NONE = 1, 2, 3, 4\n\n\nclass AccountStatus(Enum):\n  ACTIVE, CLOSED, CANCELED, BLACKLISTED, NONE = 1, 2, 3, 4, 5\n\n\nclass Address:\n  def __init__(self, street, city, state, zip_code, country):\n    self.__street_address = street\n    self.__city = city\n    self.__state = state\n    self.__zip_code = zip_code\n    self.__country = country\n\n\nclass Person(ABC):\n  def __init__(self, name, address, email, phone):\n    self.__name = name\n    self.__address = address\n    self.__email = email\n    self.__phone = phone\n\n\nclass Constants:\n  self.MAX_BOOKS_ISSUED_TO_A_USER = 5\n  self.MAX_LENDING_DAYS = 10",
    "subPath": "enums",
    "fileName": "solution.py"
  },
  "reservation_java": {
    "language": "java",
    "code": "public class BookReservation {\n  private Date creationDate;\n  private ReservationStatus status;\n  private String bookItemBarcode;\n  private String memberId;\n\n  public static BookReservation fetchReservationDetails(String barcode);\n}\n\npublic class BookLending {\n  private Date creationDate;\n  private Date dueDate;\n  private Date returnDate;\n  private String bookItemBarcode;\n  private String memberId;\n\n  public static void lendBook(String barcode, String memberId);\n  public static BookLending fetchLendingDetails(String barcode);\n}\n\npublic class Fine {\n  private Date creationDate;\n  private double bookItemBarcode;\n  private String memberId;\n\n  public static void collectFine(String memberId, long days) {}\n}",
    "subPath": "reservation",
    "fileName": "solution.java"
  },
  "reservation_py": {
    "language": "py",
    "code": "class BookReservation:\n  def check_for_fine(self, creation_date, status, book_item_barcode, member_id):\n    self.__creation_date = creation_date\n    self.__status = status\n    self.__book_item_barcode = book_item_barcode\n    self.__member_id = member_id\n\n  def fetch_reservation_details(self, barcode):\n    None\n\n\nclass BookLending:\n  def check_for_fine(self, creation_date, due_date, book_item_barcode, member_id):\n    self.__creation_date = creation_date\n    self.__due_date = due_date\n    self.__return_date = None\n    self.__book_item_barcode = book_item_barcode\n    self.__member_id = member_id\n\n  def lend_book(self, barcode, member_id):\n    None\n\n  def fetch_lending_details(self, barcode):\n    None\n\n\nclass Fine:\n  def check_for_fine(self, creation_date, book_item_barcode, member_id):\n    self.__creation_date = creation_date\n    self.__book_item_barcode = book_item_barcode\n    self.__member_id = member_id\n\n  def collect_fine(self, member_id, days):\n    None",
    "subPath": "reservation",
    "fileName": "solution.py"
  },
  "search_java": {
    "language": "java",
    "code": "public interface Search {\n  public List<Book> searchByTitle(String title);\n  public List<Book> searchByAuthor(String author);\n  public List<Book> searchBySubject(String subject);\n  public List<Book> searchByPubDate(Date publishDate);\n}\n\npublic class Catalog implements Search {\n  private HashMap<String, List<Book>> bookTitles;\n  private HashMap<String, List<Book>> bookAuthors;\n  private HashMap<String, List<Book>> bookSubjects;\n  private HashMap<String, List<Book>> bookPublicationDates;\n\n  public List<Book> searchByTitle(String query) {\n    // return all books containing the string query in their title.\n    return bookTitles.get(query);\n  }\n\n  public List<Book> searchByAuthor(String query) {\n    // return all books containing the string query in their author's name.\n    return bookAuthors.get(query);\n  }\n}",
    "subPath": "search",
    "fileName": "solution.java"
  },
  "search_py": {
    "language": "py",
    "code": "from abc import ABC, abstractmethod\n\nclass Search(ABC):\n  def search_by_title(self, title):\n    None\n\n  def search_by_author(self, author):\n    None\n\n  def search_by_subject(self, subject):\n    None\n\n  def search_by_pub_date(self, publish_date):\n    None\n\n\nclass Catalog(Search):\n  def check_for_fine(self):\n    self.__book_titles = {}\n    self.__book_authors = {}\n    self.__book_subjects = {}\n    self.__book_publication_dates = {}\n\n  def search_by_title(self, query):\n    # return all books containing the string query in their title.\n    return self.__book_titles.get(query)\n\n  def search_by_author(self, query):\n    # return all books containing the string query in their author's name.\n    return self.__book_authors.get(query)",
    "subPath": "search",
    "fileName": "solution.py"
  }
}