{
  "cpp": {
    "language": "cpp",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        int maxVal[1] = {INT_MIN};\n        maxPathDown(root, maxVal);\n        return maxVal[0];\n    }\n\n    int maxPathDown(TreeNode* root, int* maxVal) {\n        if (root == nullptr) return 0;\n        int left = max(0, maxPathDown(root->left, maxVal));\n        int right = max(0, maxPathDown(root->right, maxVal));\n        maxVal[0] = max(maxVal[0], left+right+root->val);\n        return max(left, right) + root->val;\n    }\n};",
    "subPath": "",
    "fileName": "solution.cpp"
  },
  "java": {
    "language": "java",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxPathSum(TreeNode root) {\n        int[] maxVal = new int[]{Integer.MIN_VALUE};\n        maxPathDown(root, maxVal);\n        return maxVal[0];\n    }\n\n    private int maxPathDown(TreeNode root, int[] maxVal) {\n        if (root == null) return 0;\n        int left = Math.max(0, maxPathDown(root.left, maxVal));\n        int right = Math.max(0, maxPathDown(root.right, maxVal));\n        maxVal[0] = Math.max(maxVal[0], left+right+root.val);\n        return Math.max(left, right) + root.val;\n    }\n}",
    "subPath": "",
    "fileName": "solution.java"
  },
  "py": {
    "language": "py",
    "code": "from typing import Optional, List\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        max_value = [float('-inf')]\n        self.maxPathDown(root, max_value)\n        return int(max_value[0])\n\n    def maxPathDown(self, node: Optional[TreeNode], max_value: List[float]):\n        if not node:\n            return 0\n        left = max(0, self.maxPathDown(node.left, max_value))\n        right = max(0, self.maxPathDown(node.right, max_value))\n        max_value[0] = max(max_value[0], left + right + node.val)\n        return max(left, right) + node.val",
    "subPath": "",
    "fileName": "solution.py"
  },
  "ts": {
    "language": "ts",
    "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxPathSum(root: TreeNode | null): number {\n    const maxVal = [Number.MIN_SAFE_INTEGER];\n    const ret = dfs(root, maxVal);\n    return maxVal[0];\n};\n\nfunction dfs(root: TreeNode | null, maxVal: number[]): number {\n    if (root == null) return 0;\n    const left = Math.max(0, dfs(root.left, maxVal));\n    const right = Math.max(0, dfs(root.right, maxVal));\n\n    maxVal[0] = Math.max(maxVal[0], left + right + root.val);\n    return Math.max(left, right) + root.val;\n}",
    "subPath": "",
    "fileName": "solution.ts"
  }
}