{
  "c": {
    "language": "c",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* reverseKGroup(struct ListNode* head, int k){\n    if (head == NULL) return head;\n    int count = 0;\n    struct ListNode* end = head;\n    while(count++ < k) {\n        if (end == NULL) return head;\n        end = end->next;\n    }\n    struct ListNode *next, *curr = head, *prev = reverseKGroup(end, k);\n    while(curr != end) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}",
    "subPath": "",
    "fileName": "solution.c"
  },
  "cpp": {
    "language": "cpp",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if (head == NULL) return head;\n        int count = 0;\n        ListNode* end = head;\n        while(count++ < k) {\n            if (end == NULL) return head;\n            end = end->next;\n        }\n        ListNode *curr = head, *prev = reverseKGroup(end, k);\n        while(curr != end) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};",
    "subPath": "",
    "fileName": "solution.cpp"
  },
  "java": {
    "language": "java",
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null) return head;\n        ListNode end = head;\n        int i = 0;\n        while(i++ < k) {\n            if (end == null) return head;\n            end = end.next;\n        }\n        ListNode prev = reverseKGroup(end, k), curr = head;\n        while(curr != end) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}",
    "subPath": "",
    "fileName": "solution.java"
  },
  "py": {
    "language": "py",
    "code": "from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        count, end = 0, head\n        while count < k:\n            if end is None:\n                return head\n            end = end.next\n            count += 1\n        curr, prev = head, self.reverseKGroup(end, k)\n        while curr != end:\n            next = curr.next\n            curr.next = prev\n            prev, curr = curr, next\n        return prev",
    "subPath": "",
    "fileName": "solution.py"
  }
}