{
  "cpp": {
    "language": "cpp",
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if (!root) {\n            return root;\n        }\n        Node *level = root;\n        while(level) {\n            Node *curr = level;\n            while(curr) {\n                if (curr->left) {\n                    curr->left->next = curr->right;\n                }\n                if (curr->right && curr->next) {\n                    curr->right->next = curr->next->left;\n                }\n                curr = curr->next;\n            }\n            level = level->left;\n        }\n        return root;\n    }\n};",
    "subPath": "",
    "fileName": "solution.cpp"
  },
  "go": {
    "language": "go",
    "code": "package populating_next_right_pointers_in_each_node\n\ntype Node struct {\n\tVal int\n\tLeft *Node\n\tRight *Node\n\tNext *Node\n}\n\nfunc connect(root *Node) *Node {\n\tlevel := root\n\tfor level != nil {\n\t\tcurr := level\n\t\tfor curr != nil {\n\t\t\tif curr.Left != nil {\n\t\t\t\tcurr.Left.Next = curr.Right\n\t\t\t}\n\t\t\tif curr.Right != nil && curr.Next != nil {\n\t\t\t\tcurr.Right.Next = curr.Next.Left\n\t\t\t}\n\t\t\tcurr = curr.Next\n\t\t}\n\t\tlevel = level.Left\n\t}\n\treturn root\n}",
    "subPath": "",
    "fileName": "solution.go"
  },
  "java": {
    "language": "java",
    "code": "class Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node(int _val) {\n        val = _val;\n    }\n};\n\nclass Solution {\n    public Node connect(Node root) {\n        Node level=root;\n        while(level!=null){\n            Node cur=level;\n            while(cur!=null){\n                if(cur.left!=null) cur.left.next=cur.right;\n                if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\n\n                cur=cur.next;\n            }\n            level=level.left;\n        }\n        return root;\n    }\n}",
    "subPath": "",
    "fileName": "solution.java"
  },
  "py": {
    "language": "py",
    "code": "class Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass Solution:\n    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':\n        level = root\n        while level is not None:\n            curr = level\n            while curr is not None:\n                if curr.left is not None:\n                    curr.left.next = curr.right\n                if curr.right is not None and curr.next is not None:\n                    curr.right.next = curr.next.left\n                curr = curr.next\n            level = level.left\n        return root",
    "subPath": "",
    "fileName": "solution.py"
  }
}