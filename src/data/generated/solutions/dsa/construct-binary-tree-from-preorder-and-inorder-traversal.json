{
  "cpp": {
    "language": "cpp",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        return buildTree(preorder, inorder, 0, 0, inorder.size() - 1);\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder, int prestart, int instart, int inend) {\n        if (prestart > preorder.size() || instart > inend) {\n            return nullptr;\n        }\n        TreeNode* root = new TreeNode(preorder[prestart]);\n        int index = instart;\n        while(index <= inend) {\n            if (inorder[index] == preorder[prestart]) {\n                break;\n            }\n            index++;\n        }\n        root->left = buildTree(preorder, inorder, prestart+1, instart, index-1);\n        root->right = buildTree(preorder, inorder, prestart+index-instart+1, index+1, inend);\n        return root;\n    }\n};",
    "subPath": "",
    "fileName": "solution.cpp"
  },
  "java": {
    "language": "java",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return buildTree(preorder, inorder, 0, 0, inorder.length-1);\n    }\n\n    private TreeNode buildTree(int[] preorder, int[] inorder, int prestart, int instart, int inend) {\n        if (prestart > preorder.length || instart > inend) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[prestart]);\n        int inroot = instart;\n        while(inroot <= inend) {\n            if (inorder[inroot] == preorder[prestart]) {\n                break;\n            }\n            inroot++;\n        }\n        int count = inroot - instart;\n        root.left = buildTree(preorder, inorder, prestart+1, instart, inroot-1);\n        root.right = buildTree(preorder, inorder, prestart+inroot-instart+1, inroot+1, inend);\n        return root;\n    }\n}",
    "subPath": "",
    "fileName": "solution.java"
  },
  "py": {
    "language": "py",
    "code": "from typing import List, Optional\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        return self.helper(preorder, inorder, 0, 0, len(inorder) - 1)\n\n    def helper(self, preorder, inorder, prestart, instart, inend):\n        if prestart > len(preorder) or instart > inend:\n            return None\n        root = TreeNode(preorder[prestart])\n        index = instart\n        while index <= inend:\n            if inorder[index] == preorder[prestart]:\n                break\n            index += 1\n        root.left = self.helper(preorder, inorder, prestart+1, instart, index-1);\n        root.right = self.helper(preorder, inorder, prestart+index-instart+1, index+1, inend);\n        return root",
    "subPath": "",
    "fileName": "solution.py"
  }
}