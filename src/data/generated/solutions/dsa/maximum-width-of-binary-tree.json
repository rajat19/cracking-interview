{
  "java": {
    "language": "java",
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int widthOfBinaryTree(TreeNode root) {\n        Map<TreeNode, Integer> map = new HashMap<>();\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        map.put(root, 1);\n        int maxWidth = 0, start=0, end=0;\n        while(!q.isEmpty()) {\n            int n = q.size();\n            for(int i=0; i<n; i++) {\n                TreeNode node = q.poll();\n                if (i==0) start = map.get(node);\n                if (i==n-1) end = map.get(node);\n                if (node.left != null) {\n                    q.offer(node.left);\n                    map.put(node.left, 2*map.get(node));\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                    map.put(node.right, 1 + 2*map.get(node));\n                }\n            }\n            maxWidth = Math.max(maxWidth, end-start+1);\n        }\n        return maxWidth;\n    }\n}",
    "subPath": "",
    "fileName": "solution.java"
  },
  "py": {
    "language": "py",
    "code": "from typing import  Optional\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        mp, q = {}, []\n        if root is None:\n            return 0\n        q.append(root)\n        start, end, mxw = 0, 0, 0\n        mp[root] = 1\n        while q:\n            size = len(q)\n            for i in range(size):\n                node = q.pop(0)\n                if i == 0:\n                    start = mp[node]\n                if i == size-1:\n                    end = mp[node]\n                if node.left:\n                    q.append(node.left)\n                    mp[node.left] = 2*mp[node]\n                if node.right:\n                    q.append(node.right)\n                    mp[node.right] = 2*mp[node] + 1\n            mxw = max(mxw, end-start+1)\n        return mxw",
    "subPath": "",
    "fileName": "solution.py"
  }
}