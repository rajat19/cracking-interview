{
  "dsa": {
    "alien-dictionary": {
      "id": "alien-dictionary",
      "title": "Alien Dictionary",
      "difficulty": "hard",
      "companies": [
        "airbnb",
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "google",
        "microsoft",
        "oracle",
        "pinterest",
        "snapchat",
        "twitter",
        "uber",
        "vmware"
      ],
      "topics": [
        "string",
        "topological-sort",
        "graph"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "alien-dictionary",
      "gfg": "given-sorted-dictionary-find-precedence-characters",
      "leetid": 269,
      "content": "---\nlayout: post\ntitle: Alien Dictionary\ntopics: [string, topological-sort, graph]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(1)\nleetid: 269\ncompanies: [airbnb, amazon, apple, bloomberg, facebook, google, microsoft, oracle, pinterest, snapchat, twitter, uber, vmware]\ninterviewbit:\ndifficulty: hard\ngfg: given-sorted-dictionary-find-precedence-characters\nhackerrank: \nleetcode: alien-dictionary\n---\n\nThere is a new alien language which uses the latin alphabet. \nHowever, the order among letters are unknown to you. \nYou receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. \nDerive the order of letters in this language.\n\nNote:\n1. You may assume all letters are in lowercase.\n2. You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\n3. If the order is invalid, return an empty string.\n4. There may be multiple valid order of letters, return any one of them is fine.\n\n---\n## Test Cases\n**Examples 1:**\n```\nInput:\n[\n  \"wrt\",\n  \"wrf\",\n  \"er\",\n  \"ett\",\n  \"rftt\"\n]\n\nOutput: \"wertf\"\n```\n\n**Examples 2:**\n```\nInput:\n[\n  \"z\",\n  \"x\"\n]\nOutput: \"zx\"\n```\n\n**Examples 3:**\n```\nInput:\n[\n  \"z\",\n  \"x\",\n  \"z\"\n]\nOutput: \"\"\nExplanation: The order is invalid, so return \"\".\n```\n\n**Constraints:**\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 100`\n* `words[i] consists of only lowercase English letters.`",
      "body": "There is a new alien language which uses the latin alphabet. \nHowever, the order among letters are unknown to you. \nYou receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. \nDerive the order of letters in this language.\n\nNote:\n1. You may assume all letters are in lowercase.\n2. You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\n3. If the order is invalid, return an empty string.\n4. There may be multiple valid order of letters, return any one of them is fine.\n\n---\n## Test Cases\n**Examples 1:**\n```\nInput:\n[\n  \"wrt\",\n  \"wrf\",\n  \"er\",\n  \"ett\",\n  \"rftt\"\n]\n\nOutput: \"wertf\"\n```\n\n**Examples 2:**\n```\nInput:\n[\n  \"z\",\n  \"x\"\n]\nOutput: \"zx\"\n```\n\n**Examples 3:**\n```\nInput:\n[\n  \"z\",\n  \"x\",\n  \"z\"\n]\nOutput: \"\"\nExplanation: The order is invalid, so return \"\".\n```\n\n**Constraints:**\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 100`\n* `words[i] consists of only lowercase English letters.`",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    string alienOrder(vector<string>& A) {\n        unordered_map<int, unordered_set<int>> G;\n        int indegree[26] = {};\n        for (auto &s : A) {\n            for (char c : s) G[c - 'a'] = {};\n        }\n        for (int i = 1; i < A.size(); ++i) {\n            int j = 0;\n            for (; j < min(A[i - 1].size(), A[i].size()); ++j) {\n                if (A[i - 1][j] == A[i][j]) continue;\n                G[A[i - 1][j] - 'a'].insert(A[i][j] - 'a');\n                break;\n            }\n            if (j == A[i].size() && j < A[i - 1].size()) return \"\";\n        }\n        for (auto &[from, tos] : G) {\n            for (int to : tos) {\n                indegree[to]++;\n            }\n        }\n        queue<int> q;\n        for (int i = 0; i < 26; ++i) {\n            if (G.count(i) && indegree[i] == 0) q.push(i);\n        }\n        string ans;\n        while (q.size()) {\n            int u = q.front();\n            q.pop();\n            ans += u + 'a';\n            for (int v : G[u]) {\n                if (--indegree[v] == 0) q.push(v);\n            }\n        }\n        return ans.size() == G.size() ? ans : \"\";\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    // Returns the order of characters in the alien language, or \"\" if invalid\n    public String alienOrder(String[] words) {\n        // Adjacency matrix for graph representation\n        boolean[][] g = new boolean[26][26];\n        // Set of present characters\n        boolean[] s = new boolean[26];\n        int cnt = 0;\n        int n = words.length;\n        // Mark all unique characters and build graph edges\n        for (int i = 0; i < n - 1; ++i) {\n            for (char c : words[i].toCharArray()) {\n                if (cnt == 26) break;\n                c -= 'a';\n                if (!s[c]) {\n                    ++cnt;\n                    s[c] = true;\n                }\n            }\n            int m = words[i].length();\n            for (int j = 0; j < m; ++j) {\n                if (j >= words[i + 1].length()) return \"\"; // prefix case\n                char c1 = words[i].charAt(j), c2 = words[i + 1].charAt(j);\n                if (c1 == c2) continue;\n                if (g[c2 - 'a'][c1 - 'a']) return \"\"; // cycle check\n                g[c1 - 'a'][c2 - 'a'] = true;\n                break;\n            }\n        }\n        // Mark unique characters in the last word\n        for (char c : words[n - 1].toCharArray()) {\n            if (cnt == 26) break;\n            c -= 'a';\n            if (!s[c]) {\n                ++cnt;\n                s[c] = true;\n            }\n        }\n        // Calculate indegrees\n        int[] indegree = new int[26];\n        for (int i = 0; i < 26; ++i) {\n            for (int j = 0; j < 26; ++j) {\n                if (i != j && s[i] && s[j] && g[i][j]) {\n                    ++indegree[j];\n                }\n            }\n        }\n        // Topological sort using Kahn's algorithm\n        Deque<Integer> q = new LinkedList<>();\n        for (int i = 0; i < 26; ++i) {\n            if (s[i] && indegree[i] == 0) {\n                q.offerLast(i);\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        while (!q.isEmpty()) {\n            int t = q.pollFirst();\n            ans.append((char) (t + 'a'));\n            for (int i = 0; i < 26; ++i) {\n                if (i != t && s[i] && g[t][i]) {\n                    if (--indegree[i] == 0) {\n                        q.offerLast(i);\n                    }\n                }\n            }\n        }\n        // If not all characters are used, return \"\"\n        return ans.length() < cnt ? \"\" : ans.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "import collections\n\n\nclass Node(object):\n  def __init__(self, val):\n    self.val = val\n    self.neighbors = []\n\n  def connect(self, node):\n    self.neighbors.append(node)\n\n  def getNbrs(self):\n    return self.neighbors\n\n\nclass Solution(object):\n  def alienOrder(self, words):\n    \"\"\"\n    :type words: List[str]\n    :rtype: str\n    \"\"\"\n\n    def dfs(root, graph, visited):\n      visited[root] = 1\n      for nbr in graph[root].getNbrs():\n        if visited[nbr.val] == 0:\n          if not dfs(nbr.val, graph, visited):\n            return False\n        elif visited[nbr.val] == 1:\n          return False\n\n      visited[root] = 2\n      self.ans += root\n      return True\n\n    self.ans = \"\"\n    graph = {}\n    visited = collections.defaultdict(int)\n    self.topNum = 0\n    for i in range(0, len(words) - 1):\n      a = words[i]\n      b = words[i + 1]\n      i = 0\n      while i < len(a) and i < len(b):\n        if a[i] != b[i]:\n          nodeA = nodeB = None\n          if a[i] not in graph:\n            nodeA = Node(a[i])\n            graph[a[i]] = nodeA\n          else:\n            nodeA = graph[a[i]]\n          if b[i] not in graph:\n            nodeB = Node(b[i])\n            graph[b[i]] = nodeB\n          else:\n            nodeB = graph[b[i]]\n          nodeA.connect(nodeB)\n          break\n        i += 1\n      if i < len(a) and i >= len(b):\n        return \"\"\n\n    for c in graph:\n      if visited[c] == 0:\n        if not dfs(c, graph, visited):\n          return \"\"\n\n    unUsedSet = set()\n    for word in words:\n      for c in word:\n        unUsedSet.add(c)\n\n    for c in unUsedSet:\n      if c not in graph:\n        self.ans += c\n    return self.ans[::-1]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "basic-calculator-ii": {
      "id": "basic-calculator-ii",
      "title": "Basic Calculator II",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "math",
        "string",
        "stack"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "basic-calculator-ii",
      "gfg": null,
      "leetid": 227,
      "content": "---\nlayout: post\ntitle: Basic Calculator II\ntopics: [math, string, stack]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 227\ncompanies: [facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: basic-calculator-ii\n---\nGiven a string `s` which represents an expression, *evaluate this expression and return its value*. \nThe integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-2<sup>31</sup>, 2<sup>31</sup> - 1]`.\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"3+2*2\"\nOutput: 7\n```\n**Example 2:**\n```\nInput: s = \" 3/2 \"\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: s = \" 3+5 / 2 \"\nOutput: 5\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 3 * 10<sup>5</sup>`\n* `s` consists of integers and operators `('+', '-', '*', '/')` separated by some number of spaces.\n* `s` represents **a valid expression**.\n* All the integers in the expression are non-negative integers in the range `[0, 2<sup>31</sup> - 1]`.\n* The answer is **guaranteed** to fit in a **32-bit integer**.\n\n        ",
      "body": "Given a string `s` which represents an expression, *evaluate this expression and return its value*. \nThe integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-2<sup>31</sup>, 2<sup>31</sup> - 1]`.\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"3+2*2\"\nOutput: 7\n```\n**Example 2:**\n```\nInput: s = \" 3/2 \"\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: s = \" 3+5 / 2 \"\nOutput: 5\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 3 * 10<sup>5</sup>`\n* `s` consists of integers and operators `('+', '-', '*', '/')` separated by some number of spaces.\n* `s` represents **a valid expression**.\n* All the integers in the expression are non-negative integers in the range `[0, 2<sup>31</sup> - 1]`.\n* The answer is **guaranteed** to fit in a **32-bit integer**.\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int calculate(String s) {\n        Stack<Integer> st = new Stack<>();\n\n        int num = 0;\n        char operator = '+';\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (Character.isDigit(c)) {\n                num = num * 10 + (c - '0');\n            }\n\n            if (isOperator(c) || i == s.length() - 1) {\n                if (operator == '+') st.push(num);\n                else if (operator == '-') st.push(-num);\n                else if (operator == '*') st.push(st.pop() * num);\n                else if (operator == '/') st.push(st.pop() / num);\n\n                num = 0;\n                operator = c;\n            }\n        }\n\n        int ans = 0;\n\n        while (!st.isEmpty()) {\n            ans += st.pop();\n        }\n\n        return ans;\n    }\n\n    private boolean isOperator(char c) {\n        return c == '+' || c == '-' || c == '*' || c == '/';\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def calculate(self, s: str) -> int:\n        def update(op, v):\n            if op == \"+\": stack.append(v)\n            if op == \"-\": stack.append(-v)\n            if op == \"*\": stack.append(stack.pop() * v)           #for BC II and BC III\n            if op == \"/\": stack.append(int(stack.pop() / v))      #for BC II and BC III\n\n        it, num, stack, sign = 0, 0, [], \"+\"\n\n        while it < len(s):\n            if s[it].isdigit():\n                num = num * 10 + int(s[it])\n            elif s[it] in \"+-*/\":\n                update(sign, num)\n                num, sign = 0, s[it]\n            elif s[it] == \"(\":                                        # For BC I and BC III\n                num, j = self.calculate(s[it + 1:])\n                it = it + j\n            elif s[it] == \")\":                                        # For BC I and BC III\n                update(sign, num)\n                return sum(stack), it + 1\n            it += 1\n        update(sign, num)\n        return sum(stack)",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "basic-calculator": {
      "id": "basic-calculator",
      "title": "Basic Calculator",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "math",
        "string",
        "stack",
        "recursion"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "basic-calculator",
      "gfg": null,
      "leetid": 224,
      "content": "---\nlayout: post\ntitle: Basic Calculator\ntopics: [math, string, stack, recursion]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(n)\nleetid: 224\ncompanies: \ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: basic-calculator\n---\nGiven a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return *the result of the evaluation*.\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"1 + 1\"\nOutput: 2\n```\n**Example 2:**\n```\nInput: s = \" 2-1 + 2 \"\nOutput: 3\n```\n**Example 3:**\n```\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 3 * 10<sup>5</sup>`\n\t\n* `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.\n\t\n* `s` represents a valid expression.\n\t\n* `'+'` is **not** used as a unary operation (i.e., `\"+1\"` and `\"+(2 + 3)\"` is invalid).\n\t\n* `'-'` could be used as a unary operation (i.e., `\"-1\"` and `\"-(2 + 3)\"` is valid).\n\t\n* There will be no two consecutive operators in the input.\n\t\n* Every number and running calculation will fit in a signed 32-bit integer.\n\n        ",
      "body": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return *the result of the evaluation*.\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"1 + 1\"\nOutput: 2\n```\n**Example 2:**\n```\nInput: s = \" 2-1 + 2 \"\nOutput: 3\n```\n**Example 3:**\n```\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 3 * 10<sup>5</sup>`\n\t\n* `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.\n\t\n* `s` represents a valid expression.\n\t\n* `'+'` is **not** used as a unary operation (i.e., `\"+1\"` and `\"+(2 + 3)\"` is invalid).\n\t\n* `'-'` could be used as a unary operation (i.e., `\"-1\"` and `\"-(2 + 3)\"` is valid).\n\t\n* There will be no two consecutive operators in the input.\n\t\n* Every number and running calculation will fit in a signed 32-bit integer.\n\n        ",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int calculate(string s) {\n        stack<int> st;\n        int result = 0, num = 0, sign = 1;\n        st.push(sign);\n        for(int i=0; i<s.length(); i++) {\n            char c = s[i];\n            if (c >= '0' && c <= '9') {\n                num = num*10 - (int)'0' + (int) c;\n            } else if (c == '+' || c == '-') {\n                result += sign * num;\n                sign = st.top() * (c == '+' ? 1: -1);\n                num = 0;\n            } else if (c == '(') {\n                st.push(sign);\n            } else if (c == ')'){\n                st.pop();\n            }\n        }\n        result += sign * num;\n        return result;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int calculate(String s) {\n        int result = 0, sign = 1, num = 0;\n        Stack<Integer> stack = new Stack<Integer>();\n        stack.push(sign);\n        for(int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if(c >= '0' && c <= '9') {\n                num = num * 10 + (c - '0');\n            } else if(c == '+' || c == '-') {\n                result += sign * num;\n                sign = stack.peek() * (c == '+' ? 1: -1);\n                num = 0;\n            } else if(c == '(') {\n                stack.push(sign);\n            } else if(c == ')') {\n                stack.pop();\n            }\n        }\n        result += sign * num;\n        return result;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def calculate(self, s: str) -> int:\n        res, num, sign = 0, 0, 1\n        stack = [sign]\n        for c in s:\n            if '0' <= c <= '9':\n                num = num * 10 + (ord(c) - ord('0'))\n            elif c in ['+', '-']:\n                res += sign * num\n                sign = stack[-1] * (-1 if c == '-' else 1)\n                num = 0\n            elif c == '(':\n                stack.append(sign)\n            elif c == ')':\n                stack.pop()\n        res += sign * num\n        return res",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "best-time-to-buy-and-sell-stock-ii": {
      "id": "best-time-to-buy-and-sell-stock-ii",
      "title": "Best Time to Buy and Sell Stock II",
      "difficulty": "medium",
      "companies": [
        "facebook",
        "amazon"
      ],
      "topics": [
        "array",
        "dynamic-programming",
        "greedy"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "best-time-to-buy-and-sell-stock-ii",
      "gfg": null,
      "leetid": 122,
      "content": "---\nlayout: post\ntitle: Best Time to Buy and Sell Stock II\ntopics: [array, dynamic-programming, greedy]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\nleetid: 122\ncompanies: [facebook, amazon]\ninterviewbit: best-time-to-buy-and-sell-stocks-ii\ndifficulty: medium\ngfg: \nhackerrank: \nleetcode: best-time-to-buy-and-sell-stock-ii\n---\nYou are given an integer array `prices` where `prices[i]` is the price of a given stock on the `i<sup>th</sup>` day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\nFind and return *the **maximum** profit you can achieve*.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n```\n**Example 2:**\n```\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n```\n\n**Example 3:**\n\n```\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n```\n\n**Constraints:**\n\n* `1 <= prices.length <= 3 * 10<sup>4</sup>`\n\n* `0 <= prices[i] <= 10<sup>4</sup>`\n",
      "body": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `i<sup>th</sup>` day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\nFind and return *the **maximum** profit you can achieve*.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n```\n**Example 2:**\n```\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n```\n\n**Example 3:**\n\n```\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n```\n\n**Constraints:**\n\n* `1 <= prices.length <= 3 * 10<sup>4</sup>`\n\n* `0 <= prices[i] <= 10<sup>4</sup>`\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int profit = 0;\n        if (prices.length == 1) {\n            return 0;\n        }\n        for(int i=1; i<prices.length; i++) {\n            if (prices[i] > prices[i-1]) {\n                profit += prices[i] - prices[i-1];\n            }\n        }\n        return profit;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        i, l, buy, sell, profit = 0, len(prices) - 1, 0, 0, 0\n        while i < l:\n            while i < l and prices[i+1] <= prices[i]:\n                i+=1\n            buy = prices[i]\n            while i < l and prices[i+1] > prices[i]:\n                i+= 1\n            sell = prices[i]\n            profit += sell - buy\n        return profit",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "best-time-to-buy-and-sell-stock-iii": {
      "id": "best-time-to-buy-and-sell-stock-iii",
      "title": "Best Time to Buy and Sell Stock III",
      "difficulty": "hard",
      "companies": [
        "facebook",
        "amazon"
      ],
      "topics": [
        "array",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "cpp",
        "py",
        "c"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "best-time-to-buy-and-sell-stock-iii",
      "gfg": null,
      "leetid": 123,
      "content": "---\nlayout: post\ntitle: Best Time to Buy and Sell Stock III\ntopics: [array, dynamic-programming]\nlangs: [java, cpp, py, c]\ntc: O(n)\nsc: O(1)\nleetid: 123\ncompanies: [facebook, amazon]\ninterviewbit: best-time-to-buy-and-sell-stocks-iii\ndifficulty: hard\ngfg: \nhackerrank: \nleetcode: best-time-to-buy-and-sell-stock-iii\n---\n\nYou are given an array prices where `prices[i]` is the price of a given stock on the i<sup>th</sup> day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously \n(i.e., you must sell the stock before you buy again).\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) prices = [3,3,5,0,0,3,1,4]\n```\n\n**Output:**\n```\n(int) 6\n```\n\n**Explanation:**\n```\nBuy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n```\n\n---\n\n**Input:**\n```\n(int[]) prices = [1,2,3,4,5]\n```\n\n**Output:**\n```\n(int) 4\n```\n\n**Explanation:**\n```\nBuy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, \nas you are engaging multiple transactions at the same time. You must sell before buying again.\n```\n\n---\n\n**Input:**\n```\n(int[]) prices = [7,6,4,3,1]\n```\n\n**Output:**\n```\n(int) 0\n```\n\n**Explanation:**\n```\nIn this case, no transaction is done, i.e. max profit = 0.\n```",
      "body": "You are given an array prices where `prices[i]` is the price of a given stock on the i<sup>th</sup> day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously \n(i.e., you must sell the stock before you buy again).\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) prices = [3,3,5,0,0,3,1,4]\n```\n\n**Output:**\n```\n(int) 6\n```\n\n**Explanation:**\n```\nBuy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n```\n\n---\n\n**Input:**\n```\n(int[]) prices = [1,2,3,4,5]\n```\n\n**Output:**\n```\n(int) 4\n```\n\n**Explanation:**\n```\nBuy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, \nas you are engaging multiple transactions at the same time. You must sell before buying again.\n```\n\n---\n\n**Input:**\n```\n(int[]) prices = [7,6,4,3,1]\n```\n\n**Output:**\n```\n(int) 0\n```\n\n**Explanation:**\n```\nIn this case, no transaction is done, i.e. max profit = 0.\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "int max(int a, int b) {\n    return a > b ? a: b;\n}\n\nint maxProfit(int* prices, int pricesSize) {\n    int firstBuy = INT_MIN, firstSell = 0;\n    int secondBuy = INT_MIN, secondSell = 0;\n    for(int i = 0; i< pricesSize; i++) {\n        firstBuy = max(firstBuy, -prices[i]);\n        firstSell = max(firstSell, firstBuy + prices[i]);\n        secondBuy = max(secondBuy, firstSell - prices[i]);\n        secondSell = max(secondSell, secondBuy + prices[i]);\n    }\n    return max(firstSell, secondSell);\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int oneBuy = INT_MIN, oneBuyOneSell = 0;\n        int twoBuy = INT_MIN, twoBuyTwoSell = 0;\n        for(int i=0; i<prices.size(); i++) {\n            oneBuy = max(oneBuy, -prices[i]);\n            oneBuyOneSell = max(oneBuyOneSell, oneBuy + prices[i]);\n            twoBuy = max(twoBuy, oneBuyOneSell -prices[i]);\n            twoBuyTwoSell = max(twoBuyTwoSell, twoBuy + prices[i]);\n        }\n        return max(oneBuyOneSell, twoBuyTwoSell);\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "import java.util.*;\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int oneBuy = Integer.MIN_VALUE, oneBuyOneSell = 0;\n        int twoBuy = Integer.MIN_VALUE, twoBuyTwoSell = 0;\n        for(int i=0; i<prices.length; i++) {\n            oneBuy = Math.max(oneBuy, -prices[i]);\n            oneBuyOneSell = Math.max(oneBuyOneSell, oneBuy + prices[i]);\n            twoBuy = Math.max(twoBuy, oneBuyOneSell -prices[i]);\n            twoBuyTwoSell = Math.max(twoBuyTwoSell, twoBuy + prices[i]);\n        }\n        return Math.max(oneBuyOneSell, twoBuyTwoSell);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] prices = new int[]{3,3,5,0,0,3,1,4};\n        System.out.println(solution.maxProfit(prices));\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ob, tb = float('-inf'), float('-inf')\n        obos, tbts = 0, 0\n        for price in prices:\n            ob = max(ob, -price)\n            obos = max(obos, ob + price)\n            tb = max(tb, obos - price)\n            tbts = max(tbts, tb + price)\n        return max(obos, tbts)\n\n\nif __name__ == '__main__':\n    prices = [3, 3, 5, 0, 0, 3, 1, 4]\n    solution = Solution()\n    print(solution.maxProfit(prices))",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "binary-search-tree-iterator": {
      "id": "binary-search-tree-iterator",
      "title": "Binary Search Tree Iterator",
      "difficulty": "medium",
      "companies": [
        "facebook",
        "google",
        "linkedin",
        "apple",
        "amazon"
      ],
      "topics": [
        "stack",
        "tree",
        "design",
        "binary-search-tree",
        "binary-tree",
        "iterator"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "binary-search-tree-iterator",
      "gfg": null,
      "leetid": 173,
      "content": "---\nlayout: post\ntitle: Binary Search Tree Iterator\ndifficulty: medium\ntopics: [stack, tree, design, binary-search-tree, binary-tree, iterator]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(n)\ncompanies: [facebook, google, linkedin, apple, amazon]\nleetid: 173\nleetcode: binary-search-tree-iterator\ngfg: \ninterviewbit: bst-iterator\nhackerrank: \n---\nImplement the `BSTIterator` class that represents an iterator over the **<a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a>** of a binary search tree (BST):\n\t\n* `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n\t\n* `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.\n\t\n* `int next()` Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.\nYou may assume that `next()` calls will always be valid. That is, there will be at least a next number in the in-order traversal when `next()` is called.\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style={{width: '189px', height: '178px'}} />\n```\n**Input**\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n**Output**\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n**Explanation**\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[1, 10<sup>5</sup>]`.\n\t\n* `0 <= Node.val <= 10<sup>6</sup>`\n\t\n* At most `10<sup>5</sup>` calls will be made to `hasNext`, and `next`.\n \n**Follow up:**\n\t\n* Could you implement `next()` and `hasNext()` to run in average `O(1)` time and use `O(h)` memory, where `h` is the height of the tree?\n\n",
      "body": "Implement the `BSTIterator` class that represents an iterator over the **<a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a>** of a binary search tree (BST):\n\t\n* `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n\t\n* `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.\n\t\n* `int next()` Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.\nYou may assume that `next()` calls will always be valid. That is, there will be at least a next number in the in-order traversal when `next()` is called.\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style={{width: '189px', height: '178px'}} />\n```\n**Input**\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n**Output**\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n**Explanation**\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[1, 10<sup>5</sup>]`.\n\t\n* `0 <= Node.val <= 10<sup>6</sup>`\n\t\n* At most `10<sup>5</sup>` calls will be made to `hasNext`, and `next`.\n \n**Follow up:**\n\t\n* Could you implement `next()` and `hasNext()` to run in average `O(1)` time and use `O(h)` memory, where `h` is the height of the tree?\n\n",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass BSTIterator {\n    queue<int> q;\n    void inOrder(TreeNode* root, queue<int> &q) {\n        if(root == NULL){\n            return;\n        }\n        inOrder(root->left, q);\n        q.push(root->val);\n        inOrder(root->right, q);\n    }\npublic:\n    BSTIterator(TreeNode* root) {\n        inOrder(root, q);\n    }\n\n    int next() {\n        if(!q.empty()){\n            int frontNode = q.front();\n            q.pop();\n            return frontNode;\n        }\n        return 0;\n    }\n\n    bool hasNext() {\n        if(!q.empty()){\n            return true;\n        }\n        return false;\n    }\n};\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator* obj = new BSTIterator(root);\n * int param_1 = obj->next();\n * bool param_2 = obj->hasNext();\n */",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    private Deque<TreeNode> stack;\n    public BSTIterator(TreeNode root) {\n        stack = new ArrayDeque<>();\n        TreeNode next = root;\n        while(next != null) {\n            stack.offerLast(next);\n            next = next.left;\n        }\n    }\n\n    public int next() {\n        TreeNode removedNode = stack.pollLast();\n        TreeNode next = removedNode.right;\n        while(next != null) {\n            stack.offerLast(next);\n            next = next.left;\n        }\n        return removedNode.val;\n    }\n\n    public boolean hasNext() {\n        return !stack.isEmpty();\n\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self, root: TreeNode):\n        self.lst = []\n        self.index = 0\n        if root:\n            st = [root]\n            while len(st) > 0:\n                x = st.pop()\n                self.lst.append(x.val)\n                if x.left: st.append(x.left)\n                if x.right: st.append(x.right)\n            self.lst = sorted(self.lst)\n            print(self.lst)\n\n    def next(self) -> int:\n        \"\"\"\n        @return the next smallest number\n        \"\"\"\n        x = self.lst[self.index]\n        self.index += 1\n        return x\n\n    def hasNext(self) -> bool:\n        \"\"\"\n        @return whether we have a next smallest number\n        \"\"\"\n        if len(self.lst) == 0: return False\n        if self.index < len(self.lst):\n            return True\n        return False\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "binary-tree-maximum-path-sum": {
      "id": "binary-tree-maximum-path-sum",
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "binary-tree",
        "depth-first-search",
        "dynamic-programming",
        "tree"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "ts"
      ],
      "tc": "O(h)",
      "sc": "O(1)",
      "leetcode": "binary-tree-maximum-path-sum",
      "gfg": null,
      "leetid": 124,
      "content": "---\nlayout: post\ntitle: Binary Tree Maximum Path Sum\ntopics: [binary-tree, depth-first-search, dynamic-programming, tree]\nlangs: [java, py, cpp, ts]\ntc: O(h)\nsc: O(1)\nleetid: 124\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: binary-tree-maximum-path-sum\n---\n\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the root of a binary tree, return the maximum path sum of any **non-empty** path.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n  -10\n /   \\\n9     20\n     /  \\\n    15   7\n```\n\n**Example 2:** \n```\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n  1\n / \\ \n2   3\n```",
      "body": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the root of a binary tree, return the maximum path sum of any **non-empty** path.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n  -10\n /   \\\n9     20\n     /  \\\n    15   7\n```\n\n**Example 2:** \n```\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n  1\n / \\ \n2   3\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        int maxVal[1] = {INT_MIN};\n        maxPathDown(root, maxVal);\n        return maxVal[0];\n    }\n\n    int maxPathDown(TreeNode* root, int* maxVal) {\n        if (root == nullptr) return 0;\n        int left = max(0, maxPathDown(root->left, maxVal));\n        int right = max(0, maxPathDown(root->right, maxVal));\n        maxVal[0] = max(maxVal[0], left+right+root->val);\n        return max(left, right) + root->val;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxPathSum(TreeNode root) {\n        int[] maxVal = new int[]{Integer.MIN_VALUE};\n        maxPathDown(root, maxVal);\n        return maxVal[0];\n    }\n\n    private int maxPathDown(TreeNode root, int[] maxVal) {\n        if (root == null) return 0;\n        int left = Math.max(0, maxPathDown(root.left, maxVal));\n        int right = Math.max(0, maxPathDown(root.right, maxVal));\n        maxVal[0] = Math.max(maxVal[0], left+right+root.val);\n        return Math.max(left, right) + root.val;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import Optional, List\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        max_value = [float('-inf')]\n        self.maxPathDown(root, max_value)\n        return int(max_value[0])\n\n    def maxPathDown(self, node: Optional[TreeNode], max_value: List[float]):\n        if not node:\n            return 0\n        left = max(0, self.maxPathDown(node.left, max_value))\n        right = max(0, self.maxPathDown(node.right, max_value))\n        max_value[0] = max(max_value[0], left + right + node.val)\n        return max(left, right) + node.val",
          "subPath": "",
          "fileName": "solution.py"
        },
        "ts": {
          "language": "ts",
          "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction maxPathSum(root: TreeNode | null): number {\n    const maxVal = [Number.MIN_SAFE_INTEGER];\n    const ret = dfs(root, maxVal);\n    return maxVal[0];\n};\n\nfunction dfs(root: TreeNode | null, maxVal: number[]): number {\n    if (root == null) return 0;\n    const left = Math.max(0, dfs(root.left, maxVal));\n    const right = Math.max(0, dfs(root.right, maxVal));\n\n    maxVal[0] = Math.max(maxVal[0], left + right + root.val);\n    return Math.max(left, right) + root.val;\n}",
          "subPath": "",
          "fileName": "solution.ts"
        }
      }
    },
    "binary-tree-zigzag-level-order-traversal": {
      "id": "binary-tree-zigzag-level-order-traversal",
      "title": "Binary Tree Zigzag Level Order Traversal",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "binary-tree",
        "breadth-first-search",
        "tree"
      ],
      "langs": [
        "java",
        "js",
        "py",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "binary-tree-zigzag-level-order-traversal",
      "gfg": null,
      "leetid": 103,
      "content": "---\nlayout: post\ntitle: Binary Tree Zigzag Level Order Traversal\ntopics: [binary-tree, breadth-first-search, tree]\nlangs: [java, js, py, cpp]\ntc: O(n)\nsc: O(n)\nleetid: 103\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: binary-tree-zigzag-level-order-traversal\n---\n\nGiven the `root` of a binary tree, \nreturn the zigzag level order traversal of its nodes' values. \n(i.e., from left to right, then right to left for the next level and alternate between).\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(TreeNode) root = [3,9,20,null,null,15,7]\n```\n\n**Output:** \n```\n(int[]) [[3],[20,9],[15,7]]\n```\n\n**Explanation:**\n```\n    3\n   / \\\n  9   20\n     /  \\\n    15   7\n```",
      "body": "Given the `root` of a binary tree, \nreturn the zigzag level order traversal of its nodes' values. \n(i.e., from left to right, then right to left for the next level and alternate between).\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(TreeNode) root = [3,9,20,null,null,15,7]\n```\n\n**Output:** \n```\n(int[]) [[3],[20,9],[15,7]]\n```\n\n**Explanation:**\n```\n    3\n   / \\\n  9   20\n     /  \\\n    15   7\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if (root == nullptr) return {};\n        bool ltr = true;\n        queue<TreeNode*> q;\n        vector<vector<int>> result;\n        q.push(root);\n        while(!q.empty()) {\n            vector<int> row;\n            int qs = q.size();\n            while(qs > 0) {\n                TreeNode *node = q.front();\n                q.pop();\n                if (ltr) {\n                    row.push_back(node->val);\n                } else {\n                    row.insert(row.begin(), node->val);\n                }\n\n                if (node->left != nullptr) q.push(node->left);\n                if (node->right != nullptr) q.push(node->right);\n                qs--;\n            }\n            result.push_back(row);\n            ltr = !ltr;\n        }\n        return result;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if(root == null) return res;\n\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        boolean order = true;\n        int size = 1;\n\n        while(!q.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            for(int i = 0; i < size; ++i) {\n                TreeNode n = q.poll();\n                if(order) {\n                    tmp.add(n.val);\n                } else {\n                    tmp.add(0, n.val);\n                }\n                if(n.left != null) q.add(n.left);\n                if(n.right != null) q.add(n.right);\n            }\n            res.add(tmp);\n            size = q.size();\n            order = order ? false : true;\n        }\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "js": {
          "language": "js",
          "code": "/**\n * Definition for a binary tree node.\n */\nfunction TreeNode(val, left, right) {\n    this.val = (val===undefined ? 0 : val)\n    this.left = (left===undefined ? null : left)\n    this.right = (right===undefined ? null : right)\n}\n\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar zigzagLevelOrder = function(root) {\n    if (root === null) return [];\n    const queue = [root];\n    const res = [];\n    let order = true;\n    while (queue.length > 0) {\n        const list = [];\n        const size = queue.length;\n        for(let i=0; i<size; i++) {\n            const el = queue.shift();\n            if (order) list.push(el.val);\n            else list.unshift(el.val);\n            if (el.left !== null) queue.push(el.left);\n            if (el.right !== null) queue.push(el.right);\n        }\n        res.push(list);\n        order = !order;\n    }\n    return res;\n};",
          "subPath": "",
          "fileName": "solution.js"
        },
        "py": {
          "language": "py",
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        if root is None: return root\n        q = [(root, 0)]\n        mp = {}\n        while len(q) > 0:\n            x, h = q.pop(0)\n            if h in mp:\n                mp[h].append(x.val)\n            else:\n                mp[h] = [x.val]\n            if x.left is not None: q.append((x.left, h+1))\n            if x.right is not None: q.append((x.right, h+1))\n        for k,v in mp.items():\n            if k%2==1:\n                mp[k] = mp[k][::-1]\n        return mp.values()",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "burning-tree": {
      "id": "burning-tree",
      "title": "Burning Tree",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "binary-tree",
        "breadth-first-search",
        "queue",
        "tree"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(2<sup>h</sup>)",
      "leetcode": null,
      "gfg": null,
      "content": "---\nlayout: post\ntitle: Burning Tree\ntopics: [binary-tree, breadth-first-search, queue, tree]\nlangs: [java]\ntc: O(n)\nsc: O(2<sup>h</sup>)\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven a binary tree and target node. By giving the fire to the target node and fire starts to spread in a complete tree. \nThe task is to print the total time to burn every node of the binary tree\n\nRules for burning the nodes :\n1. Fire will spread constantly to the connected nodes only.\n2. Every node takes the same time to burn.\n3. A node burns only once.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/binarytree.jpeg\" />\n\n**Input:**\n\n```\n(TreeNode)  root = [5,3,6,2,4,null,null,1]\n(int)       target = 4\n```\n\n**Output:**\n```\n(int) 4\n```\n\n**Explanation**\n```\nStep 1: burn 4\nStep 2: burn 3\nStep 3: burn 2, 5\nStep 4: burn 1, 6\n```\n\n---\n\n**Input:**\n\n```\n(TreeNode)  root = [5,3,6,2,4,null,null,1]\n(int)       target = 3\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation**\n```\nStep 1: burn 3\nStep 2: burn 2,4,5\nStep 3: burn 1, 6\n```",
      "body": "Given a binary tree and target node. By giving the fire to the target node and fire starts to spread in a complete tree. \nThe task is to print the total time to burn every node of the binary tree\n\nRules for burning the nodes :\n1. Fire will spread constantly to the connected nodes only.\n2. Every node takes the same time to burn.\n3. A node burns only once.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/binarytree.jpeg\" />\n\n**Input:**\n\n```\n(TreeNode)  root = [5,3,6,2,4,null,null,1]\n(int)       target = 4\n```\n\n**Output:**\n```\n(int) 4\n```\n\n**Explanation**\n```\nStep 1: burn 4\nStep 2: burn 3\nStep 3: burn 2, 5\nStep 4: burn 1, 6\n```\n\n---\n\n**Input:**\n\n```\n(TreeNode)  root = [5,3,6,2,4,null,null,1]\n(int)       target = 3\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation**\n```\nStep 1: burn 3\nStep 2: burn 2,4,5\nStep 3: burn 1, 6\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class TreeNode{\n    int data;\n    TreeNode left;\n    TreeNode right;\n}\n\nclass BurningTree{\n    public int minTimeToBurnTree(TreeNode root,int target){\n        Map<TreeNode, TreeNode> parentMap=new HashMap<>();\n        Queue<TreeNode> queue=new LinkedList<>();\n        Set<TreeNode> visited=new HashSet<>();\n        queue.offer(root);\n        TreeNode targetNode=null;\n        int steps=0;\n        while(!queue.isEmpty()){\n            TreeNode node=queue.poll();\n            if (node.data==target){\n                targetNode=node;\n            }\n            if(node.left!=null){\n                queue.offer(node.left);\n                parentMap.put(node.left,node);\n            }\n            if(node.right!=null){\n                queue.offer(node.right);\n                parentMap.put(node.right,node);\n            }\n        }\n        if(targetNode==null){\n            return -1;\n        }\n        queue.clear();\n        queue.offer(targetNode);\n        visited.add(targetNode);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            for(int i=0; i<size; i++){\n                TreeNode node=queue.poll();\n                TreeNode parent=parentMap.get(node);\n                if(node.left!=null && !visited.contains(node.left)){\n                    queue.offer(node.left);\n                    visited.add(node.left);\n                }\n                if(node.right!=null && !visited.contains(node.right)){\n                    queue.offer(node.right);\n                    visited.add(node.right);\n                }\n                if(parent!=null && !visited.contains(parent)){\n                    queue.offer(parent);\n                    visited.add(parent);\n                }\n            }\n            if(!q.isEmpty()) steps++;\n        }\n        return steps;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "cheapest-flights-within-k-stops": {
      "id": "cheapest-flights-within-k-stops",
      "title": "Cheapest Flights Within K Stops",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "breadth-first-search",
        "depth-first-search",
        "dynamic-programming",
        "graph"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n<sup>k</sup>)",
      "sc": "O(n<sup>2</sup>k)",
      "leetcode": "cheapest-flights-within-k-stops",
      "gfg": null,
      "leetid": 787,
      "content": "---\nlayout: post\ntitle: Cheapest Flights Within K Stops\ntopics: [breadth-first-search, depth-first-search, dynamic-programming, graph]\nlangs: [java, cpp]\ntc: O(n<sup>k</sup>)\nsc: O(n<sup>2</sup>k)\nleetid: 787\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: cheapest-flights-within-k-stops\n---\n\nThere are `n` cities connected by some number of flights. \nYou are given an array flights where `flights[i] = [from, to, price]` \nindicates that there is a flight from city from<sub>i</sub> to city to<sub>i</sub> with cost price<sub>i</sub>.\n\nYou are also given three integers `src`, `dst`, and `k`, \nreturn the cheapest price from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<MdxImage src=\"code/995.png\" />\n```\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation: The graph is shown.\nThe cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.\n```\n\n**Example 2:**\n\n<MdxImage src=\"code/995.png\" />\n\n```\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation: The graph is shown.\nThe cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.\n```",
      "body": "There are `n` cities connected by some number of flights. \nYou are given an array flights where `flights[i] = [from, to, price]` \nindicates that there is a flight from city from<sub>i</sub> to city to<sub>i</sub> with cost price<sub>i</sub>.\n\nYou are also given three integers `src`, `dst`, and `k`, \nreturn the cheapest price from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<MdxImage src=\"code/995.png\" />\n```\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation: The graph is shown.\nThe cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.\n```\n\n**Example 2:**\n\n<MdxImage src=\"code/995.png\" />\n\n```\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation: The graph is shown.\nThe cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<pair<int,int>> adj[n];\n        for(auto it: flights)\n        {\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        queue<pair<int, pair<int,int>>> q;\n        //{stop,{src, cost}}\n        q.push({0, {src,0}});\n\n        vector<int> dist(n, 1e9);\n        dist[src]=0;\n\n        while(!q.empty())\n        {\n            auto it =  q.front();\n            q.pop();\n            int stops = it.first;\n            int node = it.second.first;\n            int cost = it.second.second;\n\n            if(stops>k) break;\n\n            for(auto it : adj[node])\n            {\n                int adjNode = it.first;\n                int edW = it.second;\n\n                if(cost + edW < dist[adjNode] && stops <= k)\n                {\n                    dist[adjNode] = cost + edW;\n                    q.push({stops+1 ,{adjNode, cost+edW}});\n                }\n            }\n\n        }\n\n        if(dist[dst]== 1e9) return -1;\n        return dist[dst];\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        int graph[][] = new int[n][n];\n        for (int i = 0; i < flights.length; i++) {\n            graph[flights[i][0]][flights[i][1]] = flights[i][2];\n        }\n        int ans = findCheapestPrice(src, dst, graph, k + 1, new int[n + 1][n + 1][k + 2]);\n        return ans >= 1000000 ? -1 : ans;\n    }\n\n    int findCheapestPrice(int src, int dst, int graph[][], int k, int dp[][][]) {\n        if (dst == src) {\n            return 0;\n        }\n        if (k == 0) {\n            return 1000000;\n        }\n        if (dp[src][dst][k] != 0) {\n            return dp[src][dst][k];\n        }\n        int min = 1000000;\n        for (int i = 0; i < graph[src].length; i++) {\n            if (graph[src][i] != 0) {\n                min = Math.min(min, graph[src][i] + findCheapestPrice(i, dst, graph, k - 1, dp));\n            }\n        }\n        return dp[src][dst][k] = min;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "cherry-pickup-ii": {
      "id": "cherry-pickup-ii",
      "title": "Cherry Pickup II",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming",
        "matrix"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(mn<sup>2</sup>)",
      "sc": "O(mn<sup>2</sup>)",
      "leetcode": "cherry-pickup-ii",
      "gfg": null,
      "leetid": 1559,
      "content": "---\nlayout: post\ntitle: Cherry Pickup II\ntopics: [array, dynamic-programming, matrix]\nlangs: [java]\ntc: O(mn<sup>2</sup>)\nsc: O(mn<sup>2</sup>)\nleetid: 1559\ncompanies: \ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: cherry-pickup-ii\n---\nYou are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.\nYou have two robots that can collect cherries for you:\n\t\n* **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n\t\n* **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\nReturn *the maximum number of cherries collection using both robots by following the rules below*:\n\t\n* From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.\n\t\n* When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n\t\n* When both robots stay in the same cell, only one takes the cherries.\n\t\n* Both robots cannot move outside of the grid at any moment.\n\t\n* Both robots should reach the bottom row in `grid`.\n \n---\n## Test Cases\n**Example 1:**\n\n<img src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png\" />\n\n```\nInput: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\nOutput: 24\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n```\n\n**Example 2:**\n\n<img src=\"https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png\" />\n\n```\nInput: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\nOutput: 28\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n```\n \n**Constraints:**\n\t\n* `rows == grid.length`\n\t\n* `cols == grid[i].length`\n\t\n* `2 <= rows, cols <= 70`\n\t\n* `0 <= grid[i][j] <= 100`\n\n        ",
      "body": "You are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.\nYou have two robots that can collect cherries for you:\n\t\n* **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n\t\n* **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\nReturn *the maximum number of cherries collection using both robots by following the rules below*:\n\t\n* From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.\n\t\n* When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n\t\n* When both robots stay in the same cell, only one takes the cherries.\n\t\n* Both robots cannot move outside of the grid at any moment.\n\t\n* Both robots should reach the bottom row in `grid`.\n \n---\n## Test Cases\n**Example 1:**\n\n<img src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png\" />\n\n```\nInput: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\nOutput: 24\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n```\n\n**Example 2:**\n\n<img src=\"https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png\" />\n\n```\nInput: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\nOutput: 28\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n```\n \n**Constraints:**\n\t\n* `rows == grid.length`\n\t\n* `cols == grid[i].length`\n\t\n* `2 <= rows, cols <= 70`\n\t\n* `0 <= grid[i][j] <= 100`\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int cherryPickup(int[][] grid) {\n        int dir[] = new int[]{-1, 0, 1};\n\n        int row = grid.length;\n        int col = grid[0].length;\n        int dp[][][] = new int[row][col][col];\n\n        for(int i = 0; i < row; i++){\n            for(int j = 0; j < col; j++){\n                for(int k = 0; k < col; k++){\n                    dp[i][j][k] = -1;\n                }\n            }\n        }\n        int col1 = 0;\n        int col2 = col - 1;\n\n        dp[0][col1][col2] = grid[0][col1] + grid[0][col2];\n        int max = dp[0][col1][col2];\n\n        for(int i = 1; i < row; i++){\n            for(int c1 = 0; c1 < col; c1++){\n                for(int c2 = 0; c2 < col; c2++){\n                    int prev = dp[i - 1][c1][c2];\n                    if(prev >= 0){\n                        for(int d1: dir){\n                            col1 = d1 + c1;\n                            for(int d2: dir){\n                                col2 = d2 + c2;\n                                if(inRange(col1, col) && inRange(col2, col)){\n                                    dp[i][col1][col2] = Math.max(dp[i][col1][col2], prev+(col1 == col2 ? grid[i][col1] : (grid[i][col1] + grid[i][col2])));\n                                    max = Math.max(max, dp[i][col1][col2]);\n                                }\n                            }\n                        }\n                    }\n\n                }\n            }\n        }\n        return max;\n    }\n\n    public boolean inRange(int val, int limit){\n        return 0 <= val && val < limit;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "clone-graph": {
      "id": "clone-graph",
      "title": "Clone Graph",
      "difficulty": "medium",
      "companies": [
        "google",
        "facebook",
        "amazon"
      ],
      "topics": [
        "depth-first-search",
        "graph",
        "hash-table"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "clone-graph",
      "gfg": null,
      "leetid": 133,
      "content": "---\nlayout: post\ntitle: Clone Graph\ntopics: [depth-first-search, graph, hash-table]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(n)\nleetid: 133\ndifficulty: medium\ncompanies: [google, facebook, amazon]\ngfg: \nhackerrank: \ninterviewbit: clone-graph\nleetcode: clone-graph\n---\n\nGiven a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (`List[Node]`) of its neighbors.\n```\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n```\n\nTest case format:\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). \nFor example, the first node with `val == 1`, the second node with `val == 2`, and so on. \nThe graph is represented in the test case using an adjacency list.\n\nAn adjacency list is a collection of unordered lists used to represent a finite graph. \nEach list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the copy of the given node as a reference to the cloned graph.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(Node) adjList = [[2,4],[1,3],[2,4],[1,3]]\n```\n\n**Output:**\n```\n(Node) [[2,4],[1,3],[2,4],[1,3]]\n```\n\n---\n\n**Input:**\n```\n(Node) adjList = [[]]\n```\n\n**Output:**\n```\n(Node) [[]]\n```\n\n---\n\n**Input:**\n```\n(Node) adjList = []\n```\n\n**Output:**\n```\n(Node) []\n```",
      "body": "Given a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (`List[Node]`) of its neighbors.\n```\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n```\n\nTest case format:\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). \nFor example, the first node with `val == 1`, the second node with `val == 2`, and so on. \nThe graph is represented in the test case using an adjacency list.\n\nAn adjacency list is a collection of unordered lists used to represent a finite graph. \nEach list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the copy of the given node as a reference to the cloned graph.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(Node) adjList = [[2,4],[1,3],[2,4],[1,3]]\n```\n\n**Output:**\n```\n(Node) [[2,4],[1,3],[2,4],[1,3]]\n```\n\n---\n\n**Input:**\n```\n(Node) adjList = [[]]\n```\n\n**Output:**\n```\n(Node) [[]]\n```\n\n---\n\n**Input:**\n```\n(Node) adjList = []\n```\n\n**Output:**\n```\n(Node) []\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* arr[101];\n    Node* cloneGraph(Node* node) {\n        if (node == nullptr) {\n            return nullptr;\n        }\n        if (arr[node->val] != 0) {\n            return arr[node->val];\n        }\n        arr[node->val] = new Node(node->val);\n        int ns = node->neighbors.size();\n        for(int i=0; i<ns; i++) {\n            Node* cloned = cloneGraph(node->neighbors[i]);\n            arr[node->val]->neighbors.push_back(cloned);\n        }\n        return arr[node->val];\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n\nclass Solution {\n    public HashMap<Integer, Node> map = new HashMap<>();\n\n    public Node cloneGraph(Node node) {\n        return clone(node);\n    }\n\n    public Node clone(Node node) {\n        if (node == null) return null;\n\n        if (map.containsKey(node.val))\n            return map.get(node.val);\n\n        Node newNode = new Node(node.val, new ArrayList<Node>());\n        map.put(newNode.val, newNode);\n        for (Node neighbor : node.neighbors)\n            newNode.neighbors.add(clone(neighbor));\n        return newNode;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nfrom typing import Optional\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        visited = dict()\n        if node is None:\n            return None\n        if len(node.neighbors) == 0:\n            return Node(node.val)\n        return self.traverse(node, visited)\n\n    def traverse(self, old: Optional['Node'], visited: dict) -> Optional['Node']:\n        if old is None:\n            return None\n        if old in visited:\n            return visited[old]\n        new = Node(old.val)\n        visited[old] = new\n        for neigh in old.neighbors:\n            newneigh = self.traverse(neigh, visited)\n            new.neighbors.append(newneigh)\n        return new",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "coin-change": {
      "id": "coin-change",
      "title": "Coin Change",
      "difficulty": "medium",
      "companies": [
        "amazon",
        "apple",
        "google",
        "microsoft",
        "adobe"
      ],
      "topics": [
        "array",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "c"
      ],
      "tc": "O(n*amount)",
      "sc": "O(amount)",
      "leetcode": "coin-change",
      "gfg": null,
      "leetid": 322,
      "content": "---\nlayout: post\ntitle: Coin Change\ntopics: [array, dynamic-programming]\nlangs: [java, py, cpp, c]\ntc: O(n*amount)\nsc: O(amount)\nleetid: 322\ncompanies: [amazon, apple, google, microsoft, adobe]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: coin-change\n---\n\nYou are given an integer array coins representing coins of different denominations and \nan integer `amount` representing a total amount of money.\n\nReturn the _fewest number of coins that you need to make up that amount_. \nIf that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) coins = [1,2,5]\n(int) amount = 11\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\n11 = 5 + 5 + 1\n```\n\n---\n\n**Input:**\n```\n(int[]) coins = [2]\n(int) amount = 3\n```\n\n**Output:**\n```\n(int) -1\n```\n\n---\n\n**Input:**\n```\n(int[]) coins = [1]\n(int) amount = 0\n```\n\n**Output:**\n```\n(int) 0\n```",
      "body": "You are given an integer array coins representing coins of different denominations and \nan integer `amount` representing a total amount of money.\n\nReturn the _fewest number of coins that you need to make up that amount_. \nIf that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) coins = [1,2,5]\n(int) amount = 11\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\n11 = 5 + 5 + 1\n```\n\n---\n\n**Input:**\n```\n(int[]) coins = [2]\n(int) amount = 3\n```\n\n**Output:**\n```\n(int) -1\n```\n\n---\n\n**Input:**\n```\n(int[]) coins = [1]\n(int) amount = 0\n```\n\n**Output:**\n```\n(int) 0\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "int min(int num1, int num2) {\n    return (num1 < num2 ) ? num1 : num2;\n}\n\nint coinChange(int* coins, int coinsSize, int amount){\n    int max = amount + 1;\n    int dp[amount+1];\n    dp[0] = 0;\n    for (int i = 1; i <= amount; i++) {\n        dp[i] = max;\n        for(int j=0; j<coinsSize; j++) {\n            int coin = coins[j];\n            if (coin <= i) {\n                dp[i] = min(dp[i], dp[i - coin] + 1);\n            }\n        }\n    }\n    return dp[amount] > amount ? -1 : dp[amount];\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int max = amount + 1;\n        vector<int> dp(amount+1, max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for(int j=0; j<coins.size(); j++) {\n                int coin = coins[j];\n                if (coin <= i) {\n                    dp[i] = min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        int max = amount + 1;\n        int[] dp = new int[amount+1];\n        Arrays.fill(dp, max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for(int coin: coins) {\n                if (coin <= i) {\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        mx = amount + 1\n        dp = [mx]*mx\n        dp[0] = 0\n        for i in range(1, amount+1):\n            for coin in coins:\n                if coin <= i:\n                    dp[i] = min(dp[i], 1 + dp[i - coin])\n        return -1 if dp[amount] > amount else dp[amount]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "combination-sum": {
      "id": "combination-sum",
      "title": "Combination Sum",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "airbnb",
        "amazon",
        "apple",
        "facebook",
        "goldman",
        "linkedin",
        "microsoft",
        "salesforce"
      ],
      "topics": [
        "array",
        "backtracking"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(2<sup>n</sup>)",
      "sc": "O(n)",
      "leetcode": "combination-sum",
      "gfg": null,
      "leetid": 32,
      "content": "---\nlayout: post\ntitle: Combination Sum\ntopics: [array, backtracking]\nlangs: [java, cpp, py]\ntc: O(2<sup>n</sup>)\nsc: O(n)\nleetid: 32\ncompanies: [adobe, airbnb, amazon, apple, facebook, goldman, linkedin, microsoft, salesforce]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: combination-sum\nleetcode: combination-sum\n---\n\nGiven an array of distinct integers `candidates` and a target integer `target`, \nreturn a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. \nYou may return the combinations in any order.\n\nThe same number may be chosen from `candidates` an unlimited number of times. \nTwo combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nIt is guaranteed that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n```\n\n**Example 2:** \n```\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n```",
      "body": "Given an array of distinct integers `candidates` and a target integer `target`, \nreturn a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. \nYou may return the combinations in any order.\n\nThe same number may be chosen from `candidates` an unlimited number of times. \nTwo combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nIt is guaranteed that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n```\n\n**Example 2:** \n```\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    vector<vector<int> > combinationSum(vector<int> &candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int> > res;\n        vector<int> combination;\n        combinationSum(candidates, target, res, combination, 0);\n        return res;\n    }\nprivate:\n    void combinationSum(vector<int> &candidates, int target, vector<vector<int> > &res, vector<int> &combination, int begin) {\n        if (!target) {\n            res.push_back(combination);\n            return;\n        }\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\n            combination.push_back(candidates[i]);\n            combinationSum(candidates, target - candidates[i], res, combination, i);\n            combination.pop_back();\n        }\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        backtrack(candidates, target, 0, new ArrayList<>(), res);\n        return res;\n    }\n\n    private void backtrack(int[] candidates, int target, int pos, List<Integer> combo, List<List<Integer>> res) {\n        if (pos == candidates.length || target < 0) return;\n        if (target == 0) {\n            res.add(new ArrayList<>(combo));\n            return;\n        }\n        backtrack(candidates, target, pos+1, combo, res);\n        combo.add(candidates[pos]);\n        backtrack(candidates, target - candidates[pos], pos, combo, res);\n        combo.remove(combo.size() - 1);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        def backtrack(sum: int, pos: int, arr: List[int]):\n            if sum <0 or pos >= len(candidates):\n                return\n            if sum == 0:\n                res.append(list(arr))\n                return\n            backtrack(sum, pos+1, arr)\n            arr.append(candidates[pos])\n            backtrack(sum-candidates[pos], pos, arr)\n            arr.pop()\n        backtrack(target, 0, [])\n        return res",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "construct-binary-tree-from-preorder-and-inorder-traversal": {
      "id": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "binary-tree",
        "divide-and-conquer",
        "tree"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(h)",
      "sc": "O(1)",
      "leetcode": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "gfg": null,
      "leetid": 105,
      "content": "---\nlayout: post\ntitle: Construct Binary Tree from Preorder and Inorder Traversal\ntopics: [array, binary-tree, divide-and-conquer, tree]\nlangs: [java, py, cpp]\ntc: O(h)\nsc: O(1)\nleetid: 105\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: construct-binary-tree-from-preorder-and-inorder-traversal\n---\n\nGiven two integer arrays `preorder` and `inorder` where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, \nconstruct and return the binary tree.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n```\n\n**Example 2:** \n```\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n```",
      "body": "Given two integer arrays `preorder` and `inorder` where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, \nconstruct and return the binary tree.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n```\n\n**Example 2:** \n```\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        return buildTree(preorder, inorder, 0, 0, inorder.size() - 1);\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder, int prestart, int instart, int inend) {\n        if (prestart > preorder.size() || instart > inend) {\n            return nullptr;\n        }\n        TreeNode* root = new TreeNode(preorder[prestart]);\n        int index = instart;\n        while(index <= inend) {\n            if (inorder[index] == preorder[prestart]) {\n                break;\n            }\n            index++;\n        }\n        root->left = buildTree(preorder, inorder, prestart+1, instart, index-1);\n        root->right = buildTree(preorder, inorder, prestart+index-instart+1, index+1, inend);\n        return root;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return buildTree(preorder, inorder, 0, 0, inorder.length-1);\n    }\n\n    private TreeNode buildTree(int[] preorder, int[] inorder, int prestart, int instart, int inend) {\n        if (prestart > preorder.length || instart > inend) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[prestart]);\n        int inroot = instart;\n        while(inroot <= inend) {\n            if (inorder[inroot] == preorder[prestart]) {\n                break;\n            }\n            inroot++;\n        }\n        int count = inroot - instart;\n        root.left = buildTree(preorder, inorder, prestart+1, instart, inroot-1);\n        root.right = buildTree(preorder, inorder, prestart+inroot-instart+1, inroot+1, inend);\n        return root;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List, Optional\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        return self.helper(preorder, inorder, 0, 0, len(inorder) - 1)\n\n    def helper(self, preorder, inorder, prestart, instart, inend):\n        if prestart > len(preorder) or instart > inend:\n            return None\n        root = TreeNode(preorder[prestart])\n        index = instart\n        while index <= inend:\n            if inorder[index] == preorder[prestart]:\n                break\n            index += 1\n        root.left = self.helper(preorder, inorder, prestart+1, instart, index-1);\n        root.right = self.helper(preorder, inorder, prestart+index-instart+1, index+1, inend);\n        return root",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "convert-binary-tree-to-dll": {
      "id": "convert-binary-tree-to-dll",
      "title": "Convert Binary Tree to DLL",
      "difficulty": "medium",
      "companies": [
        "amazon",
        "microsoft",
        "facebook",
        "salesforce"
      ],
      "topics": [
        "binary-tree",
        "linked-list",
        "tree"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(h)",
      "leetcode": "convert-binary-tree-to-dll",
      "gfg": "convert-binary-tree-to-doubly-linked-list-using-inorder-traversal",
      "leetid": null,
      "content": "---\nlayout: post\ntitle: Convert Binary Tree to DLL\ntopics: [binary-tree, linked-list, tree]\nlangs: [java]\ntc: O(n)\nsc: O(h)\nleetid: \ndifficulty: medium\ncompanies: [amazon, microsoft, facebook, salesforce]\ngfg: convert-binary-tree-to-doubly-linked-list-using-inorder-traversal\nhackerrank: \ninterviewbit: \nleetcode: convert-binary-tree-to-dll\n---\n\nGiven a Binary Tree (BT), the task is to convert it to a Doubly Linked List (DLL) in place. The left and right pointers in nodes will be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be the same as the order of the given Binary Tree. The first node of Inorder traversal (leftmost node in BT) must be the head node of the DLL.\n\n---\n## Test Cases\n**Example 1:**\n\n```\nInput:\n      1\n    /  \\\n   3    2\nOutput:\n3 1 2 \n2 1 3\n```\n\n**Example 2:**\n```\nInput:\n       10\n      /   \\\n     20   30\n   /   \\\n  40   60\nOutput:\n40 20 60 10 30 \n30 10 60 20 40\n```",
      "body": "Given a Binary Tree (BT), the task is to convert it to a Doubly Linked List (DLL) in place. The left and right pointers in nodes will be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be the same as the order of the given Binary Tree. The first node of Inorder traversal (leftmost node in BT) must be the head node of the DLL.\n\n---\n## Test Cases\n**Example 1:**\n\n```\nInput:\n      1\n    /  \\\n   3    2\nOutput:\n3 1 2 \n2 1 3\n```\n\n**Example 2:**\n```\nInput:\n       10\n      /   \\\n     20   30\n   /   \\\n  40   60\nOutput:\n40 20 60 10 30 \n30 10 60 20 40\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int val) { this.val = val; }\n}\n\nclass Solution {\n    TreeNode prev = null;\n    TreeNode head = null;\n\n    public TreeNode convertToDLL(TreeNode root) {\n        if (root == null) return null;\n        inOrder(root);\n        return head;\n    }\n\n    private void inOrder(TreeNode node) {\n        if (node == null) return;\n\n        inOrder(node.left);\n\n        if (prev == null) {\n            head = node;\n        } else {\n            prev.right = node;\n            node.left = prev;\n        }\n        prev = node;\n\n        inOrder(node.right);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "count-and-say": {
      "id": "count-and-say",
      "title": "Count and Say",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "count-and-say",
      "gfg": "look-and-say-sequence",
      "leetid": 38,
      "content": "---\nlayout: post\ntitle: Count and Say\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 38\ngfg: look-and-say-sequence\ncompanies: [facebook]\ndifficulty: medium\nhackerrank: \ninterviewbit: count-and-say\nleetcode: count-and-say\n---\n\nThe **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n- `countAndSay(1) = \"1\"`\n- `countAndSay(n)` is the way you would \"say\" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, \nsplit it into the minimal number of groups so that each group is a contiguous section of all the same character. \nThen for each group, say the number of characters, then say the character. \n\nTo convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n\nFor example, the saying and conversion for digit string \"3322251\":\n\n**\"<span style={{color:'red'}}>33</span><span style={{color:'blue'}}>222</span><span style={{color:'pink'}}>5</span><span style={{color:'green'}}>1</span>\"**\n\n**<span style={{color:'red'}}>two 3's, </span><span style={{color:'blue'}}>three 2's, </span><span style={{color:'pink'}}>one 5, </span><span style={{color:'green'}}>one 1</span>**\n\n**<span style={{color:'red'}}>2 3</span>+<span style={{color:'blue'}}>3 2</span>+<span style={{color:'pink'}}>1 5</span>+<span style={{color:'green'}}>1 1</span>**\n\n**\"<span style={{color:'red'}}>23</span><span style={{color:'blue'}}>32</span><span style={{color:'pink'}}>15</span><span style={{color:'green'}}>11</span>\"**\n\n\nGiven a positive integer `n`, return the nth term of the count-and-say sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n```\n\n**Example 2:** \n```\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n```",
      "body": "The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n- `countAndSay(1) = \"1\"`\n- `countAndSay(n)` is the way you would \"say\" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, \nsplit it into the minimal number of groups so that each group is a contiguous section of all the same character. \nThen for each group, say the number of characters, then say the character. \n\nTo convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n\nFor example, the saying and conversion for digit string \"3322251\":\n\n**\"<span style={{color:'red'}}>33</span><span style={{color:'blue'}}>222</span><span style={{color:'pink'}}>5</span><span style={{color:'green'}}>1</span>\"**\n\n**<span style={{color:'red'}}>two 3's, </span><span style={{color:'blue'}}>three 2's, </span><span style={{color:'pink'}}>one 5, </span><span style={{color:'green'}}>one 1</span>**\n\n**<span style={{color:'red'}}>2 3</span>+<span style={{color:'blue'}}>3 2</span>+<span style={{color:'pink'}}>1 5</span>+<span style={{color:'green'}}>1 1</span>**\n\n**\"<span style={{color:'red'}}>23</span><span style={{color:'blue'}}>32</span><span style={{color:'pink'}}>15</span><span style={{color:'green'}}>11</span>\"**\n\n\nGiven a positive integer `n`, return the nth term of the count-and-say sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n```\n\n**Example 2:** \n```\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String countAndSay(int n) {\n        String prev = \"1\";\n        if (n==1) return prev;\n        for(int k=2; k<=n; k++) {\n            StringBuilder sb = new StringBuilder();\n            int count = 1;\n            for(int i=1; i<prev.length(); i++) {\n                if (prev.charAt(i) == prev.charAt(i-1)) {\n                    count++;\n                } else {\n                    sb.append(count).append(prev.charAt(i-1));\n                    count = 1;\n                }\n            }\n            sb.append(count).append(prev.charAt(prev.length()-1));\n            prev = sb.toString();\n        }\n        return prev;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "count-of-smaller-numbers-after-self": {
      "id": "count-of-smaller-numbers-after-self",
      "title": "Count of Smaller Numbers After Self",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "divide-and-conquer",
        "sorting"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(nlogn)",
      "sc": "O(n)",
      "leetcode": "count-of-smaller-numbers-after-self",
      "gfg": "count-smaller-elements-on-right-side",
      "leetid": 315,
      "content": "---\nlayout: post\ntitle: Count of Smaller Numbers After Self\ntopics: [array, divide-and-conquer, sorting]\nlangs: [java, cpp]\ntc: O(nlogn)\nsc: O(n)\nleetid: 315\ngfg: count-smaller-elements-on-right-side\ncompanies: [facebook]\ndifficulty: hard\nhackerrank: \ninterviewbit: \nleetcode: count-of-smaller-numbers-after-self\n---\n\nYou are given an integer array `nums` and you have to return a new `counts` array. \nThe `counts` array has the property where `counts[i]` is the number of smaller elements to the right of `nums[i]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [5,2,6,1]\nOutput: [2,1,1,0]\nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\n```\n\n**Example 2:** \n```\nInput: nums = [-1,-1]\nOutput: [0,0]\n```",
      "body": "You are given an integer array `nums` and you have to return a new `counts` array. \nThe `counts` array has the property where `counts[i]` is the number of smaller elements to the right of `nums[i]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [5,2,6,1]\nOutput: [2,1,1,0]\nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\n```\n\n**Example 2:** \n```\nInput: nums = [-1,-1]\nOutput: [0,0]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void merge(vector<int> &count, vector<pair<int, int> > &v, int left, int mid, int right) {\n        vector<pair<int, int> > tmp(right-left+1);\n        int i = left;\n        int j = mid+1;\n        int k = 0;\n\n        while (i <= mid && j <= right) {\n            if (v[i].first <= v[j].first) {\n                tmp[k++] = v[j++];\n            }\n            else {\n                count[v[i].second] += right - j + 1;\n                tmp[k++] = v[i++];\n            }\n        }\n        while (i <= mid) {\n            tmp[k++] = v[i++];\n        }\n        while (j <= right) {\n            tmp[k++] = v[j++];\n        }\n        for (int i = left; i <= right; i++)\n            v[i] = tmp[i-left];\n    }\n\n    void mergeSort(vector<int> &count, vector<pair<int, int> > &v, int left, int right) {\n        if (left >= right)\n            return;\n\n        int mid = left + (right-left)/2;\n        mergeSort(count, v, left, mid);\n        mergeSort(count, v, mid+1, right);\n        merge(count, v, left, mid, right);\n    }\n\n    vector<int> countSmaller(vector<int>& nums) {\n        int N = nums.size();\n\n        vector<pair<int, int> > v(N);\n        for (int i = 0; i < N; i++)\n            v[i] = make_pair(nums[i], i);\n\n        vector<int> count(N, 0);\n        mergeSort(count, v, 0, N-1);\n\n        return count;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        int n = nums.length;\n        Pair[] pairs = new Pair[n];\n        for(int i=0; i<n; i++) {\n            pairs[i] = new Pair(nums[i], i);\n        }\n\n        int[] count = new int[n];\n        mergeSort(count, pairs, 0, n-1);\n        List<Integer> result = new ArrayList<>();\n        for(int c: count) result.add(c);\n        return result;\n    }\n\n    private void mergeSort(int[] count, Pair[] pairs, int left, int right) {\n        if (left >= right) return;\n        int mid = left + (right-left)/2;\n        mergeSort(count, pairs, left, mid);\n        mergeSort(count, pairs, mid+1, right);\n        merge(count, pairs, left, mid, right);\n    }\n\n    private void merge(int[] count, Pair[] pairs, int left, int mid, int right) {\n        Pair[] temp = new Pair[right-left+1];\n        int i=left, j=mid+1, k=0;\n        while(i <= mid && j<= right) {\n            if (pairs[i].val <= pairs[j].val) {\n                temp[k++] = pairs[j++];\n            } else {\n                count[pairs[i].pos] += right - j + 1;\n                temp[k++] = pairs[i++];\n            }\n        }\n        while(i <= mid) {\n            temp[k++] = pairs[i++];\n        }\n        while(j <= right) {\n            temp[k++] = pairs[j++];\n        }\n        for(i=left; i<= right; i++) {\n            pairs[i] = temp[i-left];\n        }\n    }\n}\n\nclass Pair {\n    int val;\n    int pos;\n\n    public Pair(int val, int pos) {\n        this.val = val;\n        this.pos = pos;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "course-schedule-ii": {
      "id": "course-schedule-ii",
      "title": "Course Schedule II",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "depth-first-search",
        "graph",
        "topological-sort"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(V+E)",
      "sc": "O(V+E)",
      "leetcode": "course-schedule-ii",
      "gfg": null,
      "leetid": 210,
      "content": "---\nlayout: post\ntitle: Course Schedule II\ntopics: [depth-first-search, graph, topological-sort]\nlangs: [java, py]\ntc: O(V+E)\nsc: O(V+E)\nleetid: 210\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: course-schedule-ii\n---\n\nThere are a total of numCourses courses you have to take, labeled from `0` to `numCourses - 1`. \nYou are given an array prerequisites where prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]\nindicates that you must take course b<sub>i</sub> first if you want to take course a<sub>i</sub>.\n\nFor example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\nReturn the ordering of courses you should take to finish all courses. \nIf there are many valid answers, return any of them. \nIf it is impossible to finish all courses, return an empty array.\n\n---\n## How to Solve\n\n*The first node in the topological ordering will be the node that doesn't have any incoming edges. \nEssentially, any node that has an in-degree of 0 can start the topologically sorted order. \nIf there are multiple such nodes, their relative order doesn't matter, and they can appear in any order.*\n\n1. Initialize a queue, Q to keep a track of all the nodes in the graph with 0 in-degree. \n2. Iterate over all the edges in the input and create an adjacency list and also a map of node v/s in-degree. \n3. Add all the nodes with 0 in-degree to Q. \n4. The following steps are to be done until the Q becomes empty. \n   1. Pop a node from the Q. Let's call this node, N. \n   2. For all the neighbors of this node, N, reduce their in-degree by 1. If any of the nodes' in-degree reaches 0, add it to the Q. \n   3. Add the node N to the list maintaining topologically sorted order. \n   4. Continue from step `4.1`.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int) numCourses = 2\n(int[]) prerequisites = [[1,0]]\n```\n\n**Output:** \n```\n(int[]) [0, 1]\n```\n\n**Explanation:**\n```\nThere are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So the correct course order is [0,1].\n```\n\n---\n\n**Input:** \n```\n(int) numCourses = 4\n(int[]) prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n```\n\n**Output:** \n```\n(int[]) [0,2,1,3]\n```\n\n**Explanation:**\n```\nThere are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n```",
      "body": "There are a total of numCourses courses you have to take, labeled from `0` to `numCourses - 1`. \nYou are given an array prerequisites where prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]\nindicates that you must take course b<sub>i</sub> first if you want to take course a<sub>i</sub>.\n\nFor example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\nReturn the ordering of courses you should take to finish all courses. \nIf there are many valid answers, return any of them. \nIf it is impossible to finish all courses, return an empty array.\n\n---\n## How to Solve\n\n*The first node in the topological ordering will be the node that doesn't have any incoming edges. \nEssentially, any node that has an in-degree of 0 can start the topologically sorted order. \nIf there are multiple such nodes, their relative order doesn't matter, and they can appear in any order.*\n\n1. Initialize a queue, Q to keep a track of all the nodes in the graph with 0 in-degree. \n2. Iterate over all the edges in the input and create an adjacency list and also a map of node v/s in-degree. \n3. Add all the nodes with 0 in-degree to Q. \n4. The following steps are to be done until the Q becomes empty. \n   1. Pop a node from the Q. Let's call this node, N. \n   2. For all the neighbors of this node, N, reduce their in-degree by 1. If any of the nodes' in-degree reaches 0, add it to the Q. \n   3. Add the node N to the list maintaining topologically sorted order. \n   4. Continue from step `4.1`.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int) numCourses = 2\n(int[]) prerequisites = [[1,0]]\n```\n\n**Output:** \n```\n(int[]) [0, 1]\n```\n\n**Explanation:**\n```\nThere are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So the correct course order is [0,1].\n```\n\n---\n\n**Input:** \n```\n(int) numCourses = 4\n(int[]) prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n```\n\n**Output:** \n```\n(int[]) [0,2,1,3]\n```\n\n**Explanation:**\n```\nThere are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n\n        boolean isPossible = true;\n        Map<Integer, List<Integer>> adjList = new HashMap<Integer, List<Integer>>();\n        int[] indegree = new int[numCourses];\n        int[] topologicalOrder = new int[numCourses];\n\n        for (int i = 0; i < prerequisites.length; i++) {\n            int dest = prerequisites[i][0];\n            int src = prerequisites[i][1];\n            List<Integer> lst = adjList.getOrDefault(src, new ArrayList<Integer>());\n            lst.add(dest);\n            adjList.put(src, lst);\n            indegree[dest] += 1;\n        }\n\n        Queue<Integer> q = new LinkedList<Integer>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n\n        int i = 0;\n        while (!q.isEmpty()) {\n            int node = q.remove();\n            topologicalOrder[i++] = node;\n            if (adjList.containsKey(node)) {\n                for (Integer neighbor : adjList.get(node)) {\n                    indegree[neighbor]--;\n                    if (indegree[neighbor] == 0) {\n                        q.add(neighbor);\n                    }\n                }\n            }\n        }\n        if (i == numCourses) {\n            return topologicalOrder;\n        }\n        return new int[0];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from collections import defaultdict, deque\n\n\nclass Solution:\n\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        adj_list = defaultdict(list)\n        indegree = {}\n        for dest, src in prerequisites:\n            adj_list[src].append(dest)\n            indegree[dest] = indegree.get(dest, 0) + 1\n        zero_indegree_queue = deque([k for k in range(numCourses) if k not in indegree])\n\n        topological_sorted_order = []\n        while zero_indegree_queue:\n            vertex = zero_indegree_queue.popleft()\n            topological_sorted_order.append(vertex)\n            if vertex in adj_list:\n                for neighbor in adj_list[vertex]:\n                    indegree[neighbor] -= 1\n                    if indegree[neighbor] == 0:\n                        zero_indegree_queue.append(neighbor)\n\n        return topological_sorted_order if len(topological_sorted_order) == numCourses else []",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "course-schedule-iii": {
      "id": "course-schedule-iii",
      "title": "Course Schedule III",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "greedy",
        "heap"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nlogn)",
      "sc": "O(n)",
      "leetcode": "course-schedule-iii",
      "gfg": null,
      "leetid": 630,
      "content": "---\nlayout: post\ntitle: Course Schedule III\ntopics: [array, greedy, heap]\nlangs: [java]\ntc: O(nlogn)\nsc: O(n)\nleetid: 630\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: course-schedule-iii\n---\n\nThere are `n` different online courses numbered from `1` to `n`. \nYou are given an array courses where `courses[i] = [duration, lastDay]` \nindicate that the ith course should be taken continuously for duration<sub>i</sub> days \nand must be finished before or on lastDay<sub>i</sub>.\n\nYou will start on the 1<sup>st</sup> day and you cannot take two or more courses simultaneously.\n\nReturn the maximum number of courses that you can take.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n```\n\n**Example 2:**\n```\nInput: courses = [[1,2]]\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: courses = [[3,2],[4,3]]\nOutput: 0\n```",
      "body": "There are `n` different online courses numbered from `1` to `n`. \nYou are given an array courses where `courses[i] = [duration, lastDay]` \nindicate that the ith course should be taken continuously for duration<sub>i</sub> days \nand must be finished before or on lastDay<sub>i</sub>.\n\nYou will start on the 1<sup>st</sup> day and you cannot take two or more courses simultaneously.\n\nReturn the maximum number of courses that you can take.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n```\n\n**Example 2:**\n```\nInput: courses = [[1,2]]\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: courses = [[3,2],[4,3]]\nOutput: 0\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int scheduleCourse(int[][] courses) {\n        Arrays.sort(courses, (a, b) -> a[1]-b[1]);\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) ->b-a);\n        int time = 0;\n        for(int[] c: courses) {\n            if (time + c[0] <= c[1]) {\n                time += c[0];\n                pq.offer(c[0]);\n            } else if (!pq.isEmpty() && pq.peek() > c[0]){\n                time += c[0] - pq.poll();\n                pq.offer(c[0]);\n            }\n        }\n        return pq.size();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "decode-string": {
      "id": "decode-string",
      "title": "Decode String",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "queue",
        "recursion",
        "stack",
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "decode-string",
      "gfg": null,
      "leetid": 394,
      "content": "---\nlayout: post\ntitle: Decode String\ntopics: [queue, recursion, stack, string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 394\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: decode-string\nhellointerview: code/stack/decode-string\n---\n\nGiven an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, \nwhere the encoded_string inside the square brackets is being repeated exactly k times. \nNote that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; \nthere are no extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. \nFor example, there will not be input like `3a` or `2[4]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"3[a]2[bc]\"\nOutput: \"aaabcbc\"\n```\n\n**Example 2:** \n```\nInput: s = \"3[a2[c]]\"\nOutput: \"accaccacc\"\n```\n\n**Example 3:**\n```\nInput: s = \"2[abc]3[cd]ef\"\nOutput: \"abcabccdcdcdef\"\n```",
      "body": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, \nwhere the encoded_string inside the square brackets is being repeated exactly k times. \nNote that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; \nthere are no extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. \nFor example, there will not be input like `3a` or `2[4]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"3[a]2[bc]\"\nOutput: \"aaabcbc\"\n```\n\n**Example 2:** \n```\nInput: s = \"3[a2[c]]\"\nOutput: \"accaccacc\"\n```\n\n**Example 3:**\n```\nInput: s = \"2[abc]3[cd]ef\"\nOutput: \"abcabccdcdcdef\"\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String decodeString(String s) {\n        Queue<Character> queue = new LinkedList<>();\n        for (char c : s.toCharArray()) queue.offer(c);\n        return helper(queue);\n    }\n\n    public String helper(Queue<Character> queue) {\n        StringBuilder sb = new StringBuilder();\n        int num = 0;\n        while (!queue.isEmpty()) {\n            char c= queue.poll();\n            if (Character.isDigit(c)) {\n                num = num * 10 + c - '0';\n            } else if (c == '[') {\n                String sub = helper(queue);\n                for (int i = 0; i < num; i++) sb.append(sub);\n                num = 0;\n            } else if (c == ']') {\n                break;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "decode-ways": {
      "id": "decode-ways",
      "title": "Decode Ways",
      "difficulty": "medium",
      "companies": [
        "facebook",
        "amazon",
        "uber"
      ],
      "topics": [
        "dynamic-programming",
        "string"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "decode-ways",
      "gfg": null,
      "leetid": 91,
      "content": "---\nlayout: post\ntitle: Decode Ways\ntopics: [dynamic-programming, string]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(n)\nleetid: 91\ninterviewbit: ways-to-decode\ndifficulty: medium\ncompanies: [facebook, amazon, uber]\ngfg: \nhackerrank: \nleetcode: decode-ways\n---\n\nA message containing letters from A-Z can be encoded into numbers using the following mapping:\n```\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nTo **decode** an encoded message, \nall the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). \nFor example, `\"11106\"` can be mapped into:\n- `\"AAJF\"` with the grouping `(1 1 10 6)`\n- `\"KJF\"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n\nGiven a string `s` containing only digits, return the number of ways to decode it.\n\n---\n\n## Test Cases\n\n#### Example 1\n```\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n```\n\n#### Example 2\n```\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n```",
      "body": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n```\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nTo **decode** an encoded message, \nall the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). \nFor example, `\"11106\"` can be mapped into:\n- `\"AAJF\"` with the grouping `(1 1 10 6)`\n- `\"KJF\"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n\nGiven a string `s` containing only digits, return the number of ways to decode it.\n\n---\n\n## Test Cases\n\n#### Example 1\n```\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n```\n\n#### Example 2\n```\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        vector<int> dp(s.length() + 1, 0);\n        dp[0] = 1;\n        dp[1] = s[0] == '0' ? 0 : 1;\n        for (int i = 2; i <= s.length(); ++i) {\n            int one = stoi(s.substr(i - 1, 1));\n            int two = stoi(s.substr(i - 2, 2));\n            if (one >= 1) {\n                dp[i] += dp[i - 1];\n            }\n            if (two >= 10 && two <= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        return dp[s.length()];\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "public class Solution {\n    public int numDecodings(String s) {\n        int n = s.length();\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) == '0' ? 0 : 1;\n        for(int i=2; i<=n; i++) {\n            int one = Integer.parseInt(s.substring(i-1, i));\n            int two = Integer.parseInt(s.substring(i-2, i));\n            if (one >= 1) {\n                dp[i] += dp[i-1];\n            }\n            if (two >= 10 && two <= 26) {\n                dp[i] += dp[i-2];\n            }\n        }\n        return dp[n];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0]*(n+1)\n        dp[0], dp[1] = 1, 1 if s[0] != '0' else 0\n        for i in range(2, n+1):\n            one = int(s[i-1: i])\n            two = int(s[i-2: i])\n            if one > 0:\n                dp[i] += dp[i-1]\n            if 10 <= two <= 26:\n                dp[i] += dp[i-2]\n        return dp[n]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "detect-cycle-directed-graph": {
      "id": "detect-cycle-directed-graph",
      "title": "Detect Cycle Directed Graph",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "graph"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(V+E)",
      "sc": "O(V)",
      "leetcode": null,
      "gfg": "detect-cycle-in-a-graph",
      "content": "---\nlayout: post\ntitle: Detect Cycle Directed Graph\ntopics: [graph]\nlangs: [java]\ntc: O(V+E)\nsc: O(V)\ngfg: detect-cycle-in-a-graph\ndifficulty: medium\ncompanies: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, check whether it contains any cycle or not.\n\n---\n\n## How to Solve\n\n1. Create the graph using the given number of edges and vertices. \n2. Create a recursive function that initializes the current index or vertex, visited, and recursion stack. \n3. Mark the current node as visited and also mark the index in recursion stack. \n4. Find all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true, return true. \n5. If the adjacent vertices are already marked in the recursion stack then return true. \n6. Create a wrapper class, that calls the recursive function for all the vertices and if any function returns true return true. Else if for all vertices the function returns false, return false.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: V=4 adj=[[1],[2],[3],[3]]\nOutput: true\nExplanation: 1->2->3->3 is cycle\n```\n\n**Example 2:** \n```\nInput: V=4 adj=[[1],[2],[]]\nOutput: false\n```",
      "body": "Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, check whether it contains any cycle or not.\n\n---\n\n## How to Solve\n\n1. Create the graph using the given number of edges and vertices. \n2. Create a recursive function that initializes the current index or vertex, visited, and recursion stack. \n3. Mark the current node as visited and also mark the index in recursion stack. \n4. Find all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true, return true. \n5. If the adjacent vertices are already marked in the recursion stack then return true. \n6. Create a wrapper class, that calls the recursive function for all the vertices and if any function returns true return true. Else if for all vertices the function returns false, return false.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: V=4 adj=[[1],[2],[3],[3]]\nOutput: true\nExplanation: 1->2->3->3 is cycle\n```\n\n**Example 2:** \n```\nInput: V=4 adj=[[1],[2],[]]\nOutput: false\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean isCyclic(int V, ArrayList<ArrayList<Integer>> adj) {\n        Set<Integer> visited = new HashSet<>();\n        Set<Integer> rec = new HashSet<>();\n        for(int i=0; i<V; i++) {\n            if (dfs(i, adj, visited, rec)) return true;\n        }\n        return false;\n    }\n\n    private boolean dfs(int v, ArrayList<ArrayList<Integer>> adj, Set<Integer> visited, Set<Integer> rec) {\n        if (rec.contains(v)) return true;\n        if (visited.contains(v)) return false;\n        visited.add(v);\n        rec.add(v);\n        for(Integer neigh: adj.get(v)) {\n            if (dfs(neigh, adj, visited, rec)) return true;\n        }\n        rec.remove(v);\n        return false;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "detect-cycle-undirected-graph": {
      "id": "detect-cycle-undirected-graph",
      "title": "Detect Cycle Undirected Graph",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "graph"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(V+E)",
      "sc": "O(V)",
      "leetcode": null,
      "gfg": null,
      "content": "---\nlayout: post\ntitle: Detect Cycle Undirected Graph\ntopics: [graph]\nlangs: [java]\ntc: O(V+E)\nsc: O(V)\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven an undirected graph with V vertices and E edges, check whether it contains any cycle or not.\n\n---\n\n## How to Solve\n\n1. Create the graph using the given number of edges and vertices.\n2. Create a recursive function that have current index or vertex, visited array and parent node. \n3. Mark the current node as visited . \n4. Find all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true return true.\n5. If the adjacent node is not parent and already visited then return true. \n6. Create a wrapper class, that calls the recursive function for all the vertices and if any function returns true, return `true`. \n7. Else if for all vertices the function returns false, return `false`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: V=5 adj=[[1],[2,4],[1,3],[2,4],[1,3]]\nOutput: true\nExplanation: 1->2->3->4->1 is cycle\n```\n\n**Example 2:** \n```\nInput: V=4 adj=[[],[2],[1,3],[2]]\nOutput: false\n```",
      "body": "Given an undirected graph with V vertices and E edges, check whether it contains any cycle or not.\n\n---\n\n## How to Solve\n\n1. Create the graph using the given number of edges and vertices.\n2. Create a recursive function that have current index or vertex, visited array and parent node. \n3. Mark the current node as visited . \n4. Find all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true return true.\n5. If the adjacent node is not parent and already visited then return true. \n6. Create a wrapper class, that calls the recursive function for all the vertices and if any function returns true, return `true`. \n7. Else if for all vertices the function returns false, return `false`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: V=5 adj=[[1],[2,4],[1,3],[2,4],[1,3]]\nOutput: true\nExplanation: 1->2->3->4->1 is cycle\n```\n\n**Example 2:** \n```\nInput: V=4 adj=[[],[2],[1,3],[2]]\nOutput: false\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean isCycle(int V, ArrayList<ArrayList<Integer>> adj) {\n        Set<Integer> visited = new HashSet<>();\n        for(int i=0; i<V; i++) {\n            if (!visited.contains(i)) {\n                if (dfs(i, adj, visited, -1)) return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(int v, ArrayList<ArrayList<Integer>> adj, Set<Integer> visited, int parent) {\n        visited.add(v);\n        for(Integer neigh: adj.get(v)) {\n            if (!visited.contains(neigh)) {\n                if (dfs(neigh, adj, visited, v)) return true;\n            } else if (neigh != parent) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "edit-distance": {
      "id": "edit-distance",
      "title": "Edit Distance",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "dynamic-programming",
        "string"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(nm)",
      "sc": "O(nm)",
      "leetcode": "edit-distance",
      "gfg": null,
      "leetid": 72,
      "content": "---\nlayout: post\ntitle: Edit Distance\ntopics: [dynamic-programming, string]\nlangs: [java, cpp, py]\ntc: O(nm)\nsc: O(nm)\nleetid: 72\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: edit-distance\n---\n\nGiven two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\n\n- Insert a character\n- Delete a character\n- Replace a character\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n```\n\n**Example 2:** \n```\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n```",
      "body": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\n\n- Insert a character\n- Delete a character\n- Replace a character\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n```\n\n**Example 2:** \n```\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int n1 = word1.length(), n2 = word2.length();\n        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));\n        for (int i = 1; i <= n1; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 1; j <= n2; j++) {\n            dp[0][j] = j;\n        }\n        for(int i=1; i<=n1; i++) {\n            for(int j=1; j<=n2; j++) {\n                if (word1[i-1] != word2[j-1]) {\n                    dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]));\n                } else {\n                    dp[i][j] = dp[i-1][j-1];\n                }\n            }\n        }\n        return dp[n1][n2];\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        int n1 = word1.length(), n2 = word2.length();\n        int[][] dp = new int[n1+1][n2+1];\n        for (int i = 1; i <= n1; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 1; j <= n2; j++) {\n            dp[0][j] = j;\n        }\n        for(int i=1; i<=n1; i++) {\n            for(int j=1; j<=n2; j++) {\n                if (word1.charAt(i-1) != word2.charAt(j-1)) {\n                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));\n                } else {\n                    dp[i][j] = dp[i-1][j-1];\n                }\n            }\n        }\n        return dp[n1][n2];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        l1, l2 = len(word1), len(word2)\n        dp = [[0 for _ in range(l2 + 1)] for _ in range(l1 + 1)]\n        for i in range(1, l1+1, 1):\n            dp[i][0] = i\n        for i in range(1, l2+1, 1):\n            dp[0][i] = i\n\n        for i in range(1, l1+1, 1):\n            for j in range(1, l2+1, 1):\n                if word1[i-1] != word2[j-1]:\n                    dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\n                else:\n                    dp[i][j] = dp[i-1][j-1]\n        return dp[l1][l2]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "find-k-closest-elements": {
      "id": "find-k-closest-elements",
      "title": "Find K Closest Elements",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "two-pointers",
        "binary-search",
        "sliding-window",
        "sorting",
        "heap-priority-queue"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "find-k-closest-elements",
      "gfg": null,
      "leetid": 658,
      "content": "---\nlayout: post\ntitle: Find K Closest Elements\ntopics: [array, two-pointers, binary-search, sliding-window, sorting, heap-priority-queue]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\nleetid: 658\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: find-k-closest-elements\nhellointerview: code/heap/find-k-closest-elements\n---\nGiven a **sorted** integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.\nAn integer `a` is closer to `x` than an integer `b` if:\n\t\n* `|a - x| < |b - x|`, or\n\t\n* `|a - x| == |b - x|` and `a < b`\n \n---\n## Test Cases\n\n**Example 1:**\n```\nInput: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]\n```\n\n**Example 2:**\n```\nInput: arr = [1,1,2,3,4,5], k = 4, x = -1\nOutput: [1,1,2,3]\n```\n \n**Constraints:**\n\t\n* `1 <= k <= arr.length`\n\t\n* `1 <= arr.length <= 10<sup>4</sup>`\n\t\n* `arr` is sorted in **ascending** order.\n\t\n* `-10<sup>4</sup> <= arr[i], x <= 10<sup>4</sup>`\n\n        ",
      "body": "Given a **sorted** integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.\nAn integer `a` is closer to `x` than an integer `b` if:\n\t\n* `|a - x| < |b - x|`, or\n\t\n* `|a - x| == |b - x|` and `a < b`\n \n---\n## Test Cases\n\n**Example 1:**\n```\nInput: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]\n```\n\n**Example 2:**\n```\nInput: arr = [1,1,2,3,4,5], k = 4, x = -1\nOutput: [1,1,2,3]\n```\n \n**Constraints:**\n\t\n* `1 <= k <= arr.length`\n\t\n* `1 <= arr.length <= 10<sup>4</sup>`\n\t\n* `arr` is sorted in **ascending** order.\n\t\n* `-10<sup>4</sup> <= arr[i], x <= 10<sup>4</sup>`\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        int l = 0, r = arr.length - 1;\n        while(r - l >= k) {\n            if (Math.abs(arr[l] - x) > Math.abs(arr[r] - x)) {\n                l++;\n            } else {\n                r--;\n            }\n        }\n        List<Integer> result = new ArrayList<>();\n        for(int i=l; i<=r; i++) {\n            result.add(arr[i]);\n        }\n        return result;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:\n        left, right = 0, len(arr)-1\n        while right - left  >= k:\n            if abs(x - arr[left]) > abs(arr[right] - x):\n                left += 1\n            else:\n                right -= 1\n        return arr[left: right+1]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "find-median-from-data-stream": {
      "id": "find-median-from-data-stream",
      "title": "Find Median from Data Stream",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "heap",
        "sorting",
        "two-pointers"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(1)",
      "sc": "O(1)",
      "leetcode": "find-median-from-data-stream",
      "gfg": null,
      "leetid": 295,
      "content": "---\nlayout: post\ntitle: Find Median from Data Stream\ntopics: [heap, sorting, two-pointers]\nlangs: [java]\ntc: O(1)\nsc: O(1)\nleetid: 295\ndifficulty: hard\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: find-median-from-data-stream\nmetacareers: 547645422524434\n---\n\nThe median is the middle value in an ordered integer list. \nIf the size of the list is even, there is no middle value and the median is the mean of the two middle values.\n\n- For example, for `arr = [2,3,4]`, the median is `3`.\n- For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.\n\nImplement the MedianFinder class:\n- `MedianFinder()` initializes the `MedianFinder` object.\n- `void addNum(int num)` adds the integer num from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far. Answers within 10<sup>-5</sup> of the actual answer will be accepted.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n```\n",
      "body": "The median is the middle value in an ordered integer list. \nIf the size of the list is even, there is no middle value and the median is the mean of the two middle values.\n\n- For example, for `arr = [2,3,4]`, the median is `3`.\n- For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.\n\nImplement the MedianFinder class:\n- `MedianFinder()` initializes the `MedianFinder` object.\n- `void addNum(int num)` adds the integer num from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far. Answers within 10<sup>-5</sup> of the actual answer will be accepted.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n```\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class MedianFinder {\n    PriorityQueue<Integer> first;\n    PriorityQueue<Integer> second;\n    public MedianFinder() {\n        first = new PriorityQueue<>((a,b) -> b-a);\n        second = new PriorityQueue<>();\n    }\n\n    public void addNum(int num) {\n        first.offer(num);\n        second.offer(first.poll());\n        if (second.size() > first.size()) first.offer(second.poll());\n    }\n\n    public double findMedian() {\n        if (first.size() > second.size()) return first.peek();\n        return (first.peek() + second.peek())/2.0;\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "find-minimum-in-rotated-sorted-array": {
      "id": "find-minimum-in-rotated-sorted-array",
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "binary-search"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(logn)",
      "sc": "O(1)",
      "leetcode": "find-minimum-in-rotated-sorted-array",
      "gfg": null,
      "leetid": 153,
      "content": "---\nlayout: post\ntitle: Find Minimum in Rotated Sorted Array\ntopics: [array, binary-search]\nlangs: [java]\ntc: O(logn)\nsc: O(1)\nleetid: 153\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: find-minimum-in-rotated-sorted-array\n---\nSuppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\t\n* `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n\t\n* `[0,1,2,4,5,6,7]` if it was rotated `7` times.\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\nGiven the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*.\nYou must write an algorithm that runs in `O(log n) time.`\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n```\n**Example 2:**\n```\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n```\n**Example 3:**\n```\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n```\n \n**Constraints:**\n\t\n* `n == nums.length`\n\t\n* `1 <= n <= 5000`\n\t\n* `-5000 <= nums[i] <= 5000`\n\t\n* All the integers of `nums` are **unique**.\n\t\n* `nums` is sorted and rotated between `1` and `n` times.\n\n        ",
      "body": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\t\n* `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n\t\n* `[0,1,2,4,5,6,7]` if it was rotated `7` times.\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\nGiven the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*.\nYou must write an algorithm that runs in `O(log n) time.`\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n```\n**Example 2:**\n```\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n```\n**Example 3:**\n```\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n```\n \n**Constraints:**\n\t\n* `n == nums.length`\n\t\n* `1 <= n <= 5000`\n\t\n* `-5000 <= nums[i] <= 5000`\n\t\n* All the integers of `nums` are **unique**.\n\t\n* `nums` is sorted and rotated between `1` and `n` times.\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int findMin(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while(l < r) {\n            int mid = l + (r-l)/2;\n            if (nums[r] < nums[mid]) {\n                l = mid+1;\n            } else {\n                r = mid;\n            }\n        }\n        return nums[l];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "find-peak-element": {
      "id": "find-peak-element",
      "title": "Find Peak Element",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "binary-search"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(log n)",
      "sc": "O(1)",
      "leetcode": "find-peak-element",
      "gfg": "find-a-peak-in-a-given-array",
      "leetid": 162,
      "content": "---\nlayout: post\ntitle: Find Peak Element\ndifficulty: medium\ntopics: [array, binary-search]\nlangs: [java, cpp, py]\ntc: O(log n)\nsc: O(1)\nleetid: 162\ngfg: find-a-peak-in-a-given-array\ninterviewbit: \nhackerrank: \ncompanies: [facebook]\nleetcode: find-peak-element\n---\nA peak element is an element that is strictly greater than its neighbors.\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\nYou may imagine that `nums[-1] = nums[n] = -`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in `O(log n)` time.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.```\n**Example 2:**\n```\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 1000`\n\t\n* `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`\n\t\n* `nums[i] != nums[i + 1]` for all valid `i`.\n\n",
      "body": "A peak element is an element that is strictly greater than its neighbors.\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\nYou may imagine that `nums[-1] = nums[n] = -`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in `O(log n)` time.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.```\n**Example 2:**\n```\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 1000`\n\t\n* `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`\n\t\n* `nums[i] != nums[i + 1]` for all valid `i`.\n\n",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1;\n        while(l < r) {\n            int mid = l + (r-l)/2;\n            if (nums[mid] > nums[mid+1]) {\n                r = mid;\n            } else {\n                l = mid+1;\n            }\n        }\n        return l;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "public class Solution {\n    public int findPeakElement(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] > nums[mid + 1])\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def findPeakElement(self, A: List[int]) -> int:\n        nums = A\n        l, r = 0, len(nums) - 1\n\n        while l < r:\n            mid = (l+r) // 2\n            if nums[mid] > nums[mid + 1]:\n                r = mid\n            else:\n                l = mid + 1\n\n        return l",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "find-the-celebrity": {
      "id": "find-the-celebrity",
      "title": "Find the Celebrity",
      "difficulty": "medium",
      "companies": [
        "facebook",
        "linkedin",
        "amazon",
        "apple",
        "google",
        "microsoft",
        "pinterest",
        "uber"
      ],
      "topics": [
        "two-pointers"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "go"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "find-the-celebrity",
      "gfg": "the-celebrity-problem",
      "leetid": 277,
      "content": "---\nlayout: post\ntitle: Find the Celebrity\ntopics: [two-pointers]\nlangs: [java, py, cpp, go]\ntc: O(n)\nsc: O(1)\nleetid: 277\ncompanies: [facebook, linkedin, amazon, apple, google, microsoft, pinterest, uber]\ndifficulty: medium\ngfg: the-celebrity-problem\nhackerrank: \ninterviewbit: \nleetcode: find-the-celebrity\n---\n\nSuppose you are at a party with `n` people (labeled from `0` to `n - 1`) and among them, there may exist one celebrity. \nThe definition of a celebrity is that all the other `n - 1` people know him/her but he/she does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. \nThe only thing you are allowed to do is to ask questions like: \n\"Hi, A. Do you know B?\" to get information of whether A knows B. \nYou need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function `bool knows(a, b)` which tells you whether `a` knows `b`. \nImplement a function `int findCelebrity(n)`. There will be exactly one celebrity if he/she is in the party. \n\nReturn the celebrity's label if there is a celebrity in the party. If there is no celebrity, return `-1`.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: graph = [[1,1,0],[0,1,0],[1,1,1]]\nOutput: 1\nExplanation: There are three persons labeled with 0, 1 and 2. \ngraph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. \nThe celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n```\n\n**Example 2:**\n```\nInput: graph = [[1,0,1],[1,1,0],[0,1,1]]\nOutput: -1\nExplanation: There is no celebrity.\n```",
      "body": "Suppose you are at a party with `n` people (labeled from `0` to `n - 1`) and among them, there may exist one celebrity. \nThe definition of a celebrity is that all the other `n - 1` people know him/her but he/she does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. \nThe only thing you are allowed to do is to ask questions like: \n\"Hi, A. Do you know B?\" to get information of whether A knows B. \nYou need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function `bool knows(a, b)` which tells you whether `a` knows `b`. \nImplement a function `int findCelebrity(n)`. There will be exactly one celebrity if he/she is in the party. \n\nReturn the celebrity's label if there is a celebrity in the party. If there is no celebrity, return `-1`.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: graph = [[1,1,0],[0,1,0],[1,1,1]]\nOutput: 1\nExplanation: There are three persons labeled with 0, 1 and 2. \ngraph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. \nThe celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n```\n\n**Example 2:**\n```\nInput: graph = [[1,0,1],[1,1,0],[0,1,1]]\nOutput: -1\nExplanation: There is no celebrity.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/* The knows API is defined for you.\n      bool knows(int a, int b); */\n\nclass Solution {\npublic:\n    int findCelebrity(int n) {\n        int ans = 0;\n        for (int i = 1; i < n; ++i) {\n            if (knows(ans, i)) {\n                ans = i;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (ans != i) {\n                if (knows(ans, i) || !knows(i, ans)) {\n                    return -1;\n                }\n            }\n        }\n        return ans;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "/**\n * The knows API is already defined for you.\n *     knows := func(a int, b int) bool\n */\nfunc solution(knows func(a int, b int) bool) func(n int) int {\n\treturn func(n int) int {\n\t\tans := 0\n\t\tfor i := 1; i < n; i++ {\n\t\t\tif knows(ans, i) {\n\t\t\t\tans = i\n\t\t\t}\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tif ans != i {\n\t\t\t\tif knows(ans, i) || !knows(i, ans) {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans\n\t}\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "/* The knows API is defined in the parent class Relation.\n      boolean knows(int a, int b); */\n\npublic class Solution extends Relation {\n    public int findCelebrity(int n) {\n        int ans = 0;\n        for (int i = 1; i < n; ++i) {\n            if (knows(ans, i)) {\n                ans = i;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (ans != i) {\n                if (knows(ans, i) || !knows(i, ans)) {\n                    return -1;\n                }\n            }\n        }\n        return ans;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "# The knows API is already defined for you.\n# return a bool, whether a knows b\n# def knows(a: int, b: int) -> bool:\n\n\nclass Solution:\n    def findCelebrity(self, n: int) -> int:\n        ans = 0\n        for i in range(1, n):\n            if knows(ans, i):\n                ans = i\n        for i in range(n):\n            if ans != i:\n                if knows(ans, i) or not knows(i, ans):\n                    return -1\n        return ans",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "find-the-duplicate-number": {
      "id": "find-the-duplicate-number",
      "title": "Find the Duplicate Number",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "google",
        "microsoft"
      ],
      "topics": [
        "array",
        "binary-search",
        "two-pointers"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "go",
        "kt"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "find-the-duplicate-number",
      "gfg": null,
      "leetid": 287,
      "content": "---\nlayout: post\ntitle: Find the Duplicate Number\ntopics: [array, binary-search, two-pointers]\nlangs: [java, py, cpp, go, kt]\ntc: O(n)\nsc: O(1)\nleetid: 287\ncompanies: [adobe, amazon, apple, bloomberg, facebook, google, microsoft]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: find-the-duplicate-number\n---\n\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only one repeated number in `nums`, return this repeated number.\n\nYou must solve the problem without modifying the array nums and uses only constant extra space.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [1,3,4,2,2]\n```\n\n**Output:** \n```\n(int) 2\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [3,1,3,4,2]\n```\n\n**Output:**\n```\n(int) 3\n```",
      "body": "Given an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only one repeated number in `nums`, return this repeated number.\n\nYou must solve the problem without modifying the array nums and uses only constant extra space.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [1,3,4,2,2]\n```\n\n**Output:** \n```\n(int) 2\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [3,1,3,4,2]\n```\n\n**Output:**\n```\n(int) 3\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int slow = nums[0], fast = nums[0];\n        while (true) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n            if (slow == fast) break;\n        }\n        slow = nums[0];\n        while(slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return fast;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "package find_the_duplicate_number\n\nfunc findDuplicate(nums []int) int {\n\tslow := nums[0]\n\tfast := nums[0]\n\tfor true {\n\t\tslow = nums[slow]\n\t\tfast = nums[nums[fast]]\n\t\tif slow == fast {\n\t\t\tbreak\n\t\t}\n\t}\n\tslow = nums[0]\n\tfor slow != fast {\n\t\tslow = nums[slow]\n\t\tfast = nums[fast]\n\t}\n\treturn fast\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = nums[0], fast = nums[0];\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while(slow != fast);\n        slow = nums[0];\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n        return fast;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "kt": {
          "language": "kt",
          "code": "class Solution {\n    fun findDuplicate(nums: IntArray): Int {\n        var slow = nums[0];\n        var fast = nums[0];\n        do {\n            slow = nums[slow]\n            fast = nums[nums[fast]];\n        } while(slow != fast);\n\n        slow = nums[0];\n        while(slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n\n        return fast;\n    }\n}",
          "subPath": "",
          "fileName": "solution.kt"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        slow, fast = nums[0], nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return fast",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "first-missing-positive": {
      "id": "first-missing-positive",
      "title": "First Missing Positive",
      "difficulty": "hard",
      "companies": [
        "adobe",
        "amazon",
        "apple",
        "facebook",
        "google",
        "microsoft"
      ],
      "topics": [
        "array",
        "hash-table"
      ],
      "langs": [
        "java",
        "py",
        "c",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "first-missing-positive",
      "gfg": null,
      "leetid": 41,
      "content": "---\nlayout: post\ntitle: First Missing Positive\ntopics: [array, hash-table]\nlangs: [java, py, c, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 41\ncompanies: [adobe, amazon, apple, facebook, google, microsoft]\ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: first-missing-positive\n---\n\nGiven an unsorted integer array `nums`, return the smallest missing positive integer.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums = [1,2,0]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: nums = [3,4,-1,1]\nOutput: 2\n```\n\n**Example 3:**\n```\nInput: nums = [7,8,9,11,12]\nOutput: 1\n```",
      "body": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums = [1,2,0]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: nums = [3,4,-1,1]\nOutput: 2\n```\n\n**Example 3:**\n```\nInput: nums = [7,8,9,11,12]\nOutput: 1\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "int firstMissingPositive(int* nums, int n){\n    for(int i=0; i<n; i++) {\n        while (nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i]) {\n            int temp = nums[nums[i]-1];\n            nums[nums[i]-1] = nums[i];\n            nums[i] = temp;\n        }\n    }\n    for(int i=0; i<n; i++) {\n        if (nums[i] != i+1) return i+1;\n    }\n    return n+1;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for(int i=0; i<n; i++) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i]-1] != nums[i]) {\n                int temp = nums[nums[i]-1];\n                nums[nums[i]-1] = nums[i];\n                nums[i] = temp;\n            }\n        }\n        for(int i=0; i<n; i++) {\n            if (nums[i] != i+1) return i+1;\n        }\n        return n+1;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            while (nums[i] > 0 && nums[i] <= nums.length && nums[nums[i]-1] != nums[i]) {\n                swap(nums, i, nums[i]-1);\n            }\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if (nums[i] != i+1)    return i+1;\n        }\n        return nums.length+1;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n):\n            while 0 < nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "flatten-binary-tree-to-linked-list": {
      "id": "flatten-binary-tree-to-linked-list",
      "title": "Flatten Binary Tree to Linked List",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "binary-tree",
        "depth-first-search",
        "linked-list",
        "tree"
      ],
      "langs": [
        "java",
        "cpp",
        "c",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "flatten-binary-tree-to-linked-list",
      "gfg": null,
      "leetid": 114,
      "content": "---\nlayout: post\ntitle: Flatten Binary Tree to Linked List\ntopics: [binary-tree, depth-first-search, linked-list, tree]\nlangs: [java, cpp, c, py]\ntc: O(n)\nsc: O(n)\nleetid: 114\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: flatten-binary-tree-to-linked-list\n---\n\nGiven the root of a binary tree, flatten the tree into a \"linked list\":\n- The \"linked list\" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always null.\n- The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n```\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\nExplanation:\n     1\n    / \\\n   2   5\n  / \\   \\\n 3   4   6\n\nchanges to\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n```\n\n**Example 2:** \n```\nInput: root = []\nOutput: []\n```",
      "body": "Given the root of a binary tree, flatten the tree into a \"linked list\":\n- The \"linked list\" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always null.\n- The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n```\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\nExplanation:\n     1\n    / \\\n   2   5\n  / \\   \\\n 3   4   6\n\nchanges to\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n```\n\n**Example 2:** \n```\nInput: root = []\nOutput: []\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nvoid flatten(struct TreeNode* root){\n    if (!root) return;\n    flatten(root->left);\n    flatten(root->right);\n    if (!root->left) return;\n    struct TreeNode* right = root->right;\n    struct TreeNode* left = root->left;\n    root->left = NULL;\n    root->right = left;\n    while(left->right != NULL) {\n        left = left->right;\n    }\n    left->right = right;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if (root == nullptr) return;\n        flatten(root->left);\n        flatten(root->right);\n        if (root->left == nullptr) return;\n        TreeNode* right = root->right;\n        TreeNode* left = root->left;\n        root->left = nullptr;\n        root->right = left;\n        while(left->right != nullptr) {\n            left = left->right;\n        }\n        left->right = right;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void flatten(TreeNode root) {\n        if (root == null) return;\n        flatten(root.left);\n        flatten(root.right);\n        if (root.left != null) {\n            TreeNode right = root.right;\n            TreeNode left = root.left;\n            root.left = null;\n            root.right = left;\n            while(left.right != null) {\n                left = left.right;\n            }\n            left.right = right;\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import Optional\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def flatten(self, root: Optional[TreeNode]) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        if root is None:\n            return\n        self.flatten(root.left)\n        self.flatten(root.right)\n        if root.left is None:\n            return\n        right = root.right\n        left = root.left\n        root.left = None\n        root.right = left\n        while left.right is not None:\n            left = left.right\n        left.right = right",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "gas-station": {
      "id": "gas-station",
      "title": "Gas Station",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "greedy"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "gas-station",
      "gfg": "find-a-tour-that-visits-all-stations",
      "leetid": 134,
      "content": "---\nlayout: post\ntitle: Gas Station\ntopics: [array, greedy]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(1)\nleetid: 134\ncompanies: [facebook]\ngfg: find-a-tour-that-visits-all-stations\ninterviewbit: gas-station\nhackerrank: truck-tour\ndifficulty: medium\nleetcode: gas-station\n---\nThere are `n` gas stations along a circular route, where the amount of gas at the `i<sup>th</sup>` station is `gas[i]`.\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `i<sup>th</sup>` station to its next `(i + 1)<sup>th</sup>` station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays `gas` and `cost`, return *the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return* `-1`. If there exists a solution, it is **guaranteed** to be **unique**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n```\n\n**Example 2:**\n```\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n```\n \n**Constraints:**\n\t\n* `n == gas.length == cost.length`\n* `1 <= n <= 10<sup>5</sup>`\n* `0 <= gas[i], cost[i] <= 10<sup>4</sup>`\n* The input is generated such that the answer is unique.",
      "body": "There are `n` gas stations along a circular route, where the amount of gas at the `i<sup>th</sup>` station is `gas[i]`.\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `i<sup>th</sup>` station to its next `(i + 1)<sup>th</sup>` station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays `gas` and `cost`, return *the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return* `-1`. If there exists a solution, it is **guaranteed** to be **unique**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n```\n\n**Example 2:**\n```\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n```\n \n**Constraints:**\n\t\n* `n == gas.length == cost.length`\n* `1 <= n <= 10<sup>5</sup>`\n* `0 <= gas[i], cost[i] <= 10<sup>4</sup>`\n* The input is generated such that the answer is unique.",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int size=gas.size();\n    int sum=0;\n    int res=0;\n    int total=0;\n    for(int i=0; i<size; ++i){\n        sum+=gas[i]-cost[i];\n        if(sum<0){\n            total+=sum;\n            sum=0;\n            res=i+1;\n        }\n    }\n    total+=sum;\n    return total<0?-1:res;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int total = 0, current = 0, start = 0;\n        for(int index = 0; index < gas.length; index++) {\n            total += gas[index] - cost[index];\n            current += gas[index] - cost[index];\n            if (current < 0) {\n                current = 0;\n                start = index+1;\n            }\n        }\n        if (total < 0) {\n            return -1;\n        }\n        return start;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        total, current, start = 0, 0, 0\n        for i in range(len(gas)):\n            total += gas[i] - cost[i]\n            current += gas[i] - cost[i]\n            if current < 0:\n                current, start = 0, i+1\n        return start if total >= 0 else -1",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "generate-parentheses": {
      "id": "generate-parentheses",
      "title": "Generate Parentheses",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "goldman",
        "google",
        "microsoft",
        "uber"
      ],
      "topics": [
        "backtracking",
        "dynamic-programming",
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(4<sup>n</sup>/n&#8730;n)",
      "sc": "O(4<sup>n</sup>/n&#8730;n)",
      "leetcode": "generate-parentheses",
      "gfg": "print-all-combinations-of-balanced-parentheses",
      "leetid": 22,
      "content": "---\nlayout: post\ntitle: Generate Parentheses\ntopics: [backtracking, dynamic-programming, string]\nlangs: [java]\ntc: O(4<sup>n</sup>/n&#8730;n)\nsc: O(4<sup>n</sup>/n&#8730;n)\nleetid: 22\ncompanies: [adobe, amazon, apple, bloomberg, facebook, goldman, google, microsoft, uber]\ngfg: print-all-combinations-of-balanced-parentheses\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: generate-parentheses\n---\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n---\n## How to Solve\n\n### Approach 1\nTo generate all sequences, we use a recursion. \nAll sequences of length n is just `(` plus all sequences of length n-1, and then `)` plus all sequences of length n-1.\n\nTo check whether a sequence is valid, we keep track of balance, \nthe net number of opening brackets minus closing brackets. \nIf it falls below zero at any time, or doesn't end in zero, the sequence is invalid - otherwise it is valid.\n\n### Approach 2\nInstead of adding '(' or ')' every time as in Approach 1, \nlet's only add them when we know it will remain a valid sequence.\nWe can do this by keeping track of the number of opening and closing brackets we have placed so far.\n\nWe can start an opening bracket if we still have one (of `n`) left to place. \nAnd we can start a closing bracket if it would not exceed the number of opening brackets.\n\n---\n## Test Cases\n\n**Input:**\n\n    (int) n = 3\n\n**Output:**\n\n    (String[]) [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] \n",
      "body": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n---\n## How to Solve\n\n### Approach 1\nTo generate all sequences, we use a recursion. \nAll sequences of length n is just `(` plus all sequences of length n-1, and then `)` plus all sequences of length n-1.\n\nTo check whether a sequence is valid, we keep track of balance, \nthe net number of opening brackets minus closing brackets. \nIf it falls below zero at any time, or doesn't end in zero, the sequence is invalid - otherwise it is valid.\n\n### Approach 2\nInstead of adding '(' or ')' every time as in Approach 1, \nlet's only add them when we know it will remain a valid sequence.\nWe can do this by keeping track of the number of opening and closing brackets we have placed so far.\n\nWe can start an opening bracket if we still have one (of `n`) left to place. \nAnd we can start a closing bracket if it would not exceed the number of opening brackets.\n\n---\n## Test Cases\n\n**Input:**\n\n    (int) n = 3\n\n**Output:**\n\n    (String[]) [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] \n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        backtrack(n, res, new StringBuilder(), 0, 0);\n        return res;\n    }\n\n    private void backtrack(int n, List<String> res, StringBuilder sb, int open, int close) {\n        if (sb.length() == n*2) {\n            res.add(sb.toString());\n            return;\n        }\n\n        if (open < n) {\n            sb.append('(');\n            backtrack(n, res, sb, open+1, close);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n\n        if (close < open) {\n            sb.append(')');\n            backtrack(n, res, sb, open, close+1);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "group-anagrams": {
      "id": "group-anagrams",
      "title": "Group Anagrams",
      "difficulty": "medium",
      "companies": [
        "facebook",
        "uber"
      ],
      "topics": [
        "array",
        "hash-table",
        "string",
        "sorting"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(nm)",
      "sc": "O(nm)",
      "leetcode": "group-anagrams",
      "gfg": "given-a-sequence-of-words-print-all-anagrams-together",
      "leetid": 49,
      "content": "---\nlayout: post\ntitle: Group Anagrams\ntopics: [array, hash-table, string, sorting]\nlangs: [java, py]\ntc: O(nm)\nsc: O(nm)\nleetid: 49\ncompanies: [facebook, uber]\ngfg: given-a-sequence-of-words-print-all-anagrams-together\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: group-anagrams\n---\nGiven an array of strings `strs`, group the `anagrams` together. You can return the answer in **any order**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExplanation:\n* There is no string in strs that can be rearranged to form `\"bat\"`.\n* The strings `\"nat\"` and `\"tan\"` are anagrams as they can be rearranged to form each other.\n* The strings `\"ate\"`, `\"eat\"`, and `\"tea\"` are anagrams as they can be rearranged to form each other.\n```\n\n**Example 2:**\n```\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n```\n\n**Example 3:**\n```\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n```\n \n**Constraints:**\n* `1 <= strs.length <= 10<sup>4</sup>`\n* `0 <= strs[i].length <= 100`\n* `strs[i]` consists of lowercase English letters.\n\n        ",
      "body": "Given an array of strings `strs`, group the `anagrams` together. You can return the answer in **any order**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExplanation:\n* There is no string in strs that can be rearranged to form `\"bat\"`.\n* The strings `\"nat\"` and `\"tan\"` are anagrams as they can be rearranged to form each other.\n* The strings `\"ate\"`, `\"eat\"`, and `\"tea\"` are anagrams as they can be rearranged to form each other.\n```\n\n**Example 2:**\n```\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n```\n\n**Example 3:**\n```\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n```\n \n**Constraints:**\n* `1 <= strs.length <= 10<sup>4</sup>`\n* `0 <= strs[i].length <= 100`\n* `strs[i]` consists of lowercase English letters.\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> result = new ArrayList<>();\n        if (strs == null || strs.length == 0) {\n            return result;\n        }\n        if (strs.length == 1) {\n            result.add(Arrays.asList(strs));\n            return result;\n        }\n\n        HashMap<String, List<String>> groups = new HashMap<>();\n        for (String s : strs) {\n            String signature = getSignature(s);\n            groups.putIfAbsent(signature, new ArrayList<>());\n            groups.get(signature).add(s);\n        }\n\n        return new ArrayList<>(groups.values());\n    }\n\n    private String getSignature(String s) {\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) {\n                sb.append((char) ('a' + i)).append(count[i]);\n            }\n        }\n        return sb.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        def signature(str):\n            count = [0]*26\n            for c in str:\n                count[ord(c) - ord('a')]+= 1\n            sign = []\n            for i in range(26):\n                c = (chr)(i + ord('a'))\n                if count[i] != 0:\n                    sign.append(f\"${c}${count[i]}\")\n            return ''.join(sign)\n\n        groups = dict()\n        for string in strs:\n            sign = signature(string)\n            if sign in groups:\n                groups[sign].append(string)\n            else:\n                groups[sign] = [string]\n        print(groups)\n        res = []\n        for value in groups.values():\n            res.append(value)\n        return res",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "group-shifted-strings": {
      "id": "group-shifted-strings",
      "title": "Group Shifted Strings",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "strings",
        "hash-table"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "go"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "group-shifted-strings",
      "gfg": null,
      "leetid": 249,
      "content": "---\nlayout: post\ntitle: Group Shifted Strings\ntopics: [strings, hash-table]\nlangs: [java, py, cpp, go]\ntc: O(n)\nsc: O(n)\nleetid: 249\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: group-shifted-strings\n---\n\nWe can shift a string by shifting each of its letters to its successive letter.\n* For example, `\"abc\"` can be shifted to be `\"bcd\"`.\n\nWe can keep shifting the string to form a sequence.\n* For example, we can keep shifting `\"abc\"` to form the sequence: `\"abc\" -> \"bcd\" -> ... -> \"xyz\"`.\n\n* Given an array of strings `strings`, group all `strings[i]` that belong to the same shifting sequence. \n* You may return the answer in **any order**.\n\n---\n## How to Solve\n\nThe relative distance between each letter of the string and the first character is equal.\n\nFor example, `abc` and `efg` are mutually offset. \nFor abc, the distance between b and a is 1, and the distance between c and a is 2. \nFor efg, the distance between f and e is 1, and the distance between g and e is 2.\n\nLets look at another example. \nThe distance between az and yx, z and a is 25, and the distance between x and y is also 25 (direct subtraction is -1, \nwhich is the reason for adding 26 and taking the remainder).\n\nThen, in this case, all strings that are offset from each other have a unique distance difference. \nAccording to this, the mapping can be well grouped.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: strings = [\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\nOutput: [[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\n```\n\n**Example 2:**\n```\nInput: strings = [\"a\"]\nOutput: [[\"a\"]]\n```\n\n**Constraints**\n* `1 <= strings.length <= 200`\n* `1 <= strings[i].length <= 50`\n* `strings[i] consists of lowercase English letters.`",
      "body": "We can shift a string by shifting each of its letters to its successive letter.\n* For example, `\"abc\"` can be shifted to be `\"bcd\"`.\n\nWe can keep shifting the string to form a sequence.\n* For example, we can keep shifting `\"abc\"` to form the sequence: `\"abc\" -> \"bcd\" -> ... -> \"xyz\"`.\n\n* Given an array of strings `strings`, group all `strings[i]` that belong to the same shifting sequence. \n* You may return the answer in **any order**.\n\n---\n## How to Solve\n\nThe relative distance between each letter of the string and the first character is equal.\n\nFor example, `abc` and `efg` are mutually offset. \nFor abc, the distance between b and a is 1, and the distance between c and a is 2. \nFor efg, the distance between f and e is 1, and the distance between g and e is 2.\n\nLets look at another example. \nThe distance between az and yx, z and a is 25, and the distance between x and y is also 25 (direct subtraction is -1, \nwhich is the reason for adding 26 and taking the remainder).\n\nThen, in this case, all strings that are offset from each other have a unique distance difference. \nAccording to this, the mapping can be well grouped.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: strings = [\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\nOutput: [[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\n```\n\n**Example 2:**\n```\nInput: strings = [\"a\"]\nOutput: [[\"a\"]]\n```\n\n**Constraints**\n* `1 <= strings.length <= 200`\n* `1 <= strings[i].length <= 50`\n* `strings[i] consists of lowercase English letters.`",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    vector<vector<string>> groupStrings(vector<string>& strings) {\n        unordered_map<string, vector<string>> mp;\n        for (auto& s : strings) {\n            int diff = s[0] - 'a';\n            string t = s;\n            for (int i = 0; i < t.size(); ++i) {\n                char d = t[i] - diff;\n                if (d < 'a') d += 26;\n                t[i] = d;\n            }\n            cout << t << endl;\n            mp[t].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for (auto& e : mp)\n            ans.push_back(e.second);\n        return ans;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "func groupStrings(strings []string) [][]string {\n\tmp := make(map[string][]string)\n\tfor _, s := range strings {\n\t\tk := \"\"\n\t\tfor i := range s {\n\t\t\tk += string((s[i]-s[0]+26)%26 + 'a')\n\t\t}\n\t\tmp[k] = append(mp[k], s)\n\t}\n\tvar ans [][]string\n\tfor _, v := range mp {\n\t\tans = append(ans, v)\n\t}\n\treturn ans\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<List<String>> groupStrings(String[] strings) {\n        Map<String, List<String>> mp = new HashMap<>();\n        for (String s : strings) {\n            int diff = s.charAt(0) - 'a';\n            char[] t = s.toCharArray();\n            for (int i = 0; i < t.length; ++i) {\n                char d = (char) (t[i] - diff);\n                if (d < 'a') {\n                    d += 26;\n                }\n                t[i] = d;\n            }\n            String key = new String(t);\n            mp.computeIfAbsent(key, k -> new ArrayList<>()).add(s);\n        }\n        return new ArrayList<>(mp.values());\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from collections import defaultdict\n\nclass Solution:\n    def groupStrings(self, strings: List[str]) -> List[List[str]]:\n        mp = defaultdict(list)\n        for s in strings:\n            t = []\n            diff = ord(s[0]) - ord('a')\n            for c in s:\n                d = ord(c) - diff\n                if d < ord('a'):\n                    d += 26\n                t.append(chr(d))\n            k = ''.join(t)\n            mp[k].append(s)\n        return list(mp.values())",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "house-robber-ii": {
      "id": "house-robber-ii",
      "title": "House Robber II",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "house-robber-ii",
      "gfg": null,
      "leetid": 213,
      "content": "---\nlayout: post\ntitle: House Robber II\ntopics: [array, dynamic-programming]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 213\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: house-robber-ii\n---\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.\nGiven an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n```\n**Example 2:**\n```\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n```\n**Example 3:**\n```\nInput: nums = [1,2,3]\nOutput: 3\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 100`\n\t\n* `0 <= nums[i] <= 1000`\n\n        ",
      "body": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.\nGiven an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n```\n**Example 2:**\n```\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n```\n**Example 3:**\n```\nInput: nums = [1,2,3]\nOutput: 3\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 100`\n\t\n* `0 <= nums[i] <= 1000`\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int rob(int[] nums) {\n        if (nums.length == 1) return nums[0];\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\n        return Math.max(rob(nums, 0, nums.length-2), rob(nums, 1, nums.length-1));\n    }\n\n    private int rob(int[] nums, int start, int end) {\n        int first = 0, second = 0;\n        for(int i=start; i<=end; i++) {\n            int temp = Math.max(first + nums[i], second);\n            first = second;\n            second = temp;\n        }\n        return second;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "house-robber-iii": {
      "id": "house-robber-iii",
      "title": "House Robber III",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "binary-tree",
        "depth-first-search",
        "dynamic-programming",
        "tree"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "house-robber-iii",
      "gfg": null,
      "leetid": 337,
      "content": "---\nlayout: post\ntitle: House Robber III\ntopics: [binary-tree, depth-first-search, dynamic-programming, tree]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 337\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: house-robber-iii\n---\n\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. \nAfter a tour, the smart thief realized that all houses in this place form a binary tree. \nIt will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(TreeNode) root = [3,2,3,null,3,null,1]\n```\n\n**Output:** \n```\n(int) 7\n```\n\n**Explanation:**\n```\n    3\n   / \\\n  2   3\n   \\   \\\n    3   1\n\nMaximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n```",
      "body": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. \nAfter a tour, the smart thief realized that all houses in this place form a binary tree. \nIt will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(TreeNode) root = [3,2,3,null,3,null,1]\n```\n\n**Output:** \n```\n(int) 7\n```\n\n**Explanation:**\n```\n    3\n   / \\\n  2   3\n   \\   \\\n    3   1\n\nMaximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        vector<int> res = robSub(root);\n        return max(res[0], res[1]);\n    }\n\n    vector<int> robSub(TreeNode* root) {\n        vector<int> res(2, 0);\n        if (root == nullptr) {\n            return res;\n        }\n        vector<int> left = robSub(root->left);\n        vector<int> right = robSub(root->right);\n\n        res[0] = max(left[0], left[1]) + max(right[0], right[1]);\n        res[1] = root->val + left[0] + right[0];\n        return res;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int rob(TreeNode root) {\n        int[] res = robSub(root);\n        return Math.max(res[0], res[1]);\n    }\n\n    private int[] robSub(TreeNode root) {\n        if (root == null) return new int[2];\n\n        int[] left = robSub(root.left);\n        int[] right = robSub(root.right);\n        int[] res = new int[2];\n\n        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n        res[1] = root.val + left[0] + right[0];\n\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import Optional\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        res = self.robsub(root)\n        return max(res[0], res[1])\n\n    def robsub(self, root):\n        if not root:\n            return [0, 0]\n        left = self.robsub(root.left)\n        right = self.robsub(root.right)\n        res = [0, 0]\n        res[0] = max(left[0], left[1]) + max(right[0], right[1])\n        res[1] = root.val + left[0] + right[0]\n        return res",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "insert-delete-getrandom-o1": {
      "id": "insert-delete-getrandom-o1",
      "title": "Insert Delete GetRandom O1",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "hash-table"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(1)",
      "sc": "O(n)",
      "leetcode": "insert-delete-getrandom-o1",
      "gfg": null,
      "leetid": 380,
      "content": "---\nlayout: post\ntitle: Insert Delete GetRandom O1\ntopics: [array, hash-table]\nlangs: [java]\ntc: O(1)\nsc: O(n)\nleetid: 380\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: insert-delete-getrandom-o1\n---\n\nImplement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\n- `bool insert(int val)` Inserts an item val into the set if not present. Returns `true` if the item was not present, false otherwise.\n- `bool remove(int val)` Removes an item val from the set if present. Returns `true` if the item was present, false otherwise.\n- `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\n\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n```",
      "body": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\n- `bool insert(int val)` Inserts an item val into the set if not present. Returns `true` if the item was not present, false otherwise.\n- `bool remove(int val)` Removes an item val from the set if present. Returns `true` if the item was present, false otherwise.\n- `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\n\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class RandomizedSet {\n\n    private Random random;\n    private Map<Integer, Integer> map;\n    private List<Integer> arr;\n    public RandomizedSet() {\n        random = new Random();\n        map = new HashMap<>();\n        arr = new ArrayList<>();\n    }\n\n    public boolean insert(int val) {\n        if (map.containsKey(val)) return false;\n        map.put(val, arr.size());\n        arr.add(val);\n        return true;\n    }\n\n    public boolean remove(int val) {\n        if (!map.containsKey(val)) return false;\n        int pos = map.get(val);\n        if (pos < arr.size() - 1) {\n            int lastElement = arr.get(arr.size() - 1);\n            map.put(lastElement, pos);\n            arr.set(pos, lastElement);\n        }\n        map.remove(val);\n        arr.remove(arr.size() - 1);\n        return true;\n    }\n\n    public int getRandom() {\n        return arr.get(random.nextInt(arr.size()));\n    }\n}\n\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "integer-to-english-words": {
      "id": "integer-to-english-words",
      "title": "Integer to English Words",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "math",
        "string",
        "recursion"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(1)",
      "sc": "O(1)",
      "leetcode": "integer-to-english-words",
      "gfg": null,
      "leetid": 273,
      "content": "---\nlayout: post\ntitle: Integer to English Words\ndifficulty: hard\ntopics: [math, string, recursion]\nlangs: [java]\ntc: O(1)\nsc: O(1)\ncompanies: [facebook]\nleetid: 273\nleetcode: integer-to-english-words\ngfg: \ninterviewbit: \nhackerrank: \n---\nConvert a non-negative integer `num` to its English words representation.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: num = 123\nOutput: \"One Hundred Twenty Three\"\n```\n**Example 2:**\n```\nInput: num = 12345\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n```\n**Example 3:**\n```\nInput: num = 1234567\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n```\n \n**Constraints:**\n\t\n* `0 <= num <= 2<sup>31</sup> - 1`\n\n",
      "body": "Convert a non-negative integer `num` to its English words representation.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: num = 123\nOutput: \"One Hundred Twenty Three\"\n```\n**Example 2:**\n```\nInput: num = 12345\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n```\n**Example 3:**\n```\nInput: num = 1234567\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n```\n \n**Constraints:**\n\t\n* `0 <= num <= 2<sup>31</sup> - 1`\n\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    private static final String[] LESS_THAN_20 = {\n            \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n            \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\n            \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\n    };\n\n    private static final String[] TENS = {\n            \"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"\n    };\n\n    private static final String[] THOUSANDS = {\n            \"\", \"Thousand\", \"Million\", \"Billion\"\n    };\n\n    public String numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n\n        StringBuilder sb = new StringBuilder();\n        int i = 0;\n\n        while (num > 0) {\n            int chunk = num % 1000;\n            if (chunk != 0) {\n                StringBuilder part = new StringBuilder();\n                helper(chunk, part);\n                if (!THOUSANDS[i].isEmpty()) part.append(THOUSANDS[i]).append(\" \");\n                sb.insert(0, part);\n            }\n            num /= 1000;\n            i++;\n        }\n\n        return sb.toString().trim();\n    }\n\n    private void helper(int num, StringBuilder sb) {\n        if (num == 0) return;\n\n        if (num < 20) {\n            sb.append(LESS_THAN_20[num]).append(\" \");\n        } else if (num < 100) {\n            sb.append(TENS[num / 10]).append(\" \");\n            helper(num % 10, sb);\n        } else {\n            sb.append(LESS_THAN_20[num / 100]).append(\" Hundred \");\n            helper(num % 100, sb);\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "k-closest-points-to-origin": {
      "id": "k-closest-points-to-origin",
      "title": "K Closest Points to Origin",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "math",
        "divide-and-conquer",
        "geometry",
        "sorting",
        "heap-priority-queue",
        "quickselect"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nlogk)",
      "sc": "O(k)",
      "leetcode": "k-closest-points-to-origin",
      "gfg": null,
      "leetid": 1014,
      "content": "---\nlayout: post\ntitle: K Closest Points to Origin\ndifficulty: medium\ntopics: [array, math, divide-and-conquer, geometry, sorting, heap-priority-queue, quickselect]\nlangs: [java]\ntc: O(nlogk)\nsc: O(k)\ncompanies: [facebook]\nleetid: 1014\nleetcode: k-closest-points-to-origin\ngfg: \ninterviewbit: \nhackerrank: \n---\nGiven an array of `points` where `points[i] = [x<sub>i</sub>, y<sub>i</sub>]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.\nThe distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `(x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y<sub>1</sub> - y<sub>2</sub>)<sup>2</sup>`).\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style={{width: '400px', height: '400px'}} />\n```\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n```\n\n**Example 2:**\n```\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n```\n \n**Constraints:**\n\t\n* `1 <= k <= points.length <= 10<sup>4</sup>`\n* `-10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>`\n",
      "body": "Given an array of `points` where `points[i] = [x<sub>i</sub>, y<sub>i</sub>]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.\nThe distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `(x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y<sub>1</sub> - y<sub>2</sub>)<sup>2</sup>`).\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style={{width: '400px', height: '400px'}} />\n```\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n```\n\n**Example 2:**\n```\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n```\n \n**Constraints:**\n\t\n* `1 <= k <= points.length <= 10<sup>4</sup>`\n* `-10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>`\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Long.compare(getArea(b), getArea(a)));\n        for(int[] point: points) {\n            if (pq.size() < k) {\n                pq.offer(point);\n            } else {\n                if (getArea(point) < getArea(pq.peek())) {\n                    pq.poll();\n                    pq.offer(point);\n                }\n            }\n        }\n\n        int[][] res = new int[k][2];\n        while(!pq.isEmpty()) {\n            res[--k] = pq.poll();\n        }\n\n        return res;\n    }\n\n    private long getArea(int[] a) {\n        return (a[0]*a[0] + a[1]*a[1]);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "koko-eating-bananas": {
      "id": "koko-eating-bananas",
      "title": "Koko Eating Bananas",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "binary-search"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(logn)",
      "sc": "O(1)",
      "leetcode": "koko-eating-bananas",
      "gfg": null,
      "leetid": 875,
      "content": "---\nlayout: post\ntitle: Koko Eating Bananas\ntopics: [array, binary-search]\nlangs: [java]\ntc: O(logn)\nsc: O(1)\nleetid: 875\ncompanies: [facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: koko-eating-bananas\n---\n\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. \nThe guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. \nEach hour, she chooses some pile of bananas and eats `k` bananas from that pile. \nIf the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n```\n\n**Example 2:** \n```\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n```\n\n**Example 3:**\n```\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n```",
      "body": "Koko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. \nThe guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. \nEach hour, she chooses some pile of bananas and eats `k` bananas from that pile. \nIf the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n```\n\n**Example 2:** \n```\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n```\n\n**Example 3:**\n```\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int minEatingSpeed(int[] piles, int h) {\n        int max = 0;\n        for(int pile: piles) max = Math.max(max, pile);\n        int left = 0, right = max;\n        while(left <= right) {\n            int mid = left + (right-left)/2;\n            int count = 0;\n            for(int pile: piles) {\n                count += Math.ceil(1.0*pile/mid);\n            }\n            if (count > h) {\n                left = mid+1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "kth-smallest-element-in-a-bst": {
      "id": "kth-smallest-element-in-a-bst",
      "title": "Kth Smallest Element in a BST",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "binary-tree",
        "binary-search-tree",
        "depth-first-search",
        "tree"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(h+k)",
      "sc": "O(h)",
      "leetcode": "kth-smallest-element-in-a-bst",
      "gfg": null,
      "leetid": 230,
      "content": "---\nlayout: post\ntitle: Kth Smallest Element in a BST\ntopics: [binary-tree, binary-search-tree, depth-first-search, tree]\nlangs: [java, py, cpp]\ntc: O(h+k)\nsc: O(h)\nleetid: 230\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: kth-smallest-element-in-a-bst\n---\n\nGiven the root of a binary search tree, and an integer k, return the k<sup>th</sup> smallest value (1-indexed) of all the values of the nodes in the tree.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\nExplanation:\n   3\n  / \\\n 1   4\n  \\\n   2\n```\n\n**Example 2:**\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\nExplanation:\n      5\n     / \\\n    3   6\n   / \\\n  2   4\n /    \n1\n```",
      "body": "Given the root of a binary search tree, and an integer k, return the k<sup>th</sup> smallest value (1-indexed) of all the values of the nodes in the tree.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\nExplanation:\n   3\n  / \\\n 1   4\n  \\\n   2\n```\n\n**Example 2:**\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\nExplanation:\n      5\n     / \\\n    3   6\n   / \\\n  2   4\n /    \n1\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode> stack;\n        while (true) {\n            while (root != nullptr) {\n                stack.push(*root);\n                root = root->left;\n            }\n            root = &stack.top();\n            stack.pop();\n            if (--k == 0) return root->val;\n            root = root->right;\n        }\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> stack = new Stack<>();\n        while(true) {\n            while(root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            if (--k == 0) return root.val;\n            root = root.right;\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "# Definition for a binary tree node.\nfrom typing import Optional\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        while True:\n            while root is not None:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if k == 0:\n                return root.val\n            root = root.right",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "kth-smallest-element-in-a-sorted-matrix": {
      "id": "kth-smallest-element-in-a-sorted-matrix",
      "title": "Kth Smallest Element in a Sorted Matrix",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "binary-search"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "kt"
      ],
      "tc": "O(n+m)",
      "sc": "O(1)",
      "leetcode": "kth-smallest-element-in-a-sorted-matrix",
      "gfg": null,
      "leetid": 378,
      "content": "---\nlayout: post\ntitle: Kth Smallest Element in a Sorted Matrix\ntopics: [array, binary-search]\nlangs: [java, py, cpp, kt]\ntc: O(n+m)\nsc: O(1)\nleetid: 378\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: kth-smallest-element-in-a-sorted-matrix\n---\n\nGiven an `n x n` matrix where each of the rows and columns is sorted in ascending order, \nreturn the k<sup>th</sup> smallest element in the matrix.\n\nNote that it is the k<sup>th</sup> smallest element in the sorted order, \nnot the k<sup>th</sup> distinct element.\n\n---\n\n## How to Solve\n\n### Algorithm\n- Start with `left = minOfMatrix = matrix[0][0]` and `right = maxOfMatrix = matrix[n-1][n-1]`. \n- Find the `mid` of the `left` and the `right`. This middle number is **NOT necessarily** an element in the matrix. \n- If `countLessOrEqual(mid) &gt;= k`, we keep current `ans = mid` and try to find smaller value by searching on the left side. Otherwise, we search on the right side. \n- Since `ans` is the smallest value which `countLessOrEqual(ans) &gt;= k`, so it's the k<sup>th</sup> smallest element in the matrix.\n\n### How to count number of elements less or equal to x efficiently?\n- Since our `matrix` is sorted in ascending order by rows and columns. \n- We use two pointers, one points to the rightmost column `c = n-1`, and one points to the lowest row `r = 0`.\n  - If `matrix[r][c] &lt;= x` then the number of elements in row `r` less or equal to `x` is `(c+1)` (Because `row[r]` is sorted in ascending order, so if `matrix[r][c] &lt;= x` then `matrix[r][c-1]` is also &lt;= `x`). \n  Then we go to next row to continue counting.\n  - Else if `matrix[r][c] &gt; x`, we decrease column c until `matrix[r][c] &lt;= x` (Because column is sorted in ascending order, so if `matrix[r][c] &gt; x` then `matrix[r+1][c]` is also &gt; `x`). \n- Time complexity for counting: `O(M+N)`.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) matrix = [[1,5,9],[10,11,13],[12,13,15]]\n(int) k = 8\n```\n\n**Output:**\n```\n(int) 13\n```\n\n**Explanation:**\n```\nThe elements in the matrix are [1,5,9,10,11,12,13,13,15], \nand the 8th smallest number is 13\n```",
      "body": "Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, \nreturn the k<sup>th</sup> smallest element in the matrix.\n\nNote that it is the k<sup>th</sup> smallest element in the sorted order, \nnot the k<sup>th</sup> distinct element.\n\n---\n\n## How to Solve\n\n### Algorithm\n- Start with `left = minOfMatrix = matrix[0][0]` and `right = maxOfMatrix = matrix[n-1][n-1]`. \n- Find the `mid` of the `left` and the `right`. This middle number is **NOT necessarily** an element in the matrix. \n- If `countLessOrEqual(mid) &gt;= k`, we keep current `ans = mid` and try to find smaller value by searching on the left side. Otherwise, we search on the right side. \n- Since `ans` is the smallest value which `countLessOrEqual(ans) &gt;= k`, so it's the k<sup>th</sup> smallest element in the matrix.\n\n### How to count number of elements less or equal to x efficiently?\n- Since our `matrix` is sorted in ascending order by rows and columns. \n- We use two pointers, one points to the rightmost column `c = n-1`, and one points to the lowest row `r = 0`.\n  - If `matrix[r][c] &lt;= x` then the number of elements in row `r` less or equal to `x` is `(c+1)` (Because `row[r]` is sorted in ascending order, so if `matrix[r][c] &lt;= x` then `matrix[r][c-1]` is also &lt;= `x`). \n  Then we go to next row to continue counting.\n  - Else if `matrix[r][c] &gt; x`, we decrease column c until `matrix[r][c] &lt;= x` (Because column is sorted in ascending order, so if `matrix[r][c] &gt; x` then `matrix[r+1][c]` is also &gt; `x`). \n- Time complexity for counting: `O(M+N)`.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) matrix = [[1,5,9],[10,11,13],[12,13,15]]\n(int) k = 8\n```\n\n**Output:**\n```\n(int) 13\n```\n\n**Explanation:**\n```\nThe elements in the matrix are [1,5,9,10,11,12,13,13,15], \nand the 8th smallest number is 13\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int m, n;\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n        m = matrix.size(), n = matrix[0].size();\n        int left = matrix[0][0], right = matrix[m-1][n-1], ans = -1;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            if (countLessOrEqual(matrix, mid) >= k) {\n                ans = mid;\n                right = mid - 1;\n            } else left = mid + 1;\n        }\n        return ans;\n    }\n    int countLessOrEqual(vector<vector<int>>& matrix, int x) {\n        int cnt = 0, c = n - 1;\n        for (int r = 0; r < m; ++r) {\n            while (c >= 0 && matrix[r][c] > x) --c;\n            cnt += (c + 1);\n        }\n        return cnt;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    int m, n;\n    public int kthSmallest(int[][] matrix, int k) {\n        m = matrix.length; n = matrix[0].length;\n        int left = matrix[0][0], right = matrix[m-1][n-1], ans = -1;\n        while (left <= right) {\n            int mid = (left + right) >> 1;\n            if (countLessOrEqual(matrix, mid) >= k) {\n                ans = mid;\n                right = mid - 1;\n            } else left = mid + 1;\n        }\n        return ans;\n    }\n    int countLessOrEqual(int[][] matrix, int x) {\n        int cnt = 0, c = n - 1;\n        for (int r = 0; r < m; ++r) {\n            while (c >= 0 && matrix[r][c] > x) --c;\n            cnt += (c + 1);\n        }\n        return cnt;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "kt": {
          "language": "kt",
          "code": "class Solution {\n    fun kthSmallest(matrix: Array<IntArray>, k: Int): Int {\n        val m = matrix.size\n        val n = matrix[0].size\n        var left = matrix[0][0]\n        var right = matrix[m-1][n-1]\n        var ans = -1\n        while(left <= right) {\n            val mid = left + (right - left)/2\n            if (countLessAndEqual(matrix, m, n, mid) >= k) {\n                ans = mid\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        }\n        return ans\n    }\n\n    fun countLessAndEqual(matrix: Array<IntArray>, m: Int, n: Int, element: Int): Int {\n        var col = n-1\n        var count = 0\n        var row = 0\n        while (row < m) {\n            while(col >= 0 && matrix[row][col] > element) {\n                col--\n            }\n            count += col + 1\n            row++\n        }\n        return count\n    }\n}",
          "subPath": "",
          "fileName": "solution.kt"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def kthSmallest(self, matrix, k):\n        m, n = len(matrix), len(matrix[0])\n\n        def countLessOrEqual(x):\n            cnt = 0\n            c = n - 1\n            for r in range(m):\n                while c >= 0 and matrix[r][c] > x:\n                    c -= 1\n                cnt += (c + 1)\n            return cnt\n\n        left, right = matrix[0][0], matrix[-1][-1]\n        ans = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if countLessOrEqual(mid) >= k:\n                ans = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return ans",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "largest-number": {
      "id": "largest-number",
      "title": "Largest Number",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "greedy",
        "sorting",
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "largest-number",
      "gfg": null,
      "leetid": 179,
      "content": "---\nlayout: post\ntitle: Largest Number\ntopics: [greedy, sorting, string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 179\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: largest-number\n---\n\nGiven a list of non-negative integers `nums`, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [10,2]\nOutput: \"210\"\n```\n\n**Example 2:** \n```\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\n```",
      "body": "Given a list of non-negative integers `nums`, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [10,2]\nOutput: \"210\"\n```\n\n**Example 2:** \n```\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String largestNumber(int[] nums) {\n        String[] asStrs = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            asStrs[i] = String.valueOf(nums[i]);\n        }\n        Arrays.sort(asStrs, (s1, s2) -> (s2+s1).compareTo(s1+s2));\n        if (asStrs[0].equals(\"0\")) {\n            return \"0\";\n        }\n        String largestNumberStr = new String();\n        for (String numAsStr : asStrs) {\n            largestNumberStr += numAsStr;\n        }\n\n        return largestNumberStr;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "largest-rectangle-in-histogram": {
      "id": "largest-rectangle-in-histogram",
      "title": "Largest Rectangle in Histogram",
      "difficulty": "hard",
      "companies": [
        "facebook",
        "google",
        "amazon"
      ],
      "topics": [
        "array",
        "stack"
      ],
      "langs": [
        "java",
        "py",
        "go",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "largest-rectangle-in-histogram",
      "gfg": "largest-rectangular-area-in-a-histogram-using-segment-tree",
      "leetid": 84,
      "content": "---\nlayout: post\ntitle: Largest Rectangle in Histogram\ntopics: [array, stack]\nlangs: [java, py, go, cpp]\ntc: O(n)\nsc: O(n)\nleetid: 84\ncompanies: [facebook, google, amazon]\ngfg: largest-rectangular-area-in-a-histogram-using-segment-tree\ndifficulty: hard\nhackerrank: \ninterviewbit: largest-rectangle-in-histogram\nleetcode: largest-rectangle-in-histogram\nhellointerview: code/stack/largest-rectangle-in-histogram\n---\n\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, \nreturn the area of the largest rectangle in the `histogram`.\n\n---\n\n## Test Cases\n\n**Input:**\n\n<img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" />\n\n```\n(int[]) heights = [2,1,5,6,2,3]\n```\n\n**Output:**\n```\n(int) 10\n```",
      "body": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, \nreturn the area of the largest rectangle in the `histogram`.\n\n---\n\n## Test Cases\n\n**Input:**\n\n<img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" />\n\n```\n(int[]) heights = [2,1,5,6,2,3]\n```\n\n**Output:**\n```\n(int) 10\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        stack<int> stack;\n        int maxArea = 0, n = heights.size(), i=0;\n        while(i<n) {\n            if (stack.empty() || heights[i] >= heights[stack.top()]) {\n                stack.push(i++);\n            } else {\n                int top = stack.top();\n                stack.pop();\n                int width = stack.empty() ? i : i - stack.top() - 1;\n                maxArea = max(maxArea, width*heights[top]);\n            }\n        }\n        while(!stack.empty()) {\n            int top = stack.top();\n            stack.pop();\n            int width = stack.empty() ? n : n - stack.top() - 1;\n            maxArea = max(maxArea, width*heights[top]);\n        }\n        return maxArea;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "func largestRectangleArea(heights []int) int {\n    i, maxArea, n := 0, 0, len(heights)\n    var stack []int\n    top := -1\n    for i < n {\n        if len(stack) == 0 || heights[i] >= heights[stack[len(stack) - 1]] {\n            stack = append(stack, i)\n            i++\n        } else {\n            top, stack = stack[len(stack)-1], stack[:len(stack)-1]\n            width := i\n            if len(stack) > 0 {\n                width = i - stack[len(stack)-1] -1\n            }\n            area := heights[top]*width\n            if area > maxArea {\n                maxArea = area\n            }\n        }\n    }\n    for len(stack) > 0 {\n        top, stack = stack[len(stack)-1], stack[:len(stack)-1]\n        width := i\n        if len(stack) > 0 {\n            width = i - stack[len(stack)-1] -1\n        }\n        area := heights[top]*width\n        if area > maxArea {\n            maxArea = area\n        }\n    }\n    return maxArea\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int n = heights.length;\n        int maxArea = 0;\n        int i=0;\n        while(i<n) {\n            if (stack.isEmpty() || heights[stack.peek()] <= heights[i]) {\n                stack.push(i++);\n            } else {\n                int top = stack.pop();\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, heights[top]*width);\n            }\n        }\n        while(!stack.isEmpty()) {\n            int top = stack.pop();\n            int width = stack.isEmpty() ? n : n - stack.peek() - 1;\n            maxArea = Math.max(maxArea, heights[top]*width);\n        }\n        return maxArea;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        i, n, maxArea = 0, len(heights), 0\n        stack = []\n        while i<n:\n            if not stack or heights[stack[-1]] <= heights[i]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                width = i if not stack else i-stack[-1]-1\n                maxArea = max(maxArea, heights[top]*width)\n        while stack:\n            top = stack.pop()\n            width = i if not stack else i-stack[-1]-1\n            maxArea = max(maxArea, heights[top]*width)\n        return maxArea",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "least-number-of-unique-integers-after-k-removals": {
      "id": "least-number-of-unique-integers-after-k-removals",
      "title": "Least Number of Unique Integers after K Removals",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "hash-table",
        "greedy",
        "sorting",
        "counting"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "least-number-of-unique-integers-after-k-removals",
      "gfg": null,
      "leetid": 1604,
      "content": "---\nlayout: post\ntitle: Least Number of Unique Integers after K Removals\ntopics: [array, hash-table, greedy, sorting, counting]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 1604\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: least-number-of-unique-integers-after-k-removals\n---\nGiven an array of integers `arr` and an integer `k`. Find the *least number of unique integers* after removing **exactly** `k` elements\n\n---\n## Test Cases\n**Example 1:**\n\n```\nInput: arr = [5,5,4], k = 1\nOutput: 1\nExplanation: Remove the single 4, only 5 is left.\n```\n\n**Example 2:**\n\n```\nInput: arr = [4,3,1,1,3,3,2], k = 3\nOutput: 2\nExplanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n```\n\n**Constraints:**\n\n* `1 <= arr.length <= 10^5`\n\t\n* `1 <= arr[i] <= 10^9`\n\t\n* `0 <= k <= arr.length`",
      "body": "Given an array of integers `arr` and an integer `k`. Find the *least number of unique integers* after removing **exactly** `k` elements\n\n---\n## Test Cases\n**Example 1:**\n\n```\nInput: arr = [5,5,4], k = 1\nOutput: 1\nExplanation: Remove the single 4, only 5 is left.\n```\n\n**Example 2:**\n\n```\nInput: arr = [4,3,1,1,3,3,2], k = 3\nOutput: 2\nExplanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n```\n\n**Constraints:**\n\n* `1 <= arr.length <= 10^5`\n\t\n* `1 <= arr[i] <= 10^9`\n\t\n* `0 <= k <= arr.length`",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int findLeastNumOfUniqueInts(int[] arr, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i = 0; i < arr.length; i++) {\n            count.put(arr[i], count.getOrDefault(arr[i], 0) + 1);\n        }\n        int unique = count.size();\n\n        int[] countArray = new int[100000];\n        for(Integer key : count.keySet()) {\n            int keyCount = count.get(key);\n            countArray[keyCount]++;\n        }\n\n        for (int i = 1; i < 100000; i++) {\n            if (countArray[i]!= 0) {\n                int remove = k / i;\n                if (remove == 0) {\n                    break;\n                } else {\n                    remove = Math.min(remove, countArray[i]);\n                    unique -= remove;\n                    k -= remove * i;\n                }\n            }\n        }\n        return unique;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:\n        count_map = {}\n        for el in arr:\n            count_map[el] = (count_map[el] if el in count_map else 0) + 1\n        freq = [0] * 100000\n        unique = len(count_map)\n        for v in count_map.values():\n            freq[v] += 1\n        for i in range(1, 100000):\n            if freq[i] != 0:\n                remove = k // i\n                if remove == 0:\n                    break\n                else:\n                    remove = min(remove, freq[i])\n                    unique -= remove\n                    k -= remove * i\n        return unique",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "letter-combinations-of-a-phone-number": {
      "id": "letter-combinations-of-a-phone-number",
      "title": "Letter Combinations of a Phone Number",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "goldman",
        "google",
        "intuit",
        "microsoft",
        "oracle",
        "twitter",
        "uber"
      ],
      "topics": [
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "letter-combinations-of-a-phone-number",
      "gfg": "iterative-letter-combinations-of-a-phone-number",
      "leetid": 17,
      "content": "---\nlayout: post\ntitle: Letter Combinations of a Phone Number\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 17\ngfg: iterative-letter-combinations-of-a-phone-number\ncompanies: [adobe, amazon, apple, bloomberg, facebook, goldman, google, intuit, microsoft, oracle, twitter, uber]\ndifficulty: medium\nhackerrank: \ninterviewbit: letter-phone\nleetcode: letter-combinations-of-a-phone-number\n---\n\nGiven a string containing digits from `2-9` inclusive, \nreturn all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that `1` does not map to any letters.\n\n```\n2 -> abc\n3 -> def\n4 -> ghi\n5 -> jkl\n6 -> mno\n7 -> pqrs\n8 -> tuv\n9 -> wxyz\n```\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n```\n\n**Example 2:** \n```\nInput: digits = \"\"\nOutput: []\n```",
      "body": "Given a string containing digits from `2-9` inclusive, \nreturn all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that `1` does not map to any letters.\n\n```\n2 -> abc\n3 -> def\n4 -> ghi\n5 -> jkl\n6 -> mno\n7 -> pqrs\n8 -> tuv\n9 -> wxyz\n```\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n```\n\n**Example 2:** \n```\nInput: digits = \"\"\nOutput: []\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<String> letterCombinations(String digits) {\n        Map<Integer, List<Character>> phone = new HashMap<>();\n        phone.put(2, Arrays.asList('a', 'b', 'c'));\n        phone.put(3, Arrays.asList('d', 'e', 'f'));\n        phone.put(4, Arrays.asList('g', 'h', 'i'));\n        phone.put(5, Arrays.asList('j', 'k', 'l'));\n        phone.put(6, Arrays.asList('m', 'n', 'o'));\n        phone.put(7, Arrays.asList('p', 'q', 'r', 's'));\n        phone.put(8, Arrays.asList('t', 'u', 'v'));\n        phone.put(9, Arrays.asList('w', 'x', 'y', 'z'));\n        List<String> result = new ArrayList<>();\n        if (digits.length() == 0) return result;\n        generate(digits, 0, phone, result, new StringBuilder());\n        return result;\n    }\n\n    private void generate(String digits, int pos, Map<Integer, List<Character>> phone, List<String> result, StringBuilder sb) {\n        if (sb.length() == digits.length()) {\n            result.add(sb.toString());\n            return;\n        }\n        int digit = digits.charAt(pos) - '0';\n        for(Character c: phone.get(digit)) {\n            sb.append(c);\n            generate(digits, pos+1, phone, result, sb);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "linked-list-cycle-ii": {
      "id": "linked-list-cycle-ii",
      "title": "Linked List Cycle II",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "linked-list",
        "two-pointers"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "linked-list-cycle-ii",
      "gfg": null,
      "leetid": 142,
      "content": "---\nlayout: post\ntitle: Linked List Cycle II\ntopics: [linked-list, two-pointers]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 142\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: linked-list-cycle-ii\nhellointerview: code/linked-list/linked-list-cycle\n---\n\nGiven the `head` of a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. \nInternally, `pos` is used to denote the index of the node that tail's next pointer is connected to (0-indexed). \nIt is `-1` if there is no cycle. Note that pos is not passed as a parameter.\n\n**Do not modify the linked list.**\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n```\n\n**Example 2:** \n```\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n```",
      "body": "Given the `head` of a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. \nInternally, `pos` is used to denote the index of the node that tail's next pointer is connected to (0-indexed). \nIt is `-1` if there is no cycle. Note that pos is not passed as a parameter.\n\n**Do not modify the linked list.**\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n```\n\n**Example 2:** \n```\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n        if (fast == null || fast.next == null) return null;\n        slow = head;\n        while(slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return fast;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "longest-consecutive-sequence": {
      "id": "longest-consecutive-sequence",
      "title": "Longest Consecutive Sequence",
      "difficulty": "medium",
      "companies": [
        "amazon",
        "apple",
        "facebook",
        "goldman",
        "google",
        "linkedin",
        "microsoft",
        "salesforce"
      ],
      "topics": [
        "array",
        "hash-table"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "longest-consecutive-sequence",
      "gfg": null,
      "leetid": 128,
      "content": "---\nlayout: post\ntitle: Longest Consecutive Sequence\ntopics: [array, hash-table]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(n)\nleetid: 128\ncompanies: [amazon, apple, facebook, goldman, google, linkedin, microsoft, salesforce]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-consecutive-sequence\n---\n\nGiven an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n```\n\n**Example 2:** \n```\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n```",
      "body": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n```\n\n**Example 2:** \n```\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        set<int> numSet;\n        for(int n: nums) numSet.insert(n);\n\n        int longest = 0;\n        for(int n: numSet) {\n            if (!numSet.count(n-1)) {\n                int currentStreak = 1;\n                int currentNum = n;\n                while(numSet.count(currentNum+1)) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n                longest = max(longest, currentStreak);\n            }\n        }\n        return longest;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for(int n: nums) set.add(n);\n\n        int longest = 0;\n        for(int n: set) {\n            if (!set.contains(n-1)) {\n                int currentStreak = 1;\n                int currentNum = n;\n                while(set.contains(currentNum+1)) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n                longest = Math.max(longest, currentStreak);\n            }\n        }\n        return longest;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        st = set(nums)\n        longest = 0\n        for num in st:\n            if num-1 not in st:\n                currentStreak = 1\n                currentNum = num\n                while (currentNum+1) in st:\n                    currentNum += 1\n                    currentStreak += 1\n                longest = max(longest, currentStreak)\n        return longest",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "longest-cycle-in-graph": {
      "id": "longest-cycle-in-graph",
      "title": "Longest Cycle in Graph",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "depth-first-search",
        "graph",
        "topological-sort"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nm)",
      "sc": "O(nm)",
      "leetcode": "longest-cycle-in-graph",
      "gfg": null,
      "leetid": 2360,
      "content": "---\nlayout: post\ntitle: Longest Cycle in Graph\ntopics: [depth-first-search, graph, topological-sort]\nlangs: [java]\ntc: O(nm)\nsc: O(nm)\nleetid: 2360\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-cycle-in-graph\n---\n\nYou are given a directed graph of n nodes numbered from `0` to `n - 1`, where each node has at most one outgoing edge.\n\nThe graph is represented with a given **0-indexed** array edges of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`.\n\nReturn the *length of the longest cycle in the graph*. If no cycle exists, return `-1`.\n\nA cycle is a path that starts and ends at the same node.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<MdxImage src=\"code/longest-cycle.png\" />\n```\nInput: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: \nThe longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n```\n\n**Example 2:** \n```\nInput: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph.\n```",
      "body": "You are given a directed graph of n nodes numbered from `0` to `n - 1`, where each node has at most one outgoing edge.\n\nThe graph is represented with a given **0-indexed** array edges of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`.\n\nReturn the *length of the longest cycle in the graph*. If no cycle exists, return `-1`.\n\nA cycle is a path that starts and ends at the same node.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<MdxImage src=\"code/longest-cycle.png\" />\n```\nInput: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: \nThe longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n```\n\n**Example 2:** \n```\nInput: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int longestCycle(int[] edges) {\n        int longestCycleLen = -1;\n        int timeStep = 1;\n        int[] nodeVisitedAtTime = new int[edges.length];\n\n        for (int currentNode = 0; currentNode < edges.length; ++currentNode) {\n            if (nodeVisitedAtTime[currentNode] > 0)\n                continue;\n            final int startTime = timeStep;\n            int u = currentNode;\n            while (u != -1 && nodeVisitedAtTime[u] == 0) {\n                nodeVisitedAtTime[u] = timeStep++;\n                u = edges[u];\n            }\n            if (u != -1 && nodeVisitedAtTime[u] >= startTime)\n                longestCycleLen = Math.max(longestCycleLen, timeStep - nodeVisitedAtTime[u]);\n        }\n\n        return longestCycleLen;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "longest-increasing-path-in-a-matrix": {
      "id": "longest-increasing-path-in-a-matrix",
      "title": "Longest Increasing Path in a Matrix",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "depth-first-search",
        "dynamic-programming",
        "graph"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(4<sup>mn</sup>)",
      "sc": "O(mn)",
      "leetcode": "longest-increasing-path-in-a-matrix",
      "gfg": null,
      "leetid": 329,
      "content": "---\nlayout: post\ntitle: Longest Increasing Path in a Matrix\ntopics: [depth-first-search, dynamic-programming, graph]\nlangs: [java, cpp]\ntc: O(4<sup>mn</sup>)\nsc: O(mn)\nleetid: 329\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-increasing-path-in-a-matrix\n---\n\nGiven an `m` x `n` integers `matrix`, return the length of the longest increasing path in `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. \nYou may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n```\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path is [1, 2, 6, 9].\n```\n\n**Example 2:**\n\n```\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]\nOutput: 4\nExplanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n```",
      "body": "Given an `m` x `n` integers `matrix`, return the length of the longest increasing path in `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. \nYou may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n```\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path is [1, 2, 6, 9].\n```\n\n**Example 2:**\n\n```\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]\nOutput: 4\nExplanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int dir[5] = {-1, 0, 1, 0, -1};\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        int mx = 1;\n        for(int i=0; i<m; i++) {\n            for(int j=0; j<n; j++) {\n                mx = max(mx, dfs(i, j, matrix, dp, m, n));\n            }\n        }\n        return mx;\n    }\n\n    int dfs(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &dp, int m, int n) {\n        if (dp[i][j] != 0) return dp[i][j];\n        int mx = 1;\n        for(int k=0; k<4; k++) {\n            int x = i+dir[k], y = j+dir[k+1];\n            if (x < 0 || y < 0 || x >= m || y >= n || matrix[x][y] <= matrix[i][j]) continue;\n            mx = max(mx, 1+dfs(x, y, matrix, dp, m, n));\n        }\n        return dp[i][j] = mx;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int longestIncreasingPath(int[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[][] dp = new int[n][m];\n        int max = 1;\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                max = Math.max(max, dfs(matrix, dp, i, j, n, m));\n            }\n        }\n        return max;\n    }\n\n    private int dfs(int[][] matrix, int[][] dp, int i, int j, int n, int m) {\n        if (dp[i][j] != 0) return dp[i][j];\n        int[] dir = new int[]{-1, 0, 1, 0, -1};\n        int max = 1;\n        for(int k=0; k<4; k++) {\n            int x = i+dir[k], y = j+dir[k+1];\n            if (x<0 || y<0 || x>=n || y>=m || matrix[x][y] <= matrix[i][j]) continue;\n            max = Math.max(max, 1+dfs(matrix, dp, x, y, n, m));\n        }\n        dp[i][j] = max;\n        return max;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "longest-increasing-subsequence": {
      "id": "longest-increasing-subsequence",
      "title": "Longest Increasing Subsequence",
      "difficulty": "medium",
      "companies": [
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "google",
        "microsoft",
        "adobe"
      ],
      "topics": [
        "array",
        "binary-search",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(nlogn)",
      "sc": "O(n)",
      "leetcode": "longest-increasing-subsequence",
      "gfg": "longest-increasing-subsequence-dp-3",
      "leetid": 300,
      "content": "---\nlayout: post\ntitle: Longest Increasing Subsequence\ntopics: [array, binary-search, dynamic-programming]\nlangs: [java, py]\ntc: O(nlogn)\nsc: O(n)\nleetid: 300\ncompanies: [amazon, apple, bloomberg, facebook, google, microsoft, adobe]\ngfg: longest-increasing-subsequence-dp-3\ninterviewbit: longest-increasing-subsequence\ndifficulty: medium\nhackerrank: \nleetcode: longest-increasing-subsequence\n---\n\nGiven an integer array `nums`, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. \nFor example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n```\n\n**Example 2:** \n```\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n```\n\n**Example 3:**\n```\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n```",
      "body": "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. \nFor example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n```\n\n**Example 2:** \n```\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n```\n\n**Example 3:**\n```\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] lis = new int[n];\n        int size = 0;\n        for(int i=0; i<n; i++) {\n            int start = 0, end = size;\n            while(start != end) {\n                int mid = start + (end-start)/2;\n                if (lis[mid] < nums[i]) {\n                    start = mid+1;\n                } else {\n                    end = mid;\n                }\n            }\n            lis[start] = nums[i];\n            if (start == size) ++size;\n        }\n        return size;\n    }\n}\n\n/*\nAlternate solution using DP\n\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n\n        int maxLen = Arrays.stream(dp).max().getAsInt();\n        return maxLen;\n    }\n}\n\n*/",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        size, lis = 0, [0]*len(nums)\n        for num in nums:\n            start, end = 0, size\n            while start != end:\n                mid = start + (end-start)//2\n                if lis[mid] < num:\n                    start = mid+1\n                else:\n                    end = mid\n            lis[start] = num\n            if start == size:\n                size += 1\n        return size",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "longest-palindromic-substring": {
      "id": "longest-palindromic-substring",
      "title": "Longest Palindromic Substring",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "google",
        "linkedin",
        "microsoft",
        "oracle",
        "salesforce"
      ],
      "topics": [
        "string",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(n<sup>2</sup>)",
      "sc": "O(n<sup>2</sup>)",
      "leetcode": "longest-palindromic-substring",
      "gfg": null,
      "leetid": 5,
      "content": "---\nlayout: post\ntitle: Longest Palindromic Substring\ntopics: [string, dynamic-programming]\nlangs: [java, py, cpp]\ntc: O(n<sup>2</sup>)\nsc: O(n<sup>2</sup>)\nleetid: 5\ncompanies: [adobe, amazon, apple, bloomberg, facebook, google, linkedin, microsoft, oracle, salesforce]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-palindromic-substring\n---\n\nGiven a string s, return the longest palindromic substring in s.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n**Example 2:**\n```\nInput: s = \"cbbd\"\nOutput: \"bb\"\n```",
      "body": "Given a string s, return the longest palindromic substring in s.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n**Example 2:**\n```\nInput: s = \"cbbd\"\nOutput: \"bb\"\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.length(), start = 0, end=0;\n        bool dp[n][n];\n        memset(dp, false, sizeof(dp));\n        for(int i=n-1; i>=0; i--) {\n            for(int j=i; j<n; j++) {\n                if (s[i] == s[j] && (j-i <= 2 || dp[i+1][j-1])) {\n                    dp[i][j] = true;\n                }\n                if (dp[i][j] && j-i > end-start) {\n                    end = j;\n                    start = i;\n                }\n            }\n        }\n        return s.substr(start, end-start+1);\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String longestPalindrome(String s) {\n        int best = 0, start = 0, end = 0;\n        for(int i=0; i<s.length(); i++) {\n            int left = i-1;\n            while(i < s.length() - 1 && s.charAt(i) == s.charAt(i+1)) {\n                i++;\n            }\n\n            int right = i+1;\n            while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n                left--;\n                right++;\n            }\n\n            if (right-left > best) {\n                best = right - left;\n                start = left+1;\n                end = right;\n            }\n        }\n        return s.substring(start, end);\n    }\n}\n\n// Alternate solution using dp\n// class Solution {\n//     public String longestPalindrome(String s) {\n//         int n = s.length(), start = 0, end=0;\n//         boolean[][] dp = new boolean[n][n];\n//         for(int i=n-1; i>=0; i--) {\n//             for(int j=i; j<n; j++) {\n//                 if (s.charAt(i) == s.charAt(j) && (j-i <= 2 || dp[i+1][j-1])) {\n//                     dp[i][j] = true;\n//                 }\n//                 if (dp[i][j] && j-i > end-start) {\n//                     end = j;\n//                     start = i;\n//                 }\n//             }\n//         }\n//         return s.substring(start, end+1);\n//     }\n// }",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        best, start, end = 0, 0, 0\n        for i in range(len(s)):\n            left = i-1\n            while i < len(s) - 1 and s[i] == s[i+1]:\n                i += 1\n            \n            right = i+1\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            \n            if right - left > best:\n                best, start, end = right-left, left+1, right\n        return s[start:end]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "longest-repeating-character-replacement": {
      "id": "longest-repeating-character-replacement",
      "title": "Longest Repeating Character Replacement",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "hash-table",
        "string",
        "sliding-window"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "longest-repeating-character-replacement",
      "gfg": null,
      "leetid": 424,
      "content": "---\nlayout: post\ntitle: Longest Repeating Character Replacement\ntopics: [hash-table, string, sliding-window]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 424\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-repeating-character-replacement\nhellointerview: code/sliding-window/longest-repeating-character-replacement\n---\nYou are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\nReturn *the length of the longest substring containing the same letter you can get after performing the above operations*.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\n```\n**Example 2:**\n```\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 10<sup>5</sup>`\n\t\n* `s` consists of only uppercase English letters.\n\t\n* `0 <= k <= s.length`\n\n        ",
      "body": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\nReturn *the length of the longest substring containing the same letter you can get after performing the above operations*.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\n```\n**Example 2:**\n```\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 10<sup>5</sup>`\n\t\n* `s` consists of only uppercase English letters.\n\t\n* `0 <= k <= s.length`\n\n        ",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        int maxfreq = 0, left = 0, ans = 0;\n        vector<int> v(26, 0);\n        for(int right=0; right<s.length(); right++) {\n            v[s[right] - 'A']++;\n            maxfreq = max(maxfreq, v[s[right] - 'A']);\n            if (right - left + 1 - maxfreq > k) {\n                v[s[left] - 'A']--;\n                left++;\n            }\n            ans = max(ans, right - left + 1);\n        }\n        return ans;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n\n    public int characterReplacement(String s, int k) {\n        int[] arr = new int[26];\n        int ans = 0;\n        int max = 0;\n        int i = 0;\n        for (int j = 0; j < s.length(); j++) {\n            arr[s.charAt(j) - 'A']++;\n            max = Math.max(max, arr[s.charAt(j) - 'A']);\n            if (j - i + 1 - max > k) {\n                arr[s.charAt(i) - 'A']--;\n                i++;\n            }\n            ans = Math.max(ans, j - i + 1);\n        }\n        return ans;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "longest-substring-with-at-least-k-repeating-characters": {
      "id": "longest-substring-with-at-least-k-repeating-characters",
      "title": "Longest Substring with at least k repeating characters",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "divide-and-conquer",
        "hash-table",
        "sliding-window",
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(26)",
      "leetcode": "longest-substring-with-at-least-k-repeating-characters",
      "gfg": null,
      "leetid": 395,
      "content": "---\nlayout: post\ntitle: Longest Substring with at least k repeating characters\ntopics: [divide-and-conquer, hash-table, sliding-window, string]\nlangs: [java]\ntc: O(n)\nsc: O(26)\nleetid: 395\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-substring-with-at-least-k-repeating-characters\n---\n\nGiven a string `s` and an integer `k`, \nreturn the length of the longest substring of `s` such that the frequency of each character in this substring is greater than or equal to `k`.\n\n---\n\n## How to Solve\n\nDivide and Conquer is one of the popular strategies that work in 2 phases. \n- Divide the problem into subproblems. (Divide Phase).\n- Repeatedly solve each subproblem independently and combine the result to solve the original problem. (Conquer Phase).\n\nWe could apply this strategy by recursively splitting the string into substrings and \ncombine the result to find the longest substring that satisfies the given condition.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) s = \"aaabb\"\n(int) k = 3\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\n```\n\n---\n\n**Input:**\n```\n(string) s = \"ababbc\"\n(int) k = 2\n```\n\n**Output:**\n```\n(int) 5\n```\n\n**Explanation:**\n```\nThe longest substring is \"ababb\", as 'a' is repeated 2 times, b 3 times.\n```",
      "body": "Given a string `s` and an integer `k`, \nreturn the length of the longest substring of `s` such that the frequency of each character in this substring is greater than or equal to `k`.\n\n---\n\n## How to Solve\n\nDivide and Conquer is one of the popular strategies that work in 2 phases. \n- Divide the problem into subproblems. (Divide Phase).\n- Repeatedly solve each subproblem independently and combine the result to solve the original problem. (Conquer Phase).\n\nWe could apply this strategy by recursively splitting the string into substrings and \ncombine the result to find the longest substring that satisfies the given condition.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) s = \"aaabb\"\n(int) k = 3\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\n```\n\n---\n\n**Input:**\n```\n(string) s = \"ababbc\"\n(int) k = 2\n```\n\n**Output:**\n```\n(int) 5\n```\n\n**Explanation:**\n```\nThe longest substring is \"ababb\", as 'a' is repeated 2 times, b 3 times.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int longestSubstring(String s, int k) {\n        int[] chars = new int[26];\n        for(int i=0; i<s.length(); i++) {\n            chars[s.charAt(i) - 'a'] += 1;\n        }\n        boolean flag = true;\n        for(int i=0; i<26; i++) {\n            if (chars[i] < k && chars[i] > 0) flag = false;\n        }\n        if (flag) return s.length();\n        int pos = 0, max = 0, start = 0;\n        while(pos < s.length()) {\n            if (chars[s.charAt(pos) - 'a'] < k) {\n                max = Math.max(max, longestSubstring(s.substring(start, pos), k));\n                start = pos + 1;\n            }\n            pos++;\n        }\n        max = Math.max(max, longestSubstring(s.substring(start), k));\n        return max;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "longest-substring-without-repeating-characters": {
      "id": "longest-substring-without-repeating-characters",
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "hash-table",
        "sliding-window",
        "string"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "ts"
      ],
      "tc": "O(n)",
      "sc": "O(26)",
      "leetcode": "longest-substring-without-repeating-characters",
      "gfg": null,
      "leetid": 3,
      "content": "---\nlayout: post\ntitle: Longest Substring Without Repeating Characters\ntopics: [hash-table, sliding-window, string]\nlangs: [java, py, cpp, ts]\ntc: O(n)\nsc: O(26)\nleetid: 3\ncompanies: [facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-substring-without-repeating-characters\nhellointerview: code/sliding-window/longest-substring-without-repeating-characters\n---\n\nGiven a string `s`, find the length of the longest substring without repeating characters.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n**Example 2:**\n```\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n```\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```",
      "body": "Given a string `s`, find the length of the longest substring without repeating characters.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n**Example 2:**\n```\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n```\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        vector<int> charIndex(128, -1);\n        int left = 0;\n\n        for (int right = 0; right < n; right++) {\n            if (charIndex[s[right]] >= left) {\n                left = charIndex[s[right]] + 1;\n            }\n            charIndex[s[right]] = right;\n            maxLength = max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        int start = 0, max = 0;\n        for(int i=0; i<s.length(); i++) {\n            if (map.containsKey(s.charAt(i))) {\n                start = Math.max(start, map.get(s.charAt(i))+1);\n            }\n            max = Math.max(max, i-start+1);\n            map.put(s.charAt(i), i);\n        }\n        return max;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        mp, start, mxl = {}, 0, 0\n        for i in range(len(s)):\n            if s[i] in mp:\n                start = max(start, mp[s[i]] + 1)\n            mxl = max(mxl, i - start + 1)\n            mp[s[i]] = i\n        return mxl",
          "subPath": "",
          "fileName": "solution.py"
        },
        "ts": {
          "language": "ts",
          "code": "function lengthOfLongestSubstring(s: string): number {\n    const map = new Map<string, number>();\n    let index = 0, start = 0, maxlength = 0;\n    while(index < s.length) {\n        if (map.has(s[index])) {\n            start = Math.max(start, map.get(s[index])+1);\n        }\n        maxlength = Math.max(maxlength, index-start+1);\n        map.set(s[index], index);\n        index++;\n    }\n    return maxlength;\n};",
          "subPath": "",
          "fileName": "solution.ts"
        }
      }
    },
    "lowest-common-ancestor-of-a-binary-tree": {
      "id": "lowest-common-ancestor-of-a-binary-tree",
      "title": "Lowest Common Ancestor of a Binary Tree",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "amazon",
        "facebook",
        "microsoft",
        "google"
      ],
      "topics": [
        "tree",
        "depth-first-search",
        "binary-tree"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "c"
      ],
      "tc": "O(n)",
      "sc": "O(h)",
      "leetcode": "lowest-common-ancestor-of-a-binary-tree",
      "gfg": "lowest-common-ancestor-binary-tree-set-1",
      "leetid": 236,
      "content": "---\nlayout: post\ntitle: Lowest Common Ancestor of a Binary Tree\ntopics: [tree, depth-first-search, binary-tree]\nlangs: [java, py, cpp, c]\ntc: O(n)\nsc: O(h)\nleetid: 236\ncompanies: [adobe, amazon, facebook, microsoft, google]\ndifficulty: medium\ngfg: lowest-common-ancestor-binary-tree-set-1\nhackerrank: \ninterviewbit: least-common-ancestor\nleetcode: lowest-common-ancestor-of-a-binary-tree\n---\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow <b>a node to be a descendant of itself</b>).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style={{width: '200px', height: '190px'}} />\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n```\n**Example 2:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style={{width: '200px', height: '190px'}} />\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n```\n**Example 3:**\n```\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[2, 10<sup>5</sup>]`.\n\t\n* `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`\n\t\n* All `Node.val` are **unique**.\n\t\n* `p != q`\n\t\n* `p` and `q` will exist in the tree.\n\n        ",
      "body": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow <b>a node to be a descendant of itself</b>).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style={{width: '200px', height: '190px'}} />\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n```\n**Example 2:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style={{width: '200px', height: '190px'}} />\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n```\n**Example 3:**\n```\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[2, 10<sup>5</sup>]`.\n\t\n* `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`\n\t\n* All `Node.val` are **unique**.\n\t\n* `p != q`\n\t\n* `p` and `q` will exist in the tree.\n\n        ",
      "solutions": {
        "c": {
          "language": "c",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if (!root || root == p || root == q) {\n        return root;\n    }\n\n    struct TreeNode *left = lowestCommonAncestor(root->left, p, q);\n    struct TreeNode *right = lowestCommonAncestor(root->right, p, q);\n    if (left && right) {\n        return root;\n    }\n    return left ? left : right;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (!root || root == p || root == q) {\n            return root;\n        }\n\n        TreeNode *left = lowestCommonAncestor(root->left, p, q);\n        TreeNode *right = lowestCommonAncestor(root->right, p, q);\n        if (left && right) {\n            return root;\n        }\n        return left ? left : right;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null) return null;\n        if (root.val == p.val || root.val == q.val) return root;\n\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left != null && right != null) return root;\n        if (left != null) return left;\n        if (right != null) return right;\n        return null;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        if root is None:\n            return None\n        if root.val == p.val or root.val == q.val:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left is not None and right is not None:\n            return root\n        if left is not None:\n            return left\n        if right is not None:\n            return right\n        return None",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "lru-cache": {
      "id": "lru-cache",
      "title": "LRU Cache",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "hash-table",
        "linked-list"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(1)",
      "sc": "O(n)",
      "leetcode": "lru-cache",
      "gfg": null,
      "leetid": 146,
      "content": "---\nlayout: post\ntitle: LRU Cache\ntopics: [hash-table, linked-list]\nlangs: [java, py]\ntc: O(1)\nsc: O(n)\nleetid: 146\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: lru-cache\n---\n\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n\n- `LRUCache(int capacity)` Initialize the LRU cache with positive size capacity.\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\n- `void put(int key, int value)` Update the value of the key if the key exists. \nOtherwise, add the key-value pair to the cache. \nIf the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\n---\n## Test Cases\n\n**Input:**\n```\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n```\n\n**Output:**\n```\n    [null, null, null, 1, null, -1, null, -1, 3, 4]\n```\n\n**Explanation**\n```\n    LRUCache lRUCache = new LRUCache(2);\n    lRUCache.put(1, 1); // cache is {1=1}\n    lRUCache.put(2, 2); // cache is {1=1, 2=2}\n    lRUCache.get(1);    // return 1\n    lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n    lRUCache.get(2);    // returns -1 (not found)\n    lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\n    lRUCache.get(1);    // return -1 (not found)\n    lRUCache.get(3);    // return 3\n    lRUCache.get(4);    // return 4\n```",
      "body": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n\n- `LRUCache(int capacity)` Initialize the LRU cache with positive size capacity.\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\n- `void put(int key, int value)` Update the value of the key if the key exists. \nOtherwise, add the key-value pair to the cache. \nIf the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\n---\n## Test Cases\n\n**Input:**\n```\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n```\n\n**Output:**\n```\n    [null, null, null, 1, null, -1, null, -1, 3, 4]\n```\n\n**Explanation**\n```\n    LRUCache lRUCache = new LRUCache(2);\n    lRUCache.put(1, 1); // cache is {1=1}\n    lRUCache.put(2, 2); // cache is {1=1, 2=2}\n    lRUCache.get(1);    // return 1\n    lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n    lRUCache.get(2);    // returns -1 (not found)\n    lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\n    lRUCache.get(1);    // return -1 (not found)\n    lRUCache.get(3);    // return 3\n    lRUCache.get(4);    // return 4\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Node {\n    int val;\n    int key;\n    Node next;\n    Node prev;\n    Node(int k, int v) {\n        val = v;\n        key = k;\n    }\n}\n\nclass LRUCache {\n\n    private Map<Integer, Node> map;\n    private Node head, tail;\n    private int cursize, maxsize;\n    public LRUCache(int capacity) {\n        map = new HashMap<>();\n        cursize = 0;\n        maxsize = capacity;\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n        Node node = map.get(key);\n        remove(node);\n        add(node);\n        return node.val;\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            remove(map.get(key));\n            cursize--;\n        }\n        Node newNode = new Node(key, value);\n        map.put(key, newNode);\n        add(newNode);\n        cursize++;\n        if (cursize > maxsize) {\n            map.remove(head.next.key);\n            remove(head.next);\n            cursize--;\n        }\n    }\n\n    private void remove(Node node) {\n        Node prev = node.prev;\n        Node next = node.next;\n        prev.next = next;\n        next.prev = prev;\n        node.next = null;\n        node.prev = null;\n    }\n\n    private void add(Node node) {\n        Node prev = tail.prev;\n        prev.next = node;\n        tail.prev = node;\n        node.prev = prev;\n        node.next = tail;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Node:\n    def __init__(self, k, v):\n        self.key = k\n        self.val = v\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.dic = dict()\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key):\n        if key in self.dic:\n            n = self.dic[key]\n            self._remove(n)\n            self._add(n)\n            return n.val\n        return -1\n\n    def put(self, key, value):\n        if key in self.dic:\n            self._remove(self.dic[key])\n        n = Node(key, value)\n        self._add(n)\n        self.dic[key] = n\n        if len(self.dic) > self.capacity:\n            n = self.head.next\n            self._remove(n)\n            del self.dic[n.key]\n\n    def _remove(self, node):\n        p = node.prev\n        n = node.next\n        p.next = n\n        n.prev = p\n\n    def _add(self, node):\n        p = self.tail.prev\n        p.next = node\n        self.tail.prev = node\n        node.prev = p\n        node.next = self.tail",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "matching-pairs": {
      "id": "matching-pairs",
      "title": "Matching Pairs",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": null,
      "gfg": null,
      "content": "---\nlayout: post\ntitle: Matching Pairs\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven two strings s and t of length N, \nfind the maximum number of possible matching pairs in strings s and t after swapping exactly two characters within s.\n\nA swap is switching s[i] and s[j], \nwhere s[i] and s[j] denotes the character that is present at the ith and jth index of s, respectively. \nThe matching pairs of the two strings are defined as the number of indices for which s[i] and t[i] are equal.\n\nNote: This means you must swap two characters at different indices.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"abcd\" t = \"adcb\"\nOutput: 4\nExplanation: Using 0-based indexing, and with i = 1 and j = 3, s[1] and s[3] can be swapped, making it  \"adcb\".\nTherefore, the number of matching pairs of s and t will be 4.\n```\n\n**Output:** \n```\nInput: s = \"mno\" t = \"mno\"\nOutput: 1\nExplanation: Two indices have to be swapped, regardless of which two it is, only one letter will remain the same. \nIf i = 0 and j=1, s[0] and s[1] are swapped, making s = \"nmo\", which shares only \"o\" with t.\n```",
      "body": "Given two strings s and t of length N, \nfind the maximum number of possible matching pairs in strings s and t after swapping exactly two characters within s.\n\nA swap is switching s[i] and s[j], \nwhere s[i] and s[j] denotes the character that is present at the ith and jth index of s, respectively. \nThe matching pairs of the two strings are defined as the number of indices for which s[i] and t[i] are equal.\n\nNote: This means you must swap two characters at different indices.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"abcd\" t = \"adcb\"\nOutput: 4\nExplanation: Using 0-based indexing, and with i = 1 and j = 3, s[1] and s[3] can be swapped, making it  \"adcb\".\nTherefore, the number of matching pairs of s and t will be 4.\n```\n\n**Output:** \n```\nInput: s = \"mno\" t = \"mno\"\nOutput: 1\nExplanation: Two indices have to be swapped, regardless of which two it is, only one letter will remain the same. \nIf i = 0 and j=1, s[0] and s[1] are swapped, making s = \"nmo\", which shares only \"o\" with t.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int matchingPairs(String s, String t) {\n        // Write your code here\n        int match = 0;\n        Set<String> unmatched = new HashSet<>();\n        Set<Character> matched = new HashSet<>();\n        boolean hasDup = false;\n        int n = s.length();\n        for(int i=0; i<n; i++) {\n            if (s.charAt(i) == t.charAt(i)) {\n                match++;\n                if (matched.contains(s.charAt(i))) hasDup = true;\n                matched.add(s.charAt(i));\n            } else {\n                unmatched.add(s.charAt(i)+\"\"+t.charAt(i));\n            }\n        }\n        if (match == n) return hasDup ? n : n-2;\n        if (match == n-1) {\n            String onlyUnmatched = (String)unmatched.toArray()[0];\n            if (hasDup || matched.contains(onlyUnmatched.charAt(0)) || matched.contains(onlyUnmatched.charAt(1))) {\n                return match;\n            }\n            return match - 1;\n        }\n\n        for(String um: unmatched) {\n            if (unmatched.contains(um.charAt(1)+\"\"+um.charAt(0))) {\n                return match+2;\n            }\n        }\n\n        Set<Character> unmatchedS = new HashSet<>();\n        Set<Character> unmatchedT = new HashSet<>();\n\n        for(String um : unmatched) {\n            if(unmatchedS.contains(um.charAt(1)) || unmatchedT.contains(um.charAt(0))) {\n                return match + 1;\n            }\n            unmatchedS.add(um.charAt(0));\n            unmatchedT.add(um.charAt(1));\n        }\n        return match;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "max-area-of-island": {
      "id": "max-area-of-island",
      "title": "Max Area of Island",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "depth-first-search",
        "matrix"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(nm)",
      "sc": "O(1)",
      "leetcode": "max-area-of-island",
      "gfg": null,
      "leetid": 695,
      "content": "---\nlayout: post\ntitle: Max Area of Island\ntopics: [array, depth-first-search, matrix]\nlangs: [java, cpp]\ntc: O(nm)\nsc: O(1)\nleetid: 695\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: max-area-of-island\n---\n\nYou are given an `m` x `n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected\n4-directionally (horizontal or vertical.)\nYou may assume all four edges of the grid are surrounded by water.\n\nThe area of an island is the number of cells with a value `1` on the island.\n\nReturn the maximum area of an island in `grid`. If there is no island, return `0`.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: grid = \n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,1,1,0,1,0,0,0,0,0,0,0,0],\n[0,1,0,0,1,1,0,0,1,0,1,0,0],\n[0,1,0,0,1,1,0,0,1,1,1,0,0],\n[0,0,0,0,0,0,0,0,0,0,1,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\n```\n\n**Example 2:**\n\n```\nInput: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n```",
      "body": "You are given an `m` x `n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected\n4-directionally (horizontal or vertical.)\nYou may assume all four edges of the grid are surrounded by water.\n\nThe area of an island is the number of cells with a value `1` on the island.\n\nReturn the maximum area of an island in `grid`. If there is no island, return `0`.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: grid = \n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,1,1,0,1,0,0,0,0,0,0,0,0],\n[0,1,0,0,1,1,0,0,1,0,1,0,0],\n[0,1,0,0,1,1,0,0,1,1,1,0,0],\n[0,0,0,0,0,0,0,0,0,0,1,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\n```\n\n**Example 2:**\n\n```\nInput: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        int mx = 0;\n        int count[1] = {0};\n        for(int i=0; i<n; i++) {\n            for(int j = 0; j<m; j++) {\n                if (grid[i][j] == 1) {\n                    count[0] = 0;\n                    dfs(grid, n, m, i, j, count);\n                    mx = max(count[0], mx);\n                }\n            }\n        }\n        return mx;\n    }\n\n    void dfs(vector<vector<int>> &grid, int n, int m, int x, int y, int* count) {\n        count[0]++;\n        grid[x][y] = 2;\n        int dir[5] = {-1,0,1,0,-1};\n        for(int i=0; i<4; i++) {\n            int nx = x+dir[i], ny = y+dir[i+1];\n            if(nx>=0 && ny>=0 && nx<n && ny <m && grid[nx][ny] == 1) {\n                dfs(grid,n,m,nx,ny,count);\n            }\n        }\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int n = grid.length, m = grid[0].length;\n        int max = 0;\n        int[] count = new int[]{0};\n        for(int i=0; i<n; i++) {\n            for(int j = 0; j<m; j++) {\n                if (grid[i][j] == 1) {\n                    count[0] = 0;\n                    dfs(grid, n, m, i, j, count);\n                    max = Math.max(count[0], max);\n                }\n            }\n        }\n        return max;\n    }\n\n    private void dfs(int[][] grid, int n, int m, int x, int y, int[] count) {\n        count[0]++;\n        grid[x][y] = 2;\n        int[] dir = new int[]{-1,0,1,0,-1};\n        for(int i=0; i<4; i++) {\n            int nx = x+dir[i], ny = y+dir[i+1];\n            if(nx>=0 && ny>=0 && nx<n && ny <m && grid[nx][ny] == 1) {\n                dfs(grid,n,m,nx,ny,count);\n            }\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "max-consecutive-ones-iii": {
      "id": "max-consecutive-ones-iii",
      "title": "Max Consecutive Ones III",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "binary-search",
        "sliding-window"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "max-consecutive-ones-iii",
      "gfg": null,
      "leetid": 1004,
      "content": "---\nlayout: post\ntitle: Max Consecutive Ones III\ntopics: [array, binary-search, sliding-window]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 1004\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: max-consecutive-ones-iii\n---\n\nGiven a binary array `nums` and an integer `k`, return the maximum number of consecutive `1`'s in the array if you can flip at most `k` `0`'s.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```\n\n**Example 2:** \n```\nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\nOutput: 10\nExplanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```",
      "body": "Given a binary array `nums` and an integer `k`, return the maximum number of consecutive `1`'s in the array if you can flip at most `k` `0`'s.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```\n\n**Example 2:** \n```\nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\nOutput: 10\nExplanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int longestOnes(int[] nums, int k) {\n        int windowLeft = 0, windowRight = 0;\n        int bestWindow = 0, bestLeft = 0;\n        int n = nums.length, zeroCount = 0;\n        while(windowRight < n) {\n            if (zeroCount <= k) {\n                if (nums[windowRight] == 0) zeroCount++;\n                windowRight++;\n            }\n            if (zeroCount > k) {\n                if (nums[windowLeft] == 0) zeroCount--;\n                windowLeft++;\n            }\n            if (windowRight-windowLeft > bestWindow && zeroCount <= k) {\n                bestWindow = windowRight-windowLeft;\n                bestLeft = windowLeft;\n            }\n        }\n        return bestWindow;\n\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "max-increase-to-keep-city-skyline": {
      "id": "max-increase-to-keep-city-skyline",
      "title": "Max Increase to Keep City Skyline",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "greedy"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n<sup>2</sup>)",
      "sc": "O(n)",
      "leetcode": "max-increase-to-keep-city-skyline",
      "gfg": null,
      "leetid": 807,
      "content": "---\nlayout: post\ntitle: Max Increase to Keep City Skyline\ntopics: [array, greedy]\nlangs: [java, py]\ntc: O(n<sup>2</sup>)\nsc: O(n)\nleetid: 807\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: max-increase-to-keep-city-skyline\n---\n\nThere is a city composed of `n x n` blocks, \nwhere each block contains a single building shaped like a vertical square prism. \nYou are given a 0-indexed `n x n` integer matrix grid where \n`grid[r][c]` represents the height of the building located in the block at row `r` and column `c`.\n\nA city's `skyline` is the outer contour formed by all the building when viewing the side of the city from a distance. \nThe skyline from each cardinal direction north, east, south, and west may be different.\n\nWe are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). \nThe height of a `0`-height building can also be increased. \nHowever, increasing the height of a building should not affect the city's skyline from any cardinal direction.\n\nReturn the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<MdxImage src=\"code/max-skyline.png\" alt=\"Max Skyline\" />\n\n```\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n```\n\n**Example 2:** \n```\nInput: grid = [[0,0,0],[0,0,0],[0,0,0]]\nOutput: 0\nExplanation: Increasing the height of any building will result in the skyline changing.\n```",
      "body": "There is a city composed of `n x n` blocks, \nwhere each block contains a single building shaped like a vertical square prism. \nYou are given a 0-indexed `n x n` integer matrix grid where \n`grid[r][c]` represents the height of the building located in the block at row `r` and column `c`.\n\nA city's `skyline` is the outer contour formed by all the building when viewing the side of the city from a distance. \nThe skyline from each cardinal direction north, east, south, and west may be different.\n\nWe are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). \nThe height of a `0`-height building can also be increased. \nHowever, increasing the height of a building should not affect the city's skyline from any cardinal direction.\n\nReturn the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<MdxImage src=\"code/max-skyline.png\" alt=\"Max Skyline\" />\n\n```\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n```\n\n**Example 2:** \n```\nInput: grid = [[0,0,0],[0,0,0],[0,0,0]]\nOutput: 0\nExplanation: Increasing the height of any building will result in the skyline changing.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maxIncreaseKeepingSkyline(int[][] grid) {\n        int sum = 0;\n        int n = grid.length;\n        int[] row = new int[n], col = new int[n];\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                row[i] = Math.max(row[i], grid[i][j]);\n                col[j] = Math.max(col[j], grid[i][j]);\n            }\n        }\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                int nh = Math.min(row[i], col[j]);\n                if (nh > grid[i][j]) sum += nh - grid[i][j];\n            }\n        }\n        return sum;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        row, col = [0]*n, [0]*n\n        for i in range(n):\n            for j in range(n):\n                row[i] = max(row[i], grid[i][j])\n                col[j] = max(col[j], grid[i][j])\n\n        increase = 0\n        for i in range(n):\n            for j in range(n):\n                newheight = min(row[i], col[j])\n                if newheight > grid[i][j]:\n                    increase += newheight - grid[i][j]\n        return increase",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "maximal-rectangle": {
      "id": "maximal-rectangle",
      "title": "Maximal Rectangle",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming",
        "matrix",
        "stack"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(nm)",
      "sc": "O(m)",
      "leetcode": "maximal-rectangle",
      "gfg": null,
      "leetid": 85,
      "content": "---\nlayout: post\ntitle: Maximal Rectangle\ntopics: [array, dynamic-programming, matrix, stack]\nlangs: [java, cpp]\ntc: O(nm)\nsc: O(m)\nleetid: 85\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximal-rectangle\n---\n\nGiven a `rows x cols` binary matrix filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: grid = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\n```",
      "body": "Given a `rows x cols` binary matrix filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: grid = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        int rows = matrix.size(), cols = matrix[0].size();\n        vector<int> histogram(cols, 0);\n        for(int i=0; i<cols; i++) {\n            histogram[i] = matrix[0][i] - '0';\n        }\n        int maxArea = largestHistogram(histogram);\n        for(int i=1; i<rows; i++) {\n            for(int j=0; j<cols; j++) {\n                histogram[j] = matrix[i][j] == '1' ? histogram[j] + 1 : 0;\n            }\n            maxArea = max(maxArea, largestHistogram(histogram));\n        }\n        return maxArea;\n    }\n\n    int largestHistogram(vector<int> &matrix) {\n        stack<int> st;\n        int n = matrix.size();\n        int maxArea = 0, i = 0;\n        while(i<n) {\n            if (st.empty() || matrix[st.top()] <= matrix[i]) {\n                st.push(i++);\n            } else {\n                int top = st.top(); st.pop();\n                int width = st.empty() ? i : i - st.top() - 1;\n                maxArea = max(maxArea, matrix[top]*width);\n            }\n        }\n        while(!st.empty()) {\n            int top = st.top(); st.pop();\n            int width = st.empty() ? n : n - st.top() - 1;\n            maxArea = max(maxArea, matrix[top]*width);\n        }\n        return maxArea;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int rows = matrix.length, cols = matrix[0].length;\n        int[] histogram = new int[cols];\n        for(int i=0; i<cols; i++) {\n            histogram[i] = matrix[0][i] - '0';\n        }\n        int maxArea = largestRectangleArea(histogram);\n        for(int i=1; i<rows; i++) {\n            for(int j=0; j<cols; j++) {\n                histogram[j] = matrix[i][j] == '1' ? histogram[j]+1 : 0;\n            }\n            int result = largestRectangleArea(histogram);\n            maxArea = Math.max(maxArea, result);\n        }\n        return maxArea;\n    }\n\n    private int largestRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int n = heights.length;\n        int maxArea = 0;\n        int i=0;\n        while(i<n) {\n            if (stack.isEmpty() || heights[stack.peek()] <= heights[i]) {\n                stack.push(i++);\n            } else {\n                int top = stack.pop();\n                int width = stack.isEmpty() ? i : i - stack.peek() - 1;\n                maxArea = Math.max(maxArea, heights[top]*width);\n            }\n        }\n        while(!stack.isEmpty()) {\n            int top = stack.pop();\n            int width = stack.isEmpty() ? n : n - stack.peek() - 1;\n            maxArea = Math.max(maxArea, heights[top]*width);\n        }\n        return maxArea;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "maximal-square": {
      "id": "maximal-square",
      "title": "Maximal Square",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming",
        "matrix"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(mn)",
      "sc": "O(mn)",
      "leetcode": "maximal-square",
      "gfg": null,
      "leetid": 221,
      "content": "---\nlayout: post\ntitle: Maximal Square\ntopics: [array, dynamic-programming, matrix]\nlangs: [java]\ntc: O(mn)\nsc: O(mn)\nleetid: 221\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximal-square\n---\n\nGiven an `m x n` binary matrix filled with `0`'s and `1`'s, find the largest square containing only `1`'s and return its area.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\n\n```\n\n**Example 2:** \n\n\n```\nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\n```",
      "body": "Given an `m x n` binary matrix filled with `0`'s and `1`'s, find the largest square containing only `1`'s and return its area.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\n\n```\n\n**Example 2:** \n\n\n```\nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maximalSquare(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[][] dp = new int[n+1][m+1];\n        int max = 0;\n        for(int i=1; i<=n; i++) {\n            for(int j=1; j<=m; j++) {\n                if (matrix[i-1][j-1] == '1') {\n                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\n                    max = Math.max(max, dp[i][j]);\n                }\n            }\n        }\n        return max*max;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "maximum-frequency-stack": {
      "id": "maximum-frequency-stack",
      "title": "Maximum Frequency Stack",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "hash-table",
        "heap",
        "queue"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(logn)",
      "sc": "O(n)",
      "leetcode": "maximum-frequency-stack",
      "gfg": null,
      "leetid": 895,
      "content": "---\nlayout: post\ntitle: Maximum Frequency Stack\ntopics: [hash-table, heap, queue]\nlangs: [java]\ntc: O(logn)\nsc: O(n)\nleetid: 895\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximum-frequency-stack\n---\n\nDesign a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n\nImplement the FreqStack class:\n- `FreqStack()` constructs an empty frequency stack. \n- `void push(int val)` pushes an integer val onto the top of the stack. \n- `int pop()` removes and returns the most frequent element in the stack. \n  - If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\nExplanation\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n```\n\n**Example 2:** \n```\nInput\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"pop\", \"pop\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\"]\n[[],[1], [1], [1], [2], [], [], [2], [2], [1], [], [], []]\nOutput\n[null,null,null,null,null,1,1,null,null,null,2,1,2]\n```",
      "body": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n\nImplement the FreqStack class:\n- `FreqStack()` constructs an empty frequency stack. \n- `void push(int val)` pushes an integer val onto the top of the stack. \n- `int pop()` removes and returns the most frequent element in the stack. \n  - If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\nExplanation\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n```\n\n**Example 2:** \n```\nInput\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"pop\", \"pop\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\"]\n[[],[1], [1], [1], [2], [], [], [2], [2], [1], [], [], []]\nOutput\n[null,null,null,null,null,1,1,null,null,null,2,1,2]\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class FreqStack {\n\n    private PriorityQueue<Node> pq;\n    private Map<Integer, Integer> freq;\n    private int index;\n    public FreqStack() {\n        pq = new PriorityQueue<>();\n        freq = new HashMap<>();\n        index = 0;\n    }\n\n    public void push(int val) {\n        freq.put(val, freq.getOrDefault(val, 0) + 1);\n        pq.offer(new Node(val, freq.get(val), index++));\n    }\n\n    public int pop() {\n        Node top = pq.poll();\n        freq.put(top.val, freq.get(top.val) - 1);\n        return top.val;\n    }\n}\n\nclass Node implements Comparable<Node> {\n    int val;\n    int freq;\n    int index;\n    Node(int v, int f, int i) {\n        val = v;\n        freq = f;\n        index = i;\n    }\n\n    public int compareTo(Node o) {\n        if (this.freq != o.freq) return o.freq - this.freq;\n        return o.index - this.index;\n    }\n}\n\n/**\n * Your FreqStack object will be instantiated and called as such:\n * FreqStack obj = new FreqStack();\n * obj.push(val);\n * int param_2 = obj.pop();\n */",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "maximum-product-subarray": {
      "id": "maximum-product-subarray",
      "title": "Maximum Product Subarray",
      "difficulty": "medium",
      "companies": [
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "google",
        "linkedin",
        "microsoft"
      ],
      "topics": [
        "array",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "maximum-product-subarray",
      "gfg": null,
      "leetid": 152,
      "content": "---\nlayout: post\ntitle: Maximum Product Subarray\ntopics: [array, dynamic-programming]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 152\ncompanies: [amazon, apple, bloomberg, facebook, google, linkedin, microsoft]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximum-product-subarray\n---\n\nGiven an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\nA **subarray** is a contiguous subsequence of the array.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [2,3,-2,4]\n```\n\n**Output:** \n```\n(int) 6\n```\n\n**Explanation:**\n```\n[2,3] has the largest product 6.\n```",
      "body": "Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\nA **subarray** is a contiguous subsequence of the array.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [2,3,-2,4]\n```\n\n**Output:** \n```\n(int) 6\n```\n\n**Explanation:**\n```\n[2,3] has the largest product 6.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int n = nums.size(), l = 0, r = 0, res = nums[0];\n        for(int i=0; i<n; i++) {\n            l = (l==0 ? 1 : l) * nums[i];\n            r = (r==0 ? 1 : r) * nums[n-i-1];\n            res = max(res, max(l, r));\n        }\n        return res;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maxProduct(int[] A) {\n        int n = A.length, res = A[0], l = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            l =  (l == 0 ? 1 : l) * A[i];\n            r =  (r == 0 ? 1 : r) * A[n - 1 - i];\n            res = Math.max(res, Math.max(l, r));\n        }\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        rev = nums[::-1]\n        for i in range(1, len(nums)):\n            nums[i] *= nums[i-1] or 1\n            rev[i] *= rev[i-1] or 1\n        return max(nums + rev)",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "maximum-subarray": {
      "id": "maximum-subarray",
      "title": "Maximum Subarray",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "divide-and-conquer",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "cpp",
        "py",
        "go"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "maximum-subarray",
      "gfg": "find-subarray-with-given-sum",
      "leetid": 53,
      "content": "---\nlayout: post\ntitle: Maximum Subarray\ntopics: [array, divide-and-conquer, dynamic-programming]\nlangs: [java, cpp, py, go]\ntc: O(n)\nsc: O(n)\nleetid: 53\ncompanies: [facebook]\ngfg: find-subarray-with-given-sum\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: maximum-subarray\n---\nGiven an integer array `nums`, find the `subarray` with the largest sum, and return *its sum*.\n \n---\n## How to Solve:\n\nThe idea of Kadane's algorithm is to traverse over the array from left to right and for each element, \nfind the maximum sum among all subarrays ending at that element. The result will be the maximum of all these values.\n\nBut, the main issue is how to calculate maximum sum among all the subarrays ending at an element in O(N) time?\n\nTo calculate the maximum sum of subarray ending at current element, say maxEnding, \nwe can use the maximum sum ending at the previous element. So for any element, we have two choices:\n\n* Choice 1: Extend the maximum sum subarray ending at the previous element by adding the current element to it. \nIf the maximum subarray sum ending at the previous index is positive, then it is always better to extend the subarray.\n* Choice 2: Start a new subarray starting from the current element. \n* If the maximum subarray sum ending at the previous index is negative, \n* it is always better to start a new subarray from the current element.\n\nThis means that maxEnding at index `i = max(maxEnding at index (i - 1) + arr[i], arr[i])` \nand the maximum value of `maxEnding` at any index will be our answer.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n**Example 2:**\n```\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n**Example 3:**\n```\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 10<sup>5</sup>`\n\t\n* `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`\n \n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.\n\n        ",
      "body": "Given an integer array `nums`, find the `subarray` with the largest sum, and return *its sum*.\n \n---\n## How to Solve:\n\nThe idea of Kadane's algorithm is to traverse over the array from left to right and for each element, \nfind the maximum sum among all subarrays ending at that element. The result will be the maximum of all these values.\n\nBut, the main issue is how to calculate maximum sum among all the subarrays ending at an element in O(N) time?\n\nTo calculate the maximum sum of subarray ending at current element, say maxEnding, \nwe can use the maximum sum ending at the previous element. So for any element, we have two choices:\n\n* Choice 1: Extend the maximum sum subarray ending at the previous element by adding the current element to it. \nIf the maximum subarray sum ending at the previous index is positive, then it is always better to extend the subarray.\n* Choice 2: Start a new subarray starting from the current element. \n* If the maximum subarray sum ending at the previous index is negative, \n* it is always better to start a new subarray from the current element.\n\nThis means that maxEnding at index `i = max(maxEnding at index (i - 1) + arr[i], arr[i])` \nand the maximum value of `maxEnding` at any index will be our answer.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n**Example 2:**\n```\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n**Example 3:**\n```\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 10<sup>5</sup>`\n\t\n* `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`\n \n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.\n\n        ",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int s = nums.size();\n        if (s == 1) return nums[0];\n        int mx = 0;\n        int msf = nums[0];\n        for(int i=0; i<s; i++) {\n            mx += nums[i];\n            if (mx > msf) msf = mx;\n            if (mx < 0) mx = 0;\n        }\n        return msf;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "func maxSubArray(nums []int) int {\n    x := nums[0]\n    res := 0\n    for i := 0; i<len(nums); i++ {\n        res = Max(nums[i], res+nums[i])\n        x = Max(res, x)\n    }\n    return x\n}\n\nfunc Max(x, y int) int {\n    if x < y {\n        return y\n    }\n    return x\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int sum = 0, max = Integer.MIN_VALUE;\n        for(int n: nums) {\n            sum += n;\n            max = Math.max(max, sum);\n            sum = Math.max(sum, 0);\n        }\n        return max;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if len(nums) == 1: return nums[0]\n        msf = nums[0]\n        mx = 0\n        for i in range(len(nums)):\n            mx += nums[i]\n            if mx > msf:\n                msf = mx\n            if mx < 0:\n                mx = 0\n        return msf",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "maximum-width-of-binary-tree": {
      "id": "maximum-width-of-binary-tree",
      "title": "Maximum Width of Binary Tree",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "binary-tree",
        "depth-first-search",
        "tree"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(h)",
      "sc": "O(1)",
      "leetcode": "maximum-width-of-binary-tree",
      "gfg": null,
      "leetid": 662,
      "content": "---\nlayout: post\ntitle: Maximum Width of Binary Tree\ntopics: [binary-tree, depth-first-search, tree]\nlangs: [java, py]\ntc: O(h)\nsc: O(1)\nleetid: 662\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximum-width-of-binary-tree\n---\n\nGiven the root of a binary tree, return the **_maximum width_** of the given tree.\n\nThe **maximum width** of a tree is the maximum width among all levels.\n\nThe **width** of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.\n\nIt is guaranteed that the answer will in the range of 32-bit signed integer.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [1,3,null,5,3]\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n    1\n   / \\\n  3   2\n / \\   \\\n5   3   9\n```\n\n**Example 2:** \n```\nInput: root = [1,3,2,5]\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n    1\n   / \\\n  3   2\n /\n5\n```\n",
      "body": "Given the root of a binary tree, return the **_maximum width_** of the given tree.\n\nThe **maximum width** of a tree is the maximum width among all levels.\n\nThe **width** of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.\n\nIt is guaranteed that the answer will in the range of 32-bit signed integer.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [1,3,null,5,3]\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n    1\n   / \\\n  3   2\n / \\   \\\n5   3   9\n```\n\n**Example 2:** \n```\nInput: root = [1,3,2,5]\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n    1\n   / \\\n  3   2\n /\n5\n```\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int widthOfBinaryTree(TreeNode root) {\n        Map<TreeNode, Integer> map = new HashMap<>();\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        map.put(root, 1);\n        int maxWidth = 0, start=0, end=0;\n        while(!q.isEmpty()) {\n            int n = q.size();\n            for(int i=0; i<n; i++) {\n                TreeNode node = q.poll();\n                if (i==0) start = map.get(node);\n                if (i==n-1) end = map.get(node);\n                if (node.left != null) {\n                    q.offer(node.left);\n                    map.put(node.left, 2*map.get(node));\n                }\n                if (node.right != null) {\n                    q.offer(node.right);\n                    map.put(node.right, 1 + 2*map.get(node));\n                }\n            }\n            maxWidth = Math.max(maxWidth, end-start+1);\n        }\n        return maxWidth;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import  Optional\n\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        mp, q = {}, []\n        if root is None:\n            return 0\n        q.append(root)\n        start, end, mxw = 0, 0, 0\n        mp[root] = 1\n        while q:\n            size = len(q)\n            for i in range(size):\n                node = q.pop(0)\n                if i == 0:\n                    start = mp[node]\n                if i == size-1:\n                    end = mp[node]\n                if node.left:\n                    q.append(node.left)\n                    mp[node.left] = 2*mp[node]\n                if node.right:\n                    q.append(node.right)\n                    mp[node.right] = 2*mp[node] + 1\n            mxw = max(mxw, end-start+1)\n        return mxw",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "median-of-two-sorted-arrays": {
      "id": "median-of-two-sorted-arrays",
      "title": "Median of Two Sorted Arrays",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "binary-search",
        "divide-and-conquer"
      ],
      "langs": [
        "java",
        "cpp",
        "py",
        "kt",
        "ts"
      ],
      "tc": "O(log(m+n))",
      "sc": "O(1)",
      "leetcode": "median-of-two-sorted-arrays",
      "gfg": "median-of-two-sorted-arrays-of-different-sizes",
      "leetid": 4,
      "content": "---\nlayout: post\ntitle: Median of Two Sorted Arrays\ntopics: [array, binary-search, divide-and-conquer]\nlangs: [java, cpp, py, kt, ts]\ntc: O(log(m+n))\nsc: O(1)\nleetid: 4\ngfg: median-of-two-sorted-arrays-of-different-sizes\ncompanies: [facebook]\ndifficulty: hard\nhackerrank: \ninterviewbit: \nleetcode: median-of-two-sorted-arrays\n---\n\nGiven two sorted arrays, a[] and b[], the task is to find the median of these sorted arrays, in `O(log n + log m)` time complexity, \nwhen n is the number of elements in the first array, and m is the number of elements in the second array.\n\n---\n## How to Solve\n\n1. Let assume that there are two arrays `A` and `B` with array `A` having the minimum number of elements.\n   If this is not the case than swap `A` and `B` to make `A` having small size.\n2. The edge cases like one array is empty or both are empty will be handled.\n   1. let `n` be the size of `A` and `m` be the size of `B`. \n   2. Now think of an idea that if we have to find the median than we have to divide the whole merged array into two parts\n   namely `left` and `right` parts. \n   3. Now since we are given the size of left part (i.e (n+m+1)/2), Now look at below given example.\n      ```\n      A-> 1,2,3,4,5     n = 5\n      B-> 1,2,3,4,5,6   m = 6\n      ```\n\n      Here merged array will look like :- <span style={{color:'orange'}}>1,1,2,2,3</span>,3,<span style={{color:'green'}}>4,4,5,5,6</span> \n      and median then is `3`\n   \n   4. Now we can see our left part which is in <span style={{color:'orange'}}>orange</span>. \n   5. We divide A and B into two parts such that the sum of left part of both A and B will result in left part of merged array.\n      ```\n      A-> 1,2,3,4,5     // pointers l =0 and r = n-1 hence mid = (l+r)/2;\n      B -> 1,2,3,4,5,6\n      ```\n      we can see that left part of A is given as `n/2` and since total length of left part in merged array\n      is `(m+n+1)/2`, so left part of B = `(m+n+1)/2-n/2`;\n\n      Now we just have to confirm if our left and right partitions in `A` and `B` are correct or not.\n\n3. Now we have 4 variables indicating four values two from array A and two from array B.\n   ```   \n   leftA -> Rightmost element in left part of A = 2\n   leftb -> Rightmost element in left part of B = 4\n   rightA -> Leftmost element in right part of A = 3\n   rightB -> Leftmost element in right part of B = 5\n   ```\n\n   Hence to confirm that partition is correct we have to check the following conditions.\n\n   `leftA<=rightB` and `leftB<=rightA`  // This is the case when the sum of two parts of A and B results in left part of merged array\n\n   if our partition not works that means we have to  find other mid point in A and then left part in B\n   This is seen when\n   ```\n   leftA > rightB    //means we have to dec size of A's partition\n   so do r = mid-1;\n   else\n   do l =mid+1;\n   ```\n\n   Hence repeat the above steps with new partitions till we get the answers.\n\n4. If `leftA<=rightB` and `leftB<=rightA`\n   then we get correct partition and our answer depends on the total size of merged array (i.e. m+n)\n   ```\n   If (m+n)%2==0\n   ans is max(leftA,leftB)+min(rightA,rightB)/2; // max of left part is nearest to median and min of right part is nearest to medain\n   else\n   ans is max(leftA,leftB);\n   ```\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n**Example 2:**\n```\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```",
      "body": "Given two sorted arrays, a[] and b[], the task is to find the median of these sorted arrays, in `O(log n + log m)` time complexity, \nwhen n is the number of elements in the first array, and m is the number of elements in the second array.\n\n---\n## How to Solve\n\n1. Let assume that there are two arrays `A` and `B` with array `A` having the minimum number of elements.\n   If this is not the case than swap `A` and `B` to make `A` having small size.\n2. The edge cases like one array is empty or both are empty will be handled.\n   1. let `n` be the size of `A` and `m` be the size of `B`. \n   2. Now think of an idea that if we have to find the median than we have to divide the whole merged array into two parts\n   namely `left` and `right` parts. \n   3. Now since we are given the size of left part (i.e (n+m+1)/2), Now look at below given example.\n      ```\n      A-> 1,2,3,4,5     n = 5\n      B-> 1,2,3,4,5,6   m = 6\n      ```\n\n      Here merged array will look like :- <span style={{color:'orange'}}>1,1,2,2,3</span>,3,<span style={{color:'green'}}>4,4,5,5,6</span> \n      and median then is `3`\n   \n   4. Now we can see our left part which is in <span style={{color:'orange'}}>orange</span>. \n   5. We divide A and B into two parts such that the sum of left part of both A and B will result in left part of merged array.\n      ```\n      A-> 1,2,3,4,5     // pointers l =0 and r = n-1 hence mid = (l+r)/2;\n      B -> 1,2,3,4,5,6\n      ```\n      we can see that left part of A is given as `n/2` and since total length of left part in merged array\n      is `(m+n+1)/2`, so left part of B = `(m+n+1)/2-n/2`;\n\n      Now we just have to confirm if our left and right partitions in `A` and `B` are correct or not.\n\n3. Now we have 4 variables indicating four values two from array A and two from array B.\n   ```   \n   leftA -> Rightmost element in left part of A = 2\n   leftb -> Rightmost element in left part of B = 4\n   rightA -> Leftmost element in right part of A = 3\n   rightB -> Leftmost element in right part of B = 5\n   ```\n\n   Hence to confirm that partition is correct we have to check the following conditions.\n\n   `leftA<=rightB` and `leftB<=rightA`  // This is the case when the sum of two parts of A and B results in left part of merged array\n\n   if our partition not works that means we have to  find other mid point in A and then left part in B\n   This is seen when\n   ```\n   leftA > rightB    //means we have to dec size of A's partition\n   so do r = mid-1;\n   else\n   do l =mid+1;\n   ```\n\n   Hence repeat the above steps with new partitions till we get the answers.\n\n4. If `leftA<=rightB` and `leftB<=rightA`\n   then we get correct partition and our answer depends on the total size of merged array (i.e. m+n)\n   ```\n   If (m+n)%2==0\n   ans is max(leftA,leftB)+min(rightA,rightB)/2; // max of left part is nearest to median and min of right part is nearest to medain\n   else\n   ans is max(leftA,leftB);\n   ```\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n**Example 2:**\n```\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int n1 = nums1.size(), n2 = nums2.size();\n        if (n1 > n2) return findMedianSortedArrays(nums2, nums1);\n        int start = 0, end = n1;\n        while(start <= end) {\n            int mid1 = start + (end-start)/2;\n            int mid2 = (n1+n2+1)/2 - mid1;\n            int x1 = mid1 == 0 ? INT_MIN : nums1[mid1-1];\n            int x2 = mid2 == 0 ? INT_MIN : nums2[mid2-1];\n            int y1 = mid1 == n1 ? INT_MAX : nums1[mid1];\n            int y2 = mid2 == n2 ? INT_MAX : nums2[mid2];\n            if (x1 <= y2 && x2 <= y1) {\n                if ((n1+n2)%2 == 0) {\n                    return (max(x1, x2) + min(y1, y2)) /2.0;\n                } else {\n                    return max(x1, x2);\n                }\n            }\n            if (x1 > y2) {\n                end = mid1 - 1;\n            } else {\n                start = mid1 + 1;\n            }\n        }\n        return -1;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "import java.lang.*;\n\nclass Solution {\n    private static double findMedian(int[] arr1, int[] arr2) {\n        int n1 = arr1.length, n2 = arr2.length;\n        if (n1 > n2) return findMedian(arr2, arr1);\n        int start = 0, end = n1;\n        while(start <= end) {\n            int mid1 = start + (end - start)/2;\n            int mid2 = (n1+n2+1)/2 - mid1;\n            int x1 = mid1 == 0 ? Integer.MIN_VALUE : arr1[mid1 - 1];\n            int x2 = mid2 == 0 ? Integer.MIN_VALUE : arr2[mid2 - 1];\n            int y1 = mid1 == n1 ? Integer.MAX_VALUE : arr1[mid1];\n            int y2 = mid2 == n2 ? Integer.MAX_VALUE : arr2[mid2];\n            if (x1 <= y2 && x2 <= y1) {\n                if ((n1+n2)%2 == 0) {\n                    return (Math.max(x1, x2) + Math.min(y1, y2)) / 2.0;\n                }\n                return Math.max(x1, x2);\n            }\n            if (x1 > y2) {\n                end = mid1 - 1;\n            } else {\n                start = mid1 + 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] arr1 = { -5, 3, 6, 12, 15 };\n        int[] arr2 = { -12, -10, -6, -3, 4, 10 };\n        System.out.println(findMedian(arr1, arr2));\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "kt": {
          "language": "kt",
          "code": "class Solution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        val n1 = nums1.size\n        val n2 = nums2.size\n\n        if (n1 > n2) {\n            return findMedianSortedArrays(nums2, nums1)\n        }\n\n        var start = 0\n        var end = n1\n\n        while (start <= end) {\n            val mid1 = start + (end - start) / 2\n            val mid2 = (n1 + n2 + 1) / 2 - mid1\n\n            val left1 = if (mid1 == 0) Int.MIN_VALUE else nums1[mid1 - 1]\n            val left2 = if (mid2 == 0) Int.MIN_VALUE else nums2[mid2 - 1]\n\n            val right1 = if (mid1 == n1) Int.MAX_VALUE else nums1[mid1]\n            val right2 = if (mid2 == n2) Int.MAX_VALUE else nums2[mid2]\n\n            if (left1 <= right2 && left2 <= right1) {\n                if ((n1 + n2) % 2 == 0) {\n                    return (maxOf(left1, left2).toDouble() + minOf(right1, right2).toDouble()) / 2.0\n                } else {\n                    return maxOf(left1, left2).toDouble()\n                }\n            }\n            if (left1 > right2) {\n                end = mid1 - 1\n            } else {\n                start = mid1 + 1\n            }\n        }\n        return -1.0 // Return a Double consistent with the function's return type\n    }\n}",
          "subPath": "",
          "fileName": "solution.kt"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        n1, n2 = len(nums1), len(nums2)\n        if n1 > n2:\n            return self.findMedianSortedArrays(nums2, nums1)\n        start, end = 0, n1\n        while start <= end:\n            m1 = start + (end-start)//2\n            m2 = (n1+n2+1)//2 - m1\n            x1 = float('-inf') if m1 == 0 else nums1[m1-1]\n            x2 = float('-inf') if m2 == 0 else nums2[m2-1]\n            y1 = float('inf') if m1 == n1 else nums1[m1]\n            y2 = float('inf') if m2 == n2 else nums2[m2]\n            if x1 <= y2 and x2 <= y1:\n                if (n1+n2)%2 == 0:\n                    return (max(x1, x2) + min(y1, y2))/2\n                return max(x1, x2)\n            elif x1 > y2:\n                end = m1 - 1\n            else:\n                start = m1 + 1\n        return -1",
          "subPath": "",
          "fileName": "solution.py"
        },
        "ts": {
          "language": "ts",
          "code": "function findMedianSortedArrays(nums1: number[], nums2: number[]): number {\n    const l1 = nums1.length, l2 = nums2.length;\n    if (l1 > l2) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n\n    let left = 0, right = l1;\n    while (left <= right) {\n        const mid1 = Math.floor((left + right) / 2);\n        const mid2 = Math.floor((l1 + l2 + 1) / 2) - mid1;\n\n        const x1 = mid1 === 0 ? -Infinity : nums1[mid1 - 1];\n        const x2 = mid2 === 0 ? -Infinity : nums2[mid2 - 1];\n        const y1 = mid1 === l1 ? Infinity : nums1[mid1];\n        const y2 = mid2 === l2 ? Infinity : nums2[mid2];\n\n        if (x1 <= y2 && x2 <= y1) {\n            if ((l1 + l2) % 2 === 0) {\n                return (Math.max(x1, x2) + Math.min(y1, y2)) / 2.0;\n            } else {\n                return Math.max(x1, x2);\n            }\n        }\n\n        if (x1 > y2) {\n            right = mid1 - 1;\n        } else {\n            left = mid1 + 1;\n        }\n    }\n\n    return -1;\n}",
          "subPath": "",
          "fileName": "solution.ts"
        }
      }
    },
    "meeting-rooms-ii": {
      "id": "meeting-rooms-ii",
      "title": "Meeting Rooms II",
      "difficulty": "medium",
      "companies": [
        "facebook",
        "amazon",
        "apple",
        "microsoft"
      ],
      "topics": [
        "array",
        "greedy",
        "sorting"
      ],
      "langs": [
        "java",
        "py",
        "cpp",
        "go",
        "ts"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "meeting-rooms-ii",
      "gfg": "attend-all-meetings-ii",
      "leetid": 253,
      "content": "---\nlayout: post\ntitle: Meeting Rooms II\ntopics: [array, greedy, sorting]\nlangs: [java, py, cpp, go, ts]\ntc: O(n)\nsc: O(n)\nleetid: 253\ndifficulty: medium\ncompanies: [facebook, amazon, apple, microsoft]\ngfg: attend-all-meetings-ii\nhackerrank: \ninterviewbit: meeting-rooms\nleetcode: meeting-rooms-ii\n---\n\nGiven an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.\nA conference room is available if it is not occupied by any meeting at the time of the new meeting.\n\n---\n## How it works\n1. **Initialize a Large Array:** `delta = [0] * 1000010` creates an array (or list in Python terms) of size 1,000,010, initialized with zeros. \nThis array acts as a map, where the index represents a time point and the value at each index represents the net change in the number of ongoing meetings at that time.\n2. **Populate the delta Array:** For each meeting defined by its `start` and `end` times, the code increments the value at the start index by 1 and decrements the value at the end index by 1 in the delta array.\nThis increment and decrement operation effectively marks the beginning and end of a meeting, respectively. The positive value at the start time indicates new meetings starting, and the negative value at the end time indicates meetings ending.\n3. **Accumulate Changes:** The expression accumulate(delta) computes the cumulative sum of the delta array. This step calculates the net number of meetings ongoing at each time point, based on the previously marked start and end times.\nAfter accumulation, each value in the delta array represents the total number of meetings ongoing at the corresponding time point.\n4. **Find the Maximum Value:** The maximum value in the accumulated delta array represents the peak number of simultaneous meetings. \nThis peak value is the minimum number of conference rooms needed to accommodate all meetings without any overlap.\n\n---\n## Test Cases\n**Example 1:** \n```\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2\nExplanation:\n- Room 1 is occupied from 0 to 30.\n- Room 2 is occupied from 5 to 10.\n- Room 2 is occupied from 15 to 20.\n```\n\n**Example 2:** \n```\nInput: intervals = [[7,10],[2,4]]\nOutput: 1\nExplanation:\n- Room 1 is occupied from 2 to 4.\n- Room 1 is occupied from 7 to 10.\n```\n",
      "body": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.\nA conference room is available if it is not occupied by any meeting at the time of the new meeting.\n\n---\n## How it works\n1. **Initialize a Large Array:** `delta = [0] * 1000010` creates an array (or list in Python terms) of size 1,000,010, initialized with zeros. \nThis array acts as a map, where the index represents a time point and the value at each index represents the net change in the number of ongoing meetings at that time.\n2. **Populate the delta Array:** For each meeting defined by its `start` and `end` times, the code increments the value at the start index by 1 and decrements the value at the end index by 1 in the delta array.\nThis increment and decrement operation effectively marks the beginning and end of a meeting, respectively. The positive value at the start time indicates new meetings starting, and the negative value at the end time indicates meetings ending.\n3. **Accumulate Changes:** The expression accumulate(delta) computes the cumulative sum of the delta array. This step calculates the net number of meetings ongoing at each time point, based on the previously marked start and end times.\nAfter accumulation, each value in the delta array represents the total number of meetings ongoing at the corresponding time point.\n4. **Find the Maximum Value:** The maximum value in the accumulated delta array represents the peak number of simultaneous meetings. \nThis peak value is the minimum number of conference rooms needed to accommodate all meetings without any overlap.\n\n---\n## Test Cases\n**Example 1:** \n```\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2\nExplanation:\n- Room 1 is occupied from 0 to 30.\n- Room 2 is occupied from 5 to 10.\n- Room 2 is occupied from 15 to 20.\n```\n\n**Example 2:** \n```\nInput: intervals = [[7,10],[2,4]]\nOutput: 1\nExplanation:\n- Room 1 is occupied from 2 to 4.\n- Room 1 is occupied from 7 to 10.\n```\n",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int minMeetingRooms(vector<vector<int>>& intervals) {\n        int n = 1000010;\n        vector<int> delta(n);\n        for (auto e : intervals) {\n            ++delta[e[0]];\n            --delta[e[1]];\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            delta[i + 1] += delta[i];\n        }\n        return *max_element(delta.begin(), delta.end());\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "func minMeetingRooms(intervals [][]int) int {\n\tn := 1000010\n\tdelta := make([]int, n)\n\tfor _, e := range intervals {\n\t\tdelta[e[0]]++\n\t\tdelta[e[1]]--\n\t}\n\tfor i := 1; i < n; i++ {\n\t\tdelta[i] += delta[i-1]\n\t}\n\treturn slices.Max(delta)\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        int n = 1000010;\n        int[] delta = new int[n];\n        for (int[] e : intervals) {\n            ++delta[e[0]];\n            --delta[e[1]];\n        }\n        int res = delta[0];\n        for (int i = 1; i < n; ++i) {\n            delta[i] += delta[i - 1];\n            res = Math.max(res, delta[i]);\n        }\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution(object):\n  def minMeetingRooms(self, intervals):\n    \"\"\"\n    :type intervals: List[Interval]\n    :rtype: int\n    \"\"\"\n    meetings = []\n    for i in intervals:\n      meetings.append((i.start, 1))\n      meetings.append((i.end, 0))\n    meetings.sort()\n    ans = 0\n    count = 0\n    for meeting in meetings:\n      if meeting[1] == 1:\n        count += 1\n      else:\n        count -= 1\n      ans = max(ans, count)\n    return ans",
          "subPath": "",
          "fileName": "solution.py"
        },
        "ts": {
          "language": "ts",
          "code": "function minMeetingRooms(intervals: number[][]): number {\n    const m = Math.max(...intervals.map(([_, r]) => r));\n    const d: number[] = Array(m + 1).fill(0);\n    for (const [l, r] of intervals) {\n        d[l]++;\n        d[r]--;\n    }\n    let [ans, s] = [0, 0];\n    for (const v of d) {\n        s += v;\n        ans = Math.max(ans, s);\n    }\n    return ans;\n}",
          "subPath": "",
          "fileName": "solution.ts"
        }
      }
    },
    "merge-k-sorted-lists": {
      "id": "merge-k-sorted-lists",
      "title": "Merge k Sorted Lists",
      "difficulty": "hard",
      "companies": [
        "airbnb",
        "facebook",
        "google",
        "uber",
        "linkedin"
      ],
      "topics": [
        "linked-list",
        "divide-and-conquer",
        "heap-priority-queue",
        "merge-sort"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(k)",
      "leetcode": "merge-k-sorted-lists",
      "gfg": "merge-k-sorted-linked-lists",
      "leetid": 23,
      "content": "---\nlayout: post\ntitle: Merge k Sorted Lists\ndifficulty: hard\ntopics: [linked-list, divide-and-conquer, heap-priority-queue, merge-sort]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(k)\ncompanies: [airbnb, facebook, google, uber, linkedin]\nleetid: 23\nleetcode: merge-k-sorted-lists\ngfg: merge-k-sorted-linked-lists\ninterviewbit: merge-k-sorted-lists\nhackerrank: merge-two-sorted-linked-lists\nhellointerview: code/heap/merge-k-sorted-lists\n---\nYou are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n*Merge all the linked-lists into one sorted linked-list and return it.*\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n```\n**Example 2:**\n```\nInput: lists = []\nOutput: []\n```\n**Example 3:**\n```\nInput: lists = [[]]\nOutput: []\n```\n \n**Constraints:**\n\t\n* `k == lists.length`\n\t\n* `0 <= k <= 10<sup>4</sup>`\n\t\n* `0 <= lists[i].length <= 500`\n\t\n* `-10<sup>4</sup> <= lists[i][j] <= 10<sup>4</sup>`\n\t\n* `lists[i]` is sorted in **ascending order**.\n\t\n* The sum of `lists[i].length` will not exceed `10<sup>4</sup>`.\n\n",
      "body": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n*Merge all the linked-lists into one sorted linked-list and return it.*\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n```\n**Example 2:**\n```\nInput: lists = []\nOutput: []\n```\n**Example 3:**\n```\nInput: lists = [[]]\nOutput: []\n```\n \n**Constraints:**\n\t\n* `k == lists.length`\n\t\n* `0 <= k <= 10<sup>4</sup>`\n\t\n* `0 <= lists[i].length <= 500`\n\t\n* `-10<sup>4</sup> <= lists[i][j] <= 10<sup>4</sup>`\n\t\n* `lists[i]` is sorted in **ascending order**.\n\t\n* The sum of `lists[i].length` will not exceed `10<sup>4</sup>`.\n\n",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\n    struct compare {\n        bool operator()(const ListNode* l, const ListNode* r) {\n            return l->val > r->val;\n        }\n    };\n\npublic:\n    ListNode *mergeKLists(vector<ListNode *> &lists) {\n        priority_queue<ListNode *, vector<ListNode *>, compare> q;\n        for (auto l : lists) {\n            if (l) {\n                q.push(l);\n            }\n        }\n\n        if (q.empty()) {\n            return NULL;\n        }\n\n        ListNode* result = q.top();\n        q.pop();\n        if (result->next) {\n            q.push(result->next);\n        }\n\n        ListNode* tail = result;\n        while (!q.empty()) {\n            tail->next = q.top();\n            q.pop();\n            tail = tail->next;\n            if (tail->next) {\n                q.push(tail->next);\n            }\n        }\n\n        return result;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists.length == 0) return null;\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n        for(int i=0; i<lists.length; i++) {\n            if (lists[i] != null) pq.offer(lists[i]);\n        }\n        ListNode head = new ListNode();\n        ListNode temp = head;\n        while(!pq.isEmpty()) {\n            ListNode top = pq.poll();\n            if (top.next != null) pq.offer(top.next);\n            top.next = null;\n            temp.next = top;\n            temp = temp.next;\n        }\n        return head.next;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "min-cost-to-connect-all-points": {
      "id": "min-cost-to-connect-all-points",
      "title": "Min Cost to Connect All Points",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "graph"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(1)",
      "sc": "O(1)",
      "leetcode": "min-cost-to-connect-all-points",
      "gfg": null,
      "leetid": 1584,
      "content": "---\nlayout: post\ntitle: Min Cost to Connect All Points\ntopics: [array, graph]\nlangs: [java]\ntc: O(1)\nsc: O(1)\nleetid: 1584\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: min-cost-to-connect-all-points\n---\n\nYou are given an array points representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the manhattan distance between them: \n```|xi - xj| + |yi - yj|```\nwhere `|val|` denotes the absolute value of `val`.\n\nReturn the minimum cost to make all points connected. All points are connected if there is **exactly one** simple path between any two points.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<div style={{backgroundColor: 'white', width: 'auto'}}>\n    <img src=\"/assets/img/code/min-cost.png\" alt=\"\" />\n    <img src=\"/assets/img/code/min-cost2.png\" alt=\"\" />\n</div>\n\n```\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation: \n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n```\n\n**Example 2:** \n```\nInput: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18\n```",
      "body": "You are given an array points representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the manhattan distance between them: \n```|xi - xj| + |yi - yj|```\nwhere `|val|` denotes the absolute value of `val`.\n\nReturn the minimum cost to make all points connected. All points are connected if there is **exactly one** simple path between any two points.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<div style={{backgroundColor: 'white', width: 'auto'}}>\n    <img src=\"/assets/img/code/min-cost.png\" alt=\"\" />\n    <img src=\"/assets/img/code/min-cost2.png\" alt=\"\" />\n</div>\n\n```\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation: \n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n```\n\n**Example 2:** \n```\nInput: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class UnionFind {\n    public int[] group;\n    public int[] rank;\n\n    public UnionFind(int size) {\n        group = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; ++i) {\n            group[i] = i;\n        }\n    }\n\n    public int find(int node) {\n        if (group[node] != node) {\n            group[node] = find(group[node]);\n        }\n        return group[node];\n    }\n\n    public boolean union(int node1, int node2) {\n        int group1 = find(node1);\n        int group2 = find(node2);\n\n        // node1 and node2 already belong to same group.\n        if (group1 == group2) {\n            return false;\n        }\n\n        if (rank[group1] > rank[group2]) {\n            group[group2] = group1;\n        } else if (rank[group1] < rank[group2]) {\n            group[group1] = group2;\n        } else {\n            group[group1] = group2;\n            rank[group2] += 1;\n        }\n\n        return true;\n    }\n}\n\nclass Solution {\n    public int minCostConnectPoints(int[][] points) {\n        int n = points.length;\n        ArrayList<int[]> allEdges = new ArrayList<>();\n\n        // Storing all edges of our complete graph.\n        for (int currNext = 0; currNext < n; ++currNext) {\n            for (int nextNext = currNext + 1; nextNext < n; ++nextNext) {\n                int weight = Math.abs(points[currNext][0] - points[nextNext][0]) +\n                        Math.abs(points[currNext][1] - points[nextNext][1]);\n\n                int[] currEdge = {weight, currNext, nextNext};\n                allEdges.add(currEdge);\n            }\n        }\n\n        // Sort all edges in increasing order.\n        Collections.sort(allEdges, (a, b) -> Integer.compare(a[0], b[0]));\n\n        UnionFind uf = new UnionFind(n);\n        int mstCost = 0;\n        int edgesUsed = 0;\n\n        for (int i = 0; i < allEdges.size() && edgesUsed < n - 1; ++i) {\n            int node1 = allEdges.get(i)[1];\n            int node2 = allEdges.get(i)[2];\n            int weight = allEdges.get(i)[0];\n\n            if (uf.union(node1, node2)) {\n                mstCost += weight;\n                edgesUsed++;\n            }\n        }\n\n        return mstCost;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "minimize-deviation-in-array": {
      "id": "minimize-deviation-in-array",
      "title": "Minimize Deviation in Array",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "greedy",
        "heap"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "minimize-deviation-in-array",
      "gfg": null,
      "leetid": 1675,
      "content": "---\nlayout: post\ntitle: Minimize Deviation in Array\ntopics: [array, greedy, heap]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 1675\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: minimize-deviation-in-array\n---\n\nYou are given an array nums of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number of times:\n\n- If the element is **even, divide it by 2**. \nFor example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2]`.\n- If the element is **odd, multiply it by 2**.\nFor example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4]`.\n\nThe **deviation** of the array is the **maximum difference** between any two elements in the array.\n\nReturn the minimum deviation the array can have after performing some number of operations.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) nums = [1,2,3,4]\n```\n\n**Output:**\n```\n(int) 1\n```\n\n**Explanation:**\n```\nYou can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [4,1,5,20,3]\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nYou can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.\n```\n",
      "body": "You are given an array nums of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number of times:\n\n- If the element is **even, divide it by 2**. \nFor example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2]`.\n- If the element is **odd, multiply it by 2**.\nFor example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4]`.\n\nThe **deviation** of the array is the **maximum difference** between any two elements in the array.\n\nReturn the minimum deviation the array can have after performing some number of operations.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) nums = [1,2,3,4]\n```\n\n**Output:**\n```\n(int) 1\n```\n\n**Explanation:**\n```\nYou can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [4,1,5,20,3]\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nYou can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.\n```\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int minimumDeviation(int[] nums) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b-a);\n        int min = Integer.MAX_VALUE, res = Integer.MAX_VALUE;\n        for(int a: nums) {\n            if (a%2 == 1) a*=2;\n            pq.offer(a);\n            min = Math.min(min, a);\n        }\n        while(true) {\n            int max = pq.poll();\n            res = Math.min(res, max - min);\n            if (max%2 == 1) break;\n            pq.offer(max/2);\n            min = Math.min(min, max/2);\n        }\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "minimum-cost-for-tickets": {
      "id": "minimum-cost-for-tickets",
      "title": "Minimum Cost for Tickets",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(N)",
      "sc": "O(N)",
      "leetcode": "minimum-cost-for-tickets",
      "gfg": null,
      "leetid": 983,
      "content": "---\nlayout: post\ntitle: Minimum Cost for Tickets\ntopics: [array, dynamic-programming]\nlangs: [java]\ntc: O(N)\nsc: O(N)\nleetid: 983\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: minimum-cost-for-tickets\n---\n\nYou have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from `1` to `365`.\n\nTrain tickets are sold in three different ways:\n\na **1-day** pass is sold for `costs[0]` dollars,\na **7-day** pass is sold for `costs[1]` dollars, and\na **30-day** pass is sold for `costs[2]` dollars.\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day `2`, then we can travel for 7 days: `2, 3, 4, 5, 6, 7, and 8`.\nReturn the _minimum number of dollars you need to travel every day in the given list of days._\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n```\n\n**Example 2:** \n```\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n```",
      "body": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from `1` to `365`.\n\nTrain tickets are sold in three different ways:\n\na **1-day** pass is sold for `costs[0]` dollars,\na **7-day** pass is sold for `costs[1]` dollars, and\na **30-day** pass is sold for `costs[2]` dollars.\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day `2`, then we can travel for 7 days: `2, 3, 4, 5, 6, 7, and 8`.\nReturn the _minimum number of dollars you need to travel every day in the given list of days._\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n```\n\n**Example 2:** \n```\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    int[] days, costs, durations, memo;\n    public int mincostTickets(int[] days, int[] costs) {\n        this.days = days;\n        this.costs = costs;\n        this.durations = new int[]{1, 7, 30};\n        this.memo = new int[days.length];\n        Arrays.fill(memo, -1);\n        return dp(0);\n    }\n\n    private int dp(int i) {\n        if (i >= days.length) {\n            return 0;\n        }\n        if (memo[i] != -1) {\n            return memo[i];\n        }\n        int ans = Integer.MAX_VALUE;\n        int j = i;\n        for(int k=0; k<3; k++) {\n            while(j < days.length && days[j] < days[i] + durations[k]) {\n                j++;\n            }\n            ans = Math.min(ans, dp(j) + costs[k]);\n        }\n        memo[i] = ans;\n        return ans;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "minimum-remove-to-make-valid-parentheses": {
      "id": "minimum-remove-to-make-valid-parentheses",
      "title": "Minimum Remove to Make Valid Parentheses",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "stack",
        "string"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "minimum-remove-to-make-valid-parentheses",
      "gfg": null,
      "leetid": 1249,
      "content": "---\nlayout: post\ntitle: Minimum Remove to Make Valid Parentheses\ntopics: [stack, string]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(n)\nleetid: 1249\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: minimum-remove-to-make-valid-parentheses\n---\n\nGiven a string s of `'('` , `')'` and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) \nso that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n- It is the empty string, contains only lowercase characters, or\n- It can be written as `AB` (A concatenated with B), where A and B are valid strings, or\n- It can be written as `(A)`, where A is a valid string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n```\n\n**Example 2:** \n```\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.\n```",
      "body": "Given a string s of `'('` , `')'` and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) \nso that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n- It is the empty string, contains only lowercase characters, or\n- It can be written as `AB` (A concatenated with B), where A and B are valid strings, or\n- It can be written as `(A)`, where A is a valid string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n```\n\n**Example 2:** \n```\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    string minRemoveToMakeValid(string s) {\n        stack<int> st;\n        int n = s.length();\n        for(int i=0; i<n; i++) {\n            if (s[i] == '(') {\n                st.push(i);\n            } else if (s[i] == ')') {\n                if (!st.empty()) {\n                    st.pop();\n                } else {\n                    s[i] = '*';\n                }\n            }\n        }\n        while(!st.empty()) {\n            s[st.top()] = '*';\n            st.pop();\n        }\n        s.erase(remove(s.begin(), s.end(), '*'), s.end());\n        return s;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String minRemoveToMakeValid(String s) {\n        StringBuilder builder = new StringBuilder(s);\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for(int i=0; i<s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                stack.offerLast(i);\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    stack.pollLast();\n                } else {\n                    builder.setCharAt(i, '*');\n                }\n            }\n        }\n\n        while(!stack.isEmpty()) {\n            builder.setCharAt(stack.pollLast(), '*');\n        }\n\n        return builder.toString().replace(\"*\", \"\");\n    }\n}\n\n/*\n* Alternate approach without using stack\nclass Solution {\n    public String minRemoveToMakeValid(String s) {\n        StringBuilder sb = new StringBuilder(s);\n        int open = 0;\n        for(int i=0; i<s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                open++;\n            } else if (c == ')') {\n                if (open > 0) {\n                    open--;\n                } else {\n                    sb.setCharAt(i, '*');\n                }\n            }\n        }\n\n        int i = s.length() - 1;\n        while(i >=0 && open > 0) {\n            if (s.charAt(i) == '(') {\n                sb.setCharAt(i, '*');\n                open--;\n            }\n            i--;\n        }\n\n        return sb.toString().replace(\"*\", \"\");\n    }\n}\n*\n* */",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        stack = []\n        arr = list(s)\n        print(arr)\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if not stack:\n                    arr[i] = '*'\n                else:\n                    stack.pop()\n        while stack:\n            arr[stack.pop()] = '*'\n        return ''.join(arr).replace('*', '')",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "minimum-size-subarray-sum": {
      "id": "minimum-size-subarray-sum",
      "title": "Minimum Size Subarray Sum",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "binary-search",
        "sliding-window",
        "prefix-sum"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "minimum-size-subarray-sum",
      "gfg": null,
      "leetid": 209,
      "content": "---\nlayout: post\ntitle: Minimum Size Subarray Sum\ndifficulty: medium\ntopics: [array, binary-search, sliding-window, prefix-sum]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\ncompanies: [facebook]\nleetid: 209\nleetcode: minimum-size-subarray-sum\ngfg: \ninterviewbit: \nhackerrank: \n---\nGiven an array of positive integers `nums` and a positive integer `target`, return *the **minimal length** of a *<span data-keyword=\"subarray-nonempty\">*subarray*</span>* whose sum is greater than or equal to* `target`. If there is no such subarray, return `0` instead.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n```\n\n**Example 2:**\n```\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n```\n \n**Constraints:**\n* `1 <= target <= 10<sup>9</sup>`\n* `1 <= nums.length <= 10<sup>5</sup>`\n* `1 <= nums[i] <= 10<sup>4</sup>`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`.\n",
      "body": "Given an array of positive integers `nums` and a positive integer `target`, return *the **minimal length** of a *<span data-keyword=\"subarray-nonempty\">*subarray*</span>* whose sum is greater than or equal to* `target`. If there is no such subarray, return `0` instead.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n```\n\n**Example 2:**\n```\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n```\n \n**Constraints:**\n* `1 <= target <= 10<sup>9</sup>`\n* `1 <= nums.length <= 10<sup>5</sup>`\n* `1 <= nums[i] <= 10<sup>4</sup>`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`.\n",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int start = 0, current = 0, end = 0, minlen = INT_MAX;\n        while(end < nums.size()) {\n            current += nums[end];\n            while(current >= target) {\n                minlen = min(minlen, end-start+1);\n                current -= nums[start++];\n            }\n            end++;\n        }\n        return minlen == INT_MAX ? 0: minlen;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int ml = Integer.MAX_VALUE;\n        int start = 0, end = 0, curr = 0;\n        while(end < nums.length) {\n            curr += nums[end];\n            while(curr >= target) {\n                ml = Math.min(ml, end-start+1);\n                curr -= nums[start++];\n            }\n            end++;\n        }\n        return ml == Integer.MAX_VALUE ? 0 : ml;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "minimum-sum-partition": {
      "id": "minimum-sum-partition",
      "title": "Minimum sum partition",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": null,
      "gfg": null,
      "content": "---\nlayout: post\ntitle: Minimum sum partition\ntopics: [array, dynamic-programming]\nlangs: [java]\ntc: O(n)\nsc: O(n)\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven an integer array arr of size N, \nthe task is to divide it into two sets `S1` and `S2` such that the absolute difference between their sums is minimum and find the minimum difference\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: N = 4, arr[] = {1, 6, 11, 5} \nOutput: 1\nExplanation: \nSubset1 = {1, 5, 6}, sum of Subset1 = 12 \nSubset2 = {11}, sum of Subset2 = 11   \n```\n\n**Example 2:** \n```\nInput: N = 2, arr[] = {1, 4}\nOutput: 3\nExplanation: \nSubset1 = {1}, sum of Subset1 = 1\nSubset2 = {4}, sum of Subset2 = 4\n```",
      "body": "Given an integer array arr of size N, \nthe task is to divide it into two sets `S1` and `S2` such that the absolute difference between their sums is minimum and find the minimum difference\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: N = 4, arr[] = {1, 6, 11, 5} \nOutput: 1\nExplanation: \nSubset1 = {1, 5, 6}, sum of Subset1 = 12 \nSubset2 = {11}, sum of Subset2 = 11   \n```\n\n**Example 2:** \n```\nInput: N = 2, arr[] = {1, 4}\nOutput: 3\nExplanation: \nSubset1 = {1}, sum of Subset1 = 1\nSubset2 = {4}, sum of Subset2 = 4\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution\n{\n    public int minDifference(int arr[], int n) {\n        if (n==0) return 0;\n        if (n==1) return arr[0];\n        if (n==2) return Math.abs(arr[1] - arr[0]);\n        int sum = 0;\n        for(int i=0; i<n; i++) {\n            sum += arr[i];\n        }\n        int W = sum/2;\n        int[][] dp = new int[n+1][W+1];\n        for(int i=1; i<= n; i++) {\n            for(int j=1; j<= W; j++) {\n                if (arr[i-1] <= j) {\n                    dp[i][j] = Math.max(dp[i-1][j], arr[i-1] + dp[i-1][j-arr[i-1]]);\n                } else {\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        return Math.abs(sum - 2*dp[n][W]);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "minimum-window-substring": {
      "id": "minimum-window-substring",
      "title": "Minimum Window Substring",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "hash-table",
        "sliding-window",
        "string"
      ],
      "langs": [
        "java",
        "cpp",
        "py",
        "c",
        "kt"
      ],
      "tc": "O(n+m)",
      "sc": "O(n+m)",
      "leetcode": "minimum-window-substring",
      "gfg": "find-the-smallest-window-in-a-string-containing-all-characters-of-another-string",
      "leetid": 76,
      "content": "---\nlayout: post\ntitle: Minimum Window Substring\ncategory: hard\ntopics: [hash-table, sliding-window, string]\nlangs: [java, cpp, py, c, kt]\ntc: O(n+m)\nsc: O(n+m)\nleetid: 76\ngfg: find-the-smallest-window-in-a-string-containing-all-characters-of-another-string\ncompanies: [facebook]\ndifficulty: hard\nhackerrank: \ninterviewbit: \nleetcode: minimum-window-substring\n---\n\nGiven two strings `s` and `t` of lengths `m` and `n` respectively, \nreturn the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. \nIf there is no such substring, return the empty string `\"\"`.\n\n**A substring is a contiguous sequence of characters within the string**.\n\n---\n## How to Solve\n\nThe question asks us to return the minimum window from the string `S` which has all the characters of the string `T`. \nLet us call a window desirable if it has all the characters from `T`.\n\nWe can use a simple sliding window approach to solve this problem.\nIn any sliding window based problem we have two pointers. One `right` pointer whose job is to expand the current window, \nand then we have the `left` pointer whose job is to contract a given window. \nAt any point in time only one of these pointers move and the other one remains fixed.\n\nThe solution is pretty intuitive. We keep expanding the window by moving the right pointer. \nWhen the window has all the desired characters, we contract (if possible) and save the smallest window till now.\n\nThe answer is the smallest desirable window.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n```\n\n**Example 2:**\n```\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n```\n\n**Example 3:**\n```\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n```",
      "body": "Given two strings `s` and `t` of lengths `m` and `n` respectively, \nreturn the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. \nIf there is no such substring, return the empty string `\"\"`.\n\n**A substring is a contiguous sequence of characters within the string**.\n\n---\n## How to Solve\n\nThe question asks us to return the minimum window from the string `S` which has all the characters of the string `T`. \nLet us call a window desirable if it has all the characters from `T`.\n\nWe can use a simple sliding window approach to solve this problem.\nIn any sliding window based problem we have two pointers. One `right` pointer whose job is to expand the current window, \nand then we have the `left` pointer whose job is to contract a given window. \nAt any point in time only one of these pointers move and the other one remains fixed.\n\nThe solution is pretty intuitive. We keep expanding the window by moving the right pointer. \nWhen the window has all the desired characters, we contract (if possible) and save the smallest window till now.\n\nThe answer is the smallest desirable window.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n```\n\n**Example 2:**\n```\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n```\n\n**Example 3:**\n```\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "char* minWindow(char* s, char* t) {\n    int i    = 0;\n    int j    = 0;\n    int tlen = strlen(t);\n    int slen = strlen(s);\n    int counts[256] = { 0 };\n    int win[2] = { 0, INT_MAX };\n\n    for (int i = 0; i < tlen; i++) {\n        counts[t[i]]++;\n    }\n    while (j < slen) {\n        if (counts[s[j]] > 0) {\n            tlen--;\n        }\n        counts[s[j]]--;\n        j++;\n        while (tlen == 0) {\n            if (j - i < win[1] - win[0]) {\n                win[0] = i; win[1] = j;\n            }\n            counts[s[i]]++;\n            if (counts[s[i]] > 0) {\n                tlen++;\n            }\n            i++;\n        }\n    }\n    return (win[1] != INT_MAX) \n           ? strndup(&s[win[0]], win[1] - win[0]) \n           : \"\";\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        int tmap[256] = {0}, smap[256] = {0};\n        int requiredChars = 0, foundChars = 0;\n        int left = 0, right = 0, minlength = -1, start = 0, end=0;\n        char c;\n        for(int i=0; i<t.length(); i++) {\n            char c = t[i];\n            if (tmap[c] == 0) requiredChars++;\n            tmap[c]++;\n        }\n        while(right < s.length()) {\n            c = s[right];\n            smap[c]++;\n            if (tmap[c] > 0 && tmap[c] == smap[c]) {\n                foundChars++;\n            }\n            while(left <= right && foundChars == requiredChars) {\n                c = s[left];\n                if (minlength == -1 || minlength > right - left + 1) {\n                    minlength = right - left + 1;\n                    start = left;\n                    end = right;\n                }\n                smap[c]--;\n                if (tmap[c] > 0 && tmap[c] > smap[c]) {\n                    foundChars--;\n                }\n                left++;\n            }\n\n            right++;\n        }\n        return minlength == -1 ? \"\" : s.substr(start, minlength);\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String minWindow(String s, String t) {\n        int[] smap = new int[256];\n        int[] tmap = new int[256];\n        int requiredChars = 0;\n        char c;\n        for(int i=0; i<t.length(); i++) {\n            c = t.charAt(i);\n            if (tmap[c] == 0) requiredChars++;\n            tmap[c]++;\n        }\n        int left = 0, right = 0;\n        int foundChars = 0;\n        int start = 0, end = 0, minlength = -1;\n        while(right < s.length()) {\n            c = s.charAt(right);\n            smap[c]++;\n            if (tmap[c] > 0 && tmap[c] == smap[c]) {\n                foundChars++;\n            }\n            while(left <= right && foundChars == requiredChars) {\n                c = s.charAt(left);\n                if (minlength == -1 || minlength > right - left + 1) {\n                    minlength = right - left + 1;\n                    start = left;\n                    end = right;\n                }\n                smap[c]--;\n                if (tmap[c] > 0 && tmap[c] > smap[c]) {\n                    foundChars--;\n                }\n                left++;\n            }\n\n            right++;\n        }\n\n        return minlength == -1 ? \"\" : s.substring(start, end+1);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "kt": {
          "language": "kt",
          "code": "class Solution {\n    fun minWindow(s: String, t: String): String {\n        if (s.length < t.length) return \"\"\n\n        val tmap = IntArray(128)\n        val smap = IntArray(128)\n\n        for (c in t) {\n            tmap[c.code]++\n        }\n\n        var left = 0\n        var right = 0\n        var minLen = Int.MAX_VALUE\n        var minStart = 0\n        var formed = 0\n        val required = t.count { it.isLetterOrDigit() || it.isWhitespace() || true }.let {\n            tmap.count { it > 0 }\n        }\n\n        while (right < s.length) {\n            val rc = s[right].code\n            smap[rc]++\n            if (tmap[rc] > 0 && smap[rc] == tmap[rc]) {\n                formed++\n            }\n\n            while (formed == required) {\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1\n                    minStart = left\n                }\n\n                val lc = s[left].code\n                smap[lc]--\n                if (tmap[lc] > 0 && smap[lc] < tmap[lc]) {\n                    formed--\n                }\n                left++\n            }\n\n            right++\n        }\n\n        return if (minLen == Int.MAX_VALUE) \"\" else s.substring(minStart, minStart + minLen)\n    }\n}",
          "subPath": "",
          "fileName": "solution.kt"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        tmap, smap = [0]*256, [0]*256\n        requiredChars, foundChars = 0, 0\n        left, right, minlength, start, end = 0, 0, -1, 0, 0\n        for c in t:\n            if tmap[ord(c)] == 0:\n                requiredChars += 1\n            tmap[ord(c)]+=1\n        while right < len(s):\n            c = ord(s[right])\n            smap[c]+=1\n            if tmap[c] > 0 and tmap[c] == smap[c]:\n                foundChars += 1\n            while left <= right and foundChars == requiredChars:\n                c = ord(s[left])\n                if minlength == -1 or minlength > right - left + 1:\n                    minlength, start, end = right-left+1, left, right\n                smap[c]-=1\n                if tmap[c] > 0 and tmap[c] > smap[c]:\n                    foundChars-=1\n                left += 1\n            right += 1\n        return \"\" if minlength == -1 else s[start:end+1]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "multiply-strings": {
      "id": "multiply-strings",
      "title": "Multiply Strings",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "math",
        "string",
        "simulation"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(nm)",
      "sc": "O(nm)",
      "leetcode": "multiply-strings",
      "gfg": "multiply-large-numbers-represented-as-strings",
      "leetid": 43,
      "content": "---\nlayout: post\ntitle: Multiply Strings\ntopics: [math, string, simulation]\nlangs: [java, py, cpp]\ntc: O(nm)\nsc: O(nm)\nleetid: 43\ncompanies: [facebook]\ngfg: multiply-large-numbers-represented-as-strings\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: multiply-strings\n---\nGiven two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n```\n\n**Example 2:**\n```\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n```\n \n**Constraints:**\n\t\n* `1 <= num1.length, num2.length <= 200`\n\t\n* `num1` and `num2` consist of digits only.\n\t\n* Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.\n\n        ",
      "body": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n```\n\n**Example 2:**\n```\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n```\n \n**Constraints:**\n\t\n* `1 <= num1.length, num2.length <= 200`\n\t\n* `num1` and `num2` consist of digits only.\n\t\n* Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.\n\n        ",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\n        int n1 = num1.size(), n2 = num2.size();\n        vector<int> result(n1+n2, 0);\n        for(int i=n1-1; i>=0; i--) {\n            for(int j=n2-1; j>=0; j--) {\n                int mult = (num1[i] - '0')*(num2[j] - '0');\n                int sum = mult + result[i + j + 1];\n                result[i + j + 1] = sum % 10;\n                result[i + j] += sum / 10;\n            }\n        }\n\n        int i = 0;\n        while(i < result.size() && result[i] == 0) {\n            i++;\n        }\n\n        string res = \"\";\n        while(i < result.size()) {\n            res.push_back(result[i++] + '0');\n        }\n        return res;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String multiply(String num1, String num2) {\n        int m = num1.length(), n = num2.length();\n        int[] pos = new int[m + n];\n\n        for(int i = m - 1; i >= 0; i--) {\n            for(int j = n - 1; j >= 0; j--) {\n                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n                int p1 = i + j, p2 = i + j + 1;\n                int sum = mul + pos[p2];\n\n                pos[p1] += sum / 10;\n                pos[p2] = (sum) % 10;\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);\n        return sb.length() == 0 ? \"0\" : sb.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        n, m = len(num1), len(num2)\n        result = [0] * (n + m)\n\n        for i in range(n - 1, -1, -1):\n            for j in range(m - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                sum_ = mul + result[i + j + 1]\n                result[i + j + 1] = sum_ % 10\n                result[i + j] += sum_ // 10\n\n        product = ''.join(map(str, result)).lstrip('0')\n        return product if product else \"0\"",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "next-permutation": {
      "id": "next-permutation",
      "title": "Next Permutation",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "two-pointers"
      ],
      "langs": [
        "java",
        "py",
        "go",
        "cpp",
        "c"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "next-permutation",
      "gfg": null,
      "leetid": 31,
      "content": "---\nlayout: post\ntitle: Next Permutation\ntopics: [array, two-pointers]\nlangs: [java, py, go, cpp, c]\ntc: O(n)\nsc: O(1)\nleetid: 31\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: next-permutation\n---\n\nA permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n- For example, for `arr = [1,2,3]`, the following are considered permutations of `arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]`.\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. \nMore formally, if all the permutations of the array are sorted in one container according to their lexicographical order, \nthen the next permutation of that array is the permutation that follows it in the sorted container.\nIf such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n- For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n- Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n- While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n---\n\n## How to Solve\n\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\nFor example, no next permutation is possible for the array: `[9, 5, 4, 3, 1]`.\n\nWe need to find the first pair of two successive numbers `a[i]` and `a[i1]`, \nfrom the right, which satisfy `a[i] > a[i-1]`.\n\nNow, no rearrangements to the right of `a[i-1]` can create a larger permutation since that subarray consists of numbers in descending order.\nThus, we need to rearrange the numbers to the right of `a[i1]` including itself.\n\nNow, what kind of rearrangement will produce the next larger number?\n\nWe want to create the permutation just larger than the current one.\nTherefore, we need to replace the number `a[i-1]` with the number which is just larger than itself among the numbers lying to its right section, say `a[j]`.\n\n<MdxImage src=\"code/nextpermutation.png\" alt=\"Next Permutation\" />\n\nWe swap the numbers `a[i-1]` and `a[j]`. We now have the correct number at index `i-1`.\nBut still the current permutation isn't the permutation that we are looking for.\nWe need the smallest permutation that can be formed by using the numbers only to the right of `a[i-1]`.\nTherefore, we need to place those numbers in ascending order to get their smallest permutation.\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair `a[i]` and `a[i-1]` where, `a[i] > a[i-1]`.\nThus, all numbers to the right of `a[i1]` were already sorted in descending order.\nFurthermore, swapping `a[i-1]` and `a[j]` didn't change that order.\nTherefore, we simply need to reverse the numbers following `a[i-1]` to get the next smallest lexicographic permutation.\n\n---\n## Test Cases\n\n**Input:**\n\n      (int[]) nums = [1,2,3]\n\n**Output:**\n\n      (int[]) [1,3,2]\n\n---\n\n**Input:**\n\n      (int[]) nums = [3,2,1]\n\n**Output:**\n\n      (int[]) [1,2,3]\n\n---",
      "body": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n- For example, for `arr = [1,2,3]`, the following are considered permutations of `arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]`.\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. \nMore formally, if all the permutations of the array are sorted in one container according to their lexicographical order, \nthen the next permutation of that array is the permutation that follows it in the sorted container.\nIf such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n- For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n- Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n- While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n---\n\n## How to Solve\n\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\nFor example, no next permutation is possible for the array: `[9, 5, 4, 3, 1]`.\n\nWe need to find the first pair of two successive numbers `a[i]` and `a[i1]`, \nfrom the right, which satisfy `a[i] > a[i-1]`.\n\nNow, no rearrangements to the right of `a[i-1]` can create a larger permutation since that subarray consists of numbers in descending order.\nThus, we need to rearrange the numbers to the right of `a[i1]` including itself.\n\nNow, what kind of rearrangement will produce the next larger number?\n\nWe want to create the permutation just larger than the current one.\nTherefore, we need to replace the number `a[i-1]` with the number which is just larger than itself among the numbers lying to its right section, say `a[j]`.\n\n<MdxImage src=\"code/nextpermutation.png\" alt=\"Next Permutation\" />\n\nWe swap the numbers `a[i-1]` and `a[j]`. We now have the correct number at index `i-1`.\nBut still the current permutation isn't the permutation that we are looking for.\nWe need the smallest permutation that can be formed by using the numbers only to the right of `a[i-1]`.\nTherefore, we need to place those numbers in ascending order to get their smallest permutation.\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair `a[i]` and `a[i-1]` where, `a[i] > a[i-1]`.\nThus, all numbers to the right of `a[i1]` were already sorted in descending order.\nFurthermore, swapping `a[i-1]` and `a[j]` didn't change that order.\nTherefore, we simply need to reverse the numbers following `a[i-1]` to get the next smallest lexicographic permutation.\n\n---\n## Test Cases\n\n**Input:**\n\n      (int[]) nums = [1,2,3]\n\n**Output:**\n\n      (int[]) [1,3,2]\n\n---\n\n**Input:**\n\n      (int[]) nums = [3,2,1]\n\n**Output:**\n\n      (int[]) [1,2,3]\n\n---",
      "solutions": {
        "c": {
          "language": "c",
          "code": "void nextPermutation(int* nums, int numsSize){\n    int i = numsSize - 2;\n    while(i>=0 && nums[i] >= nums[i+1]) {\n        i--;\n    }\n    if (i >= 0) {\n        int j = numsSize - 1;\n        while(nums[j] <= nums[i]) {\n            j--;\n        }\n        swap(nums, i, j);\n    }\n    reverse(nums, numsSize, i+1);\n}\n\nvoid swap(int* nums, int i, int j) {\n    int temp = nums[i];\n    nums[i] = nums[j];\n    nums[j] = temp;\n}\n\nvoid reverse(int* nums, int numsSize, int start) {\n        int i = start, j = numsSize - 1;\n        while(i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        int n = nums.size();\n        int i = n - 2;\n        while(i >= 0 && nums[i] >= nums[i+1]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = n - 1;\n            while(nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i+1);\n    }\n\n    void swap(vector<int>& nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    void reverse(vector<int>& nums, int start) {\n        int i = start, j = nums.size() - 1;\n        while(i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "package next_permutation\n\nfunc nextPermutation(nums []int)  {\n\ti := len(nums) - 2\n\tfor i>=0 && nums[i+1] <= nums[i] {\n\t\ti--\n\t}\n\tif i>=0 {\n\t\tj := len(nums) - 1\n\t\tfor nums[j] <= nums[i] {\n\t\t\tj--\n\t\t}\n\t\tswap(nums, i, j)\n\t}\n\treverse(nums, i+1)\n}\n\nfunc swap(nums [] int, x int, y int) {\n\ttemp := nums[x]\n\tnums[x] = nums[y]\n\tnums[y] = temp\n}\n\nfunc reverse(nums []int, start int) {\n\tleft, right := start, len(nums) - 1\n\tfor left < right {\n\t\tswap(nums, left, right)\n\t\tleft++\n\t\tright--\n\t}\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def nextPermutation(self, arr: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(arr)\n        i, j = n - 2, 0\n        while i >= 0 and arr[i] >= arr[i + 1]:\n            i -= 1\n        j = i + 1\n        if i >= 0:\n            j = n - 1\n            while j >= 0 and arr[j] <= arr[i]:\n                j -= 1\n            arr[i], arr[j] = arr[j], arr[i]\n        start, end = i + 1, n - 1\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "number-of-islands": {
      "id": "number-of-islands",
      "title": "Number of Islands",
      "difficulty": "medium",
      "companies": [
        "google",
        "facebook"
      ],
      "topics": [
        "array",
        "depth-first-search",
        "breadth-first-search",
        "union-find",
        "matrix"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(mn)",
      "sc": "O(1)",
      "leetcode": "number-of-islands",
      "gfg": null,
      "leetid": 200,
      "content": "---\nlayout: post\ntitle: Number of Islands\ntopics: [array, depth-first-search, breadth-first-search, union-find, matrix]\nlangs: [java, py, cpp]\ntc: O(mn)\nsc: O(1)\nleetid: 200\ncompanies: [google, facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: number-of-islands\n---\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n```\n**Example 2:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n```\n \n**Constraints:**\n\t\n* `m == grid.length`\n\t\n* `n == grid[i].length`\n\t\n* `1 <= m, n <= 300`\n\t\n* `grid[i][j]` is `'0'` or `'1'`.\n\n        ",
      "body": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n```\n**Example 2:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n```\n \n**Constraints:**\n\t\n* `m == grid.length`\n\t\n* `n == grid[i].length`\n\t\n* `1 <= m, n <= 300`\n\t\n* `grid[i][j]` is `'0'` or `'1'`.\n\n        ",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int count = 0, m = grid.size(), n = grid[0].size();\n        for(int i=0; i<m; i++) {\n            for(int j=0; j<n; j++) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j, m, n);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\nprivate:\n    void dfs(vector<vector<char>> &grid, int row, int col, int rowsize, int colsize) {\n        if (row < 0 || row >= rowsize || col <0 || col >= colsize || grid[row][col] == '0') {\n            return;\n        }\n        grid[row][col] = '0';\n        dfs(grid, row-1, col, rowsize, colsize);\n        dfs(grid, row+1, col, rowsize, colsize);\n        dfs(grid, row, col-1, rowsize, colsize);\n        dfs(grid, row, col+1, rowsize, colsize);\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        int n = grid.length, m = grid[0].length;\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j, n, m);\n                }\n            }\n        }\n        return count;\n    }\n    \n    private void dfs(char[][] grid, int r, int c, int n, int m) {\n        grid[r][c] = '2';\n        if (r>0 && grid[r-1][c] == '1') dfs(grid, r-1, c, n, m);\n        if (r<n-1 && grid[r+1][c] == '1') dfs(grid, r+1, c, n, m);\n        if (c>0 && grid[r][c-1] == '1') dfs(grid, r, c-1, n, m);\n        if (c<m-1 && grid[r][c+1] == '1') dfs(grid, r, c+1, n, m);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        def graph_search(grid: List[List[str]], i: int, j: int, m: int, n: int):\n            if 0 <= i < m and 0 <= j < n and grid[i][j] == '1':\n                grid[i][j] = '0'\n                graph_search(grid, i+1, j, m, n)\n                graph_search(grid, i-1, j, m, n)\n                graph_search(grid, i, j+1, m, n)\n                graph_search(grid, i, j-1, m, n)\n        m: int = len(grid)\n        n: int = len(grid[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    count += 1\n                    graph_search(grid, i, j, m, n)\n        return count",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "palindrome-partitioning-ii": {
      "id": "palindrome-partitioning-ii",
      "title": "Palindrome Partitioning II",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "dynamic-programming",
        "string"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n<sup>2</sup>)",
      "sc": "O(n<sup>2</sup>)",
      "leetcode": "palindrome-partitioning-ii",
      "gfg": null,
      "leetid": 132,
      "content": "---\nlayout: post\ntitle: Palindrome Partitioning II\ntopics: [dynamic-programming, string]\nlangs: [java, cpp]\ntc: O(n<sup>2</sup>)\nsc: O(n<sup>2</sup>)\nleetid: 132\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: palindrome-partitioning-ii\n---\n\nGiven a string s, partition s such that every substring of the partition is a palindrome.\n\nReturn the minimum cuts needed for a palindrome partitioning of `s`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n```\n\n**Example 2:**\n```\nInput: s = \"abaa\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aba\",\"a\"] could be produced using 1 cut.\n```",
      "body": "Given a string s, partition s such that every substring of the partition is a palindrome.\n\nReturn the minimum cuts needed for a palindrome partitioning of `s`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n```\n\n**Example 2:**\n```\nInput: s = \"abaa\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aba\",\"a\"] could be produced using 1 cut.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int minCut(string s) {\n        int n =s.length();\n        bool dp[n][n];\n        memset(dp, 0, sizeof(dp));\n        int cut[n];\n        for(int i=0; i<n; i++) {\n            int mincut = i;\n            for(int j=0; j<=i; j++) {\n                if (s[i] == s[j] && (i-j < 2 || dp[j+1][i-1])) {\n                    dp[j][i] = true;\n                    mincut = min(mincut, j==0 ? 0 : cut[j-1]+1);\n                }\n            }\n            cut[i] = mincut;\n        }\n        return cut[n-1];\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int minCut(String s) {\n        int n =s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] cut= new int[n];\n        for(int i=0; i<n; i++) {\n            int mincut = i;\n            for(int j=0; j<=i; j++) {\n                if (s.charAt(i) == s.charAt(j) && (i-j < 2 || dp[j+1][i-1])) {\n                    dp[j][i] = true;\n                    mincut = Math.min(mincut, j==0 ? 0 : cut[j-1]+1);\n                }\n            }\n            cut[i] = mincut;\n        }\n        return cut[n-1];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "palindrome-partitioning": {
      "id": "palindrome-partitioning",
      "title": "Palindrome Partitioning",
      "difficulty": "hard",
      "companies": [
        "adobe",
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "goldman",
        "google",
        "microsoft",
        "oracle",
        "twitter"
      ],
      "topics": [
        "backtracking",
        "dynamic-programming",
        "string"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(n2<sup>n</sup>)",
      "sc": "O(n<sup>2</sup>)",
      "leetcode": "palindrome-partitioning",
      "gfg": null,
      "leetid": 131,
      "content": "---\nlayout: post\ntitle: Palindrome Partitioning\ntopics: [backtracking, dynamic-programming, string]\nlangs: [java, py, cpp]\ntc: O(n2<sup>n</sup>)\nsc: O(n<sup>2</sup>)\nleetid: 131\ncompanies: [adobe, amazon, apple, bloomberg, facebook, goldman, google, microsoft, oracle, twitter]\ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: palindrome-partitioning\n---\n\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. \nReturn all possible palindrome partitioning of `s`.\n\nA palindrome string is a string that reads the same backward as forward.\n\n---\n## How to Solve\n\nA given string `s` starting at index `start` and ending at index `end` is a palindrome if following conditions are satisfied :\n1. The characters at `start` and `end` indexes are equal. \n2. The substring starting at index `start+1` and ending at index `end1` is a palindrome.\n\n<MdxImage src=\"code/palindrome_dp.png\" alt=\"Palindrome\" />\n\nLet `N` be the length of the string. \nTo determine if a substring starting at index `start` and ending at index `end` is a palindrome or not, \nwe use a 2 Dimensional array `dp` of size `NxN` where,\n\n`dp[start][end]=true` , if the substring beginning at index `start` and ending at index `end` is a palindrome.\n\nOtherwise, `dp[start][end] ==false`.\n\nAlso, we must update the `dp` array, if we find that the current string is a palindrome.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**Example 2:**\n```\nInput: s = \"a\"\nOutput: [[\"a\"]]\n```",
      "body": "Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. \nReturn all possible palindrome partitioning of `s`.\n\nA palindrome string is a string that reads the same backward as forward.\n\n---\n## How to Solve\n\nA given string `s` starting at index `start` and ending at index `end` is a palindrome if following conditions are satisfied :\n1. The characters at `start` and `end` indexes are equal. \n2. The substring starting at index `start+1` and ending at index `end1` is a palindrome.\n\n<MdxImage src=\"code/palindrome_dp.png\" alt=\"Palindrome\" />\n\nLet `N` be the length of the string. \nTo determine if a substring starting at index `start` and ending at index `end` is a palindrome or not, \nwe use a 2 Dimensional array `dp` of size `NxN` where,\n\n`dp[start][end]=true` , if the substring beginning at index `start` and ending at index `end` is a palindrome.\n\nOtherwise, `dp[start][end] ==false`.\n\nAlso, we must update the `dp` array, if we find that the current string is a palindrome.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**Example 2:**\n```\nInput: s = \"a\"\nOutput: [[\"a\"]]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        int n = s.length();\n        vector<vector<string>> result;\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        vector<string> current;\n        backtrack(s, dp, 0, current, result);\n        return result;\n    }\n\n    void backtrack(string s, vector<vector<bool>> &dp, int start, vector<string> &current, vector<vector<string>> &result) {\n        if (start >= s.length()) {\n            result.push_back(current);\n            return;\n        }\n        for(int pos=start; pos<s.length(); pos++) {\n            if (s[start] == s[pos] && (pos - start <= 2 || dp[start+1][pos-1])) {\n                dp[start][pos] = true;\n                current.push_back(s.substr(start, pos+1-start));\n                backtrack(s, dp, pos+1, current, result);\n                current.pop_back();\n            }\n        }\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<List<String>> partition(String s) {\n        int len = s.length();\n        boolean[][] dp = new boolean[len][len];\n        List<List<String>> result = new ArrayList<>();\n        backtrack(result, s, 0, new ArrayList<>(), dp);\n        return result;\n    }\n\n    void backtrack(List<List<String>> result, String s, int start, List<String> currentList, boolean[][] dp) {\n        if (start >= s.length()) result.add(new ArrayList<>(currentList));\n        for (int end = start; end < s.length(); end++) {\n            if (s.charAt(start) == s.charAt(end) && (end - start <= 2 || dp[start + 1][end - 1])) {\n                dp[start][end] = true;\n                currentList.add(s.substring(start, end + 1));\n                backtrack(result, s, end + 1, currentList, dp);\n                currentList.remove(currentList.size() - 1);\n            }\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        n = len(s)\n        dp = [[False for _ in range(n)] for _ in range(n)]\n        res = []\n        self.backtrack(s, 0, dp, [], res)\n        return res\n\n    def backtrack(self, s, start, dp, current, res):\n        if start >= len(s):\n            res.append(list(current))\n            return\n        for end in range(start, len(s)):\n            if s[start] == s[end] and (end-start <= 2 or dp[start+1][end-1]):\n                dp[start][end] = True;\n                current.append(s[start:end+1])\n                self.backtrack(s, end+1, dp, current, res)\n                current.pop()",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "partition-array-for-maximum-sum": {
      "id": "partition-array-for-maximum-sum",
      "title": "Partition Array for Maximum Sum",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nk)",
      "sc": "O(n)",
      "leetcode": "partition-array-for-maximum-sum",
      "gfg": null,
      "leetid": 1043,
      "content": "---\nlayout: post\ntitle: Partition Array for Maximum Sum\ntopics: [array, dynamic-programming]\nlangs: [java]\ntc: O(nk)\nsc: O(n)\nleetid: 1043\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: partition-array-for-maximum-sum\n---\n\nGiven an integer array `arr`, partition the array into (contiguous) subarrays of length **at most** `k`. \nAfter partitioning, each subarray has their values changed to become the maximum value of that subarray.\n\nReturn the _largest sum of the given array after partitioning_. Test cases are generated so that the answer fits in a **_32-bit integer_**.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\n```\n\n**Example 2:** \n```\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n```\n\n**Example 2:**\n```\nInput: arr = [1], k = 1\nOutput: 1\n```\n\n---\n\n## How to Solve\n\nAt every index, we need to decide whether to move the element at the index to a new partition or use the existing partition\n\nFor the first test case, `arr = [1,15,7,9,2,5,10], k = 3`\n```mermaid\ngraph TD\n    0 --> 1\n    0 --> 2\n    0 --> 3\n    1 --> 2\n    1 --> 3\n    1 --> 4\n    2 --> 3\n    2 --> 4\n    2 --> 5\n```\n\nFrom above graph, we can see that we are reusing some of the pre-calculated values. We should proceed with dynamic programming for this\n\nAt every index, check for all elements upto `index + k` and find max sum that can be made by multipying the max element in sub-array",
      "body": "Given an integer array `arr`, partition the array into (contiguous) subarrays of length **at most** `k`. \nAfter partitioning, each subarray has their values changed to become the maximum value of that subarray.\n\nReturn the _largest sum of the given array after partitioning_. Test cases are generated so that the answer fits in a **_32-bit integer_**.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\n```\n\n**Example 2:** \n```\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n```\n\n**Example 2:**\n```\nInput: arr = [1], k = 1\nOutput: 1\n```\n\n---\n\n## How to Solve\n\nAt every index, we need to decide whether to move the element at the index to a new partition or use the existing partition\n\nFor the first test case, `arr = [1,15,7,9,2,5,10], k = 3`\n```mermaid\ngraph TD\n    0 --> 1\n    0 --> 2\n    0 --> 3\n    1 --> 2\n    1 --> 3\n    1 --> 4\n    2 --> 3\n    2 --> 4\n    2 --> 5\n```\n\nFrom above graph, we can see that we are reusing some of the pre-calculated values. We should proceed with dynamic programming for this\n\nAt every index, check for all elements upto `index + k` and find max sum that can be made by multipying the max element in sub-array",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maxSumAfterPartitioning(int[] arr, int k) {\n        int[] dp = new int[arr.length];\n        Arrays.fill(dp, -1);\n        return maxSum(arr, k, dp, arr.length, 0);\n    }\n\n    private int maxSum(int[] arr, int k, int[] dp, int n, int start) {\n        if (start >= n) {\n            return 0;\n        }\n        if (dp[start] != -1) {\n            return dp[start];\n        }\n        int max = 0, ans = 0;\n        int end = Math.min(n, start + k);\n        for(int i = start; i < end; i++) {\n            max = Math.max(max, arr[i]);\n            ans = Math.max(ans, max*(i-start+1) + maxSum(arr, k, dp, n, i+1));\n        }\n        return dp[start] = ans;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "partition-equal-subset-sum": {
      "id": "partition-equal-subset-sum",
      "title": "Partition Equal Subset Sum",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n*sum)",
      "sc": "O(sum)",
      "leetcode": "partition-equal-subset-sum",
      "gfg": null,
      "leetid": 416,
      "content": "---\nlayout: post\ntitle: Partition Equal Subset Sum\ntopics: [array, dynamic-programming]\nlangs: [java, py]\ntc: O(n*sum)\nsc: O(sum)\nleetid: 416\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: partition-equal-subset-sum\n---\n\nGiven a non-empty array nums containing only positive integers, \nfind if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n```\n\n**Example 2:** \n```\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n```",
      "body": "Given a non-empty array nums containing only positive integers, \nfind if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n```\n\n**Example 2:** \n```\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean canPartition(int[] nums) {\n        int sum = 0;\n\n        for (int num : nums) {\n            sum += num;\n        }\n\n        if ((sum & 1) == 1) {\n            return false;\n        }\n        sum /= 2;\n\n        int n = nums.length;\n        boolean[] dp = new boolean[sum+1];\n        Arrays.fill(dp, false);\n        dp[0] = true;\n\n        for (int num : nums) {\n            for (int i = sum; i > 0; i--) {\n                if (i >= num) {\n                    dp[i] = dp[i] || dp[i-num];\n                }\n            }\n        }\n\n        return dp[sum];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        sm = sum(nums)\n        if sm %2 != 0:\n            return False\n        sm //= 2\n        dp = [False]*(sm+1)\n        dp[0] = True\n        for num in nums:\n            for i in range(sm, 0, -1):\n                if i >= num:\n                    dp[i] = dp[i] or dp[i-num]\n        return dp[sm]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "partition-labels": {
      "id": "partition-labels",
      "title": "Partition Labels",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "hash-table",
        "greedy",
        "string"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "partition-labels",
      "gfg": null,
      "leetid": 763,
      "content": "---\nlayout: post\ntitle: Partition Labels\ntopics: [hash-table, greedy, string]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\nleetid: 763\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: partition-labels\n---\n\nYou are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn a list of integers representing the size of these parts.\n\n---\n\n## How to Solve\n\n### Intuition\n\nLet's try to repeatedly choose the smallest left-justified partition. \nConsider the first label, say it's 'a'. \nThe first partition must include it, and also the last occurrence of 'a'. \nHowever, between those two occurrences of 'a', \nthere could be other labels that make the minimum size of this partition bigger. \nFor example, in `\"abccaddbeffe\"`, the minimum first partition is `\"abccaddb\"`. \nThis gives us the idea for the algorithm: For each letter encountered, \nprocess the last occurrence of that letter, extending the current partition `[start, end]` appropriately.\n\n### Algorithm\n\nWe need an array `last[char] -> index of S where char occurs last`. \nThen, let `start` and `end` be the start and end of the current partition. \nIf we are at a label that occurs last at some index after `end`, \nwe'll extend the partition `end = last[c]`. \nIf we are at the end of the partition `(i == end)` then we'll append a partition size to our answer, \nand set the start of our new partition to `i+1`.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(string) s = \"ababcbacadefegdehijhklij\"\n```\n\n**Output:** \n```\n(int[]) [9,7,8]\n```\n\n**Explanation:**\n```\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n```\n\n---\n\n**Input:**\n```\n(string) s = \"eccbbbbdec\"\n```\n\n**Output:**\n```\n(int[]) [10]\n```\n",
      "body": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn a list of integers representing the size of these parts.\n\n---\n\n## How to Solve\n\n### Intuition\n\nLet's try to repeatedly choose the smallest left-justified partition. \nConsider the first label, say it's 'a'. \nThe first partition must include it, and also the last occurrence of 'a'. \nHowever, between those two occurrences of 'a', \nthere could be other labels that make the minimum size of this partition bigger. \nFor example, in `\"abccaddbeffe\"`, the minimum first partition is `\"abccaddb\"`. \nThis gives us the idea for the algorithm: For each letter encountered, \nprocess the last occurrence of that letter, extending the current partition `[start, end]` appropriately.\n\n### Algorithm\n\nWe need an array `last[char] -> index of S where char occurs last`. \nThen, let `start` and `end` be the start and end of the current partition. \nIf we are at a label that occurs last at some index after `end`, \nwe'll extend the partition `end = last[c]`. \nIf we are at the end of the partition `(i == end)` then we'll append a partition size to our answer, \nand set the start of our new partition to `i+1`.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(string) s = \"ababcbacadefegdehijhklij\"\n```\n\n**Output:** \n```\n(int[]) [9,7,8]\n```\n\n**Explanation:**\n```\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n```\n\n---\n\n**Input:**\n```\n(string) s = \"eccbbbbdec\"\n```\n\n**Output:**\n```\n(int[]) [10]\n```\n",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        int last[26] = {0};\n        for(int i=0; i<s.length(); i++) {\n            last[s[i]-'a'] = i;\n        }\n        int start = 0, end = 0;\n        vector<int> res;\n        for(int i=0; i<s.length(); i++) {\n            end = max(end, last[s[i] - 'a']);\n            if (i == end) {\n                res.push_back(end-start+1);\n                start=i+1;\n            }\n        }\n        return res;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<Integer> partitionLabels(String S) {\n        int[] last = new int[26];\n        for (int i = 0; i < S.length(); ++i)\n            last[S.charAt(i) - 'a'] = i;\n\n        int end = 0, start = 0;\n        List<Integer> ans = new ArrayList();\n        for (int i = 0; i < S.length(); ++i) {\n            end = Math.max(end, last[S.charAt(i) - 'a']);\n            if (i == end) {\n                ans.add(end - start + 1);\n                start = end + 1;\n            }\n        }\n        return ans;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        n, last = len(s), [0]*26\n        for i in range(n):\n            last[ord(s[i]) - ord('a')] = i\n        start, end, res = 0, 0, []\n        for i in range(n):\n            end = max(end, last[ord(s[i]) - ord('a')])\n            if i == end:\n                res.append(end - start + 1)\n                start = end + 1\n        return res",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "path-sum-iii": {
      "id": "path-sum-iii",
      "title": "Path Sum III",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "tree",
        "depth-first-search",
        "binary-tree"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "path-sum-iii",
      "gfg": null,
      "leetid": 437,
      "content": "---\nlayout: post\ntitle: Path Sum III\ntopics: [tree, depth-first-search, binary-tree]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 437\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: path-sum-iii\n---\nGiven the `root` of a binary tree and an integer `targetSum`, return *the number of paths where the sum of the values along the path equals* `targetSum`.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style={{width: '450px', height: '386px'}} />\n```\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n\n```\n**Example 2:**\n```\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[0, 1000]`.\n\t\n* `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`\n\t\n* `-1000 <= targetSum <= 1000`\n\n        ",
      "body": "Given the `root` of a binary tree and an integer `targetSum`, return *the number of paths where the sum of the values along the path equals* `targetSum`.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style={{width: '450px', height: '386px'}} />\n```\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n\n```\n**Example 2:**\n```\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[0, 1000]`.\n\t\n* `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`\n\t\n* `-1000 <= targetSum <= 1000`\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int pathSum(TreeNode root, int targetSum) {\n        Map<Long, Integer> prefix = new HashMap<>();\n        prefix.put(0L, 1);\n        return dfs(root, targetSum, 0, prefix);\n    }\n\n    private int dfs(TreeNode root, int target, long current, Map<Long, Integer> prefix) {\n        if (root == null) {\n            return 0;\n        }\n        current += root.val;\n        int count = prefix.getOrDefault(current - target, 0);\n        prefix.put(current, prefix.getOrDefault(current, 0) + 1);\n        count += dfs(root.left, target, current, prefix);\n        count += dfs(root.right, target, current, prefix);\n        prefix.put(current, prefix.getOrDefault(current, 0) - 1);\n\n        return count;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        def dfs(root, prefix, current):\n            if not root:\n                return 0\n\n            current += root.val\n            count = prefix.get(current - targetSum, 0)\n            prefix[current] = prefix.get(current, 0) + 1\n            count += dfs(root.left, prefix, current)\n            count += dfs(root.right, prefix, current)\n            prefix[current] -= 1\n            return count\n\n        prefix = {0: 1}\n        return dfs(root, prefix, 0)",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "perfect-squares": {
      "id": "perfect-squares",
      "title": "Perfect Squares",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "dynamic-programming"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n<sup>2</sup>)",
      "sc": "O(n)",
      "leetcode": "perfect-squares",
      "gfg": null,
      "leetid": 279,
      "content": "---\nlayout: post\ntitle: Perfect Squares\ntopics: [dynamic-programming]\nlangs: [java]\ntc: O(n<sup>2</sup>)\nsc: O(n)\nleetid: 279\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: perfect-squares\n---\n\nGiven an integer `n`, return the _least number of perfect square numbers that sum to_ `n`.\n\nA *perfect square* is an integer that is the square of an integer; \nin other words, it is the product of some integer with itself. \nFor example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int) n = 12\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\n12 = 4 + 4 + 4\n```\n\n---\n\n**Input:**\n```\n(int) n = 13\n```\n\n**Output:**\n```\n(int) 2\n```\n\n**Explanation:**\n```\n12 = 4 + 9\n```",
      "body": "Given an integer `n`, return the _least number of perfect square numbers that sum to_ `n`.\n\nA *perfect square* is an integer that is the square of an integer; \nin other words, it is the product of some integer with itself. \nFor example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int) n = 12\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\n12 = 4 + 4 + 4\n```\n\n---\n\n**Input:**\n```\n(int) n = 13\n```\n\n**Output:**\n```\n(int) 2\n```\n\n**Explanation:**\n```\n12 = 4 + 9\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int numSquares(int n) {\n        int[] res = new int[n+1];\n        Arrays.fill(res, Integer.MAX_VALUE);\n        res[0] = 0;\n        for(int i=1; i<=n; i++) {\n            for(int j=1; j*j <= i; j++) {\n                res[i] = Math.min(res[i], res[i - j*j] + 1);\n            }\n        }\n        return res[n];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "permutation-sequence": {
      "id": "permutation-sequence",
      "title": "Permutation Sequence",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "recursion"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "permutation-sequence",
      "gfg": null,
      "leetid": 60,
      "content": "---\nlayout: post\ntitle: Permutation Sequence\ntopics: [recursion]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 60\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: permutation-sequence\n---\n\nThe set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all the permutations in order, we get the following sequence for `n = 3`:\n\n1. \"123\"\n2. \"132\"\n3. \"213\"\n4. \"231\"\n5. \"312\"\n6. \"321\"\n\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: n = 3, k = 3\nOutput: \"213\"\n```\n\n**Example 2:** \n```\nInput: n = 4, k = 9\nOutput: \"2314\"\n```",
      "body": "The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all the permutations in order, we get the following sequence for `n = 3`:\n\n1. \"123\"\n2. \"132\"\n3. \"213\"\n4. \"231\"\n5. \"312\"\n6. \"321\"\n\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: n = 3, k = 3\nOutput: \"213\"\n```\n\n**Example 2:** \n```\nInput: n = 4, k = 9\nOutput: \"2314\"\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String getPermutation(int n, int k) {\n        List<Integer> num = new LinkedList<Integer>();\n        int[] fact = new int[n];\n        k--;\n        for(int i=0; i<n; i++) {\n            num.add(i+1);\n            if (i==0) {\n                fact[i] = 1;\n            } else {\n                fact[i] = i*fact[i-1];\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = n; i > 0; i--){\n            int ind = k/fact[i-1];\n            k = k%fact[i-1];\n            sb.append(num.get(ind));\n            num.remove(ind);\n        }\n        return sb.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "populating-next-right-pointers-in-each-node": {
      "id": "populating-next-right-pointers-in-each-node",
      "title": "Populating Next Right Pointers in Each Node",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "binary-tree",
        "breadth-first-search",
        "linked-list",
        "tree"
      ],
      "langs": [
        "java",
        "go",
        "py",
        "cpp"
      ],
      "tc": "O(h)",
      "sc": "O(1)",
      "leetcode": "populating-next-right-pointers-in-each-node",
      "gfg": null,
      "leetid": 116,
      "content": "---\nlayout: post\ntitle: Populating Next Right Pointers in Each Node\ntopics: [binary-tree, breadth-first-search, linked-list, tree]\nlangs: [java, go, py, cpp]\ntc: O(h)\nsc: O(1)\nleetid: 116\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: populating-next-right-pointers-in-each-node\n---\n\nYou are given a perfect binary tree where all leaves are on the same level, and **every parent has two children**. \nThe binary tree has the following definition:\n```java\nclass Node {\n    int val;\n    Node left;\n    Node right;\n    Node next;\n}\n```\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n---\n## How to Solve\n\nTo solve, we will be traversing the tree per level.\nFor each node `curr` on a particular level (would already have `next` pointer due to parent level), do following\n1. if `curr.left` is not null, point its next to `curr.right`\n2. if `curr.right` is not null, point its next to `curr` neighbouring child\n3. `curr = curr.next`\n\nFor next level, move to `level.left`\n\n---\n## Test Cases\n\n<MdxImage src=\"code/116_sample.png\" alt=\"Example\" />\n\n**Example 1:**\n```\nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given the above perfect binary tree (Figure A), \nyour function should populate each next pointer to point to its next right node, just like in Figure B. \nThe serialized output is in level order as connected by the next pointers, \nwith '#' signifying the end of each level.\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```",
      "body": "You are given a perfect binary tree where all leaves are on the same level, and **every parent has two children**. \nThe binary tree has the following definition:\n```java\nclass Node {\n    int val;\n    Node left;\n    Node right;\n    Node next;\n}\n```\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n---\n## How to Solve\n\nTo solve, we will be traversing the tree per level.\nFor each node `curr` on a particular level (would already have `next` pointer due to parent level), do following\n1. if `curr.left` is not null, point its next to `curr.right`\n2. if `curr.right` is not null, point its next to `curr` neighbouring child\n3. `curr = curr.next`\n\nFor next level, move to `level.left`\n\n---\n## Test Cases\n\n<MdxImage src=\"code/116_sample.png\" alt=\"Example\" />\n\n**Example 1:**\n```\nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given the above perfect binary tree (Figure A), \nyour function should populate each next pointer to point to its next right node, just like in Figure B. \nThe serialized output is in level order as connected by the next pointers, \nwith '#' signifying the end of each level.\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if (!root) {\n            return root;\n        }\n        Node *level = root;\n        while(level) {\n            Node *curr = level;\n            while(curr) {\n                if (curr->left) {\n                    curr->left->next = curr->right;\n                }\n                if (curr->right && curr->next) {\n                    curr->right->next = curr->next->left;\n                }\n                curr = curr->next;\n            }\n            level = level->left;\n        }\n        return root;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "package populating_next_right_pointers_in_each_node\n\ntype Node struct {\n\tVal int\n\tLeft *Node\n\tRight *Node\n\tNext *Node\n}\n\nfunc connect(root *Node) *Node {\n\tlevel := root\n\tfor level != nil {\n\t\tcurr := level\n\t\tfor curr != nil {\n\t\t\tif curr.Left != nil {\n\t\t\t\tcurr.Left.Next = curr.Right\n\t\t\t}\n\t\t\tif curr.Right != nil && curr.Next != nil {\n\t\t\t\tcurr.Right.Next = curr.Next.Left\n\t\t\t}\n\t\t\tcurr = curr.Next\n\t\t}\n\t\tlevel = level.Left\n\t}\n\treturn root\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node(int _val) {\n        val = _val;\n    }\n};\n\nclass Solution {\n    public Node connect(Node root) {\n        Node level=root;\n        while(level!=null){\n            Node cur=level;\n            while(cur!=null){\n                if(cur.left!=null) cur.left.next=cur.right;\n                if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\n\n                cur=cur.next;\n            }\n            level=level.left;\n        }\n        return root;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\n\nclass Solution:\n    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':\n        level = root\n        while level is not None:\n            curr = level\n            while curr is not None:\n                if curr.left is not None:\n                    curr.left.next = curr.right\n                if curr.right is not None and curr.next is not None:\n                    curr.right.next = curr.next.left\n                curr = curr.next\n            level = level.left\n        return root",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "predict-the-winner": {
      "id": "predict-the-winner",
      "title": "Predict the Winner",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming",
        "recursion"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n<sup>2</sup>)",
      "sc": "O(n)",
      "leetcode": "predict-the-winner",
      "gfg": null,
      "leetid": 486,
      "content": "---\nlayout: post\ntitle: Predict the Winner\ntopics: [array, dynamic-programming, recursion]\nlangs: [java, cpp]\ntc: O(n<sup>2</sup>)\nsc: O(n)\nleetid: 486\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: predict-the-winner\n---\n\nYou are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. \nBoth players start the game with a score of `0`. \nAt each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) \nwhich reduces the size of the array by `1`. \nThe player adds the chosen number to their score. \nThe game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. \nIf the scores of both players are equal, then player 1 is still the winner, \nand you should also return `true`. You may assume that both players are playing optimally.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,5,2]\nOutput: false\nExplanation: Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n```\n\n**Example 2:** \n```\nInput: nums = [1,5,233,7]\nOutput: true\nExplanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n```",
      "body": "You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. \nBoth players start the game with a score of `0`. \nAt each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) \nwhich reduces the size of the array by `1`. \nThe player adds the chosen number to their score. \nThe game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. \nIf the scores of both players are equal, then player 1 is still the winner, \nand you should also return `true`. You may assume that both players are playing optimally.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,5,2]\nOutput: false\nExplanation: Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n```\n\n**Example 2:** \n```\nInput: nums = [1,5,233,7]\nOutput: true\nExplanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool PredictTheWinner(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n, 0);\n        for(int start=n-1; start>=0; start--) {\n            for(int end=start; end<n; end++) {\n                if (start == end) {\n                    dp[start] = nums[start];\n                } else {\n                    int a = nums[start] - dp[end];\n                    int b = nums[end] - dp[end - 1];\n                    dp[end] = max(a, b);\n                }\n            }\n        }\n        return dp[n-1] >= 0;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "public class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        int[] dp = new int[nums.length];\n        for (int start = nums.length; start >= 0; start--) {\n            for (int end = start; end < nums.length; end++) {\n                if (start == end) {\n                    dp[start] = nums[start];\n                } else {\n                    int a = nums[start] - dp[end];\n                    int b = nums[end] - dp[end - 1];\n                    dp[end] = Math.max(a, b);\n                }\n            }\n        }\n        return dp[nums.length - 1] >= 0;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "product-of-array-except-self": {
      "id": "product-of-array-except-self",
      "title": "Product of Array Except Self",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "prefix-sum"
      ],
      "langs": [
        "java",
        "cpp",
        "py",
        "c"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "product-of-array-except-self",
      "gfg": "a-product-array-puzzle",
      "leetid": 238,
      "content": "---\nlayout: post\ntitle: Product of Array Except Self\ntopics: [array, prefix-sum]\nlangs: [java, cpp, py, c]\ntc: O(n)\nsc: O(1)\nleetid: 238\ncompanies: [facebook]\ngfg: a-product-array-puzzle\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: product-of-array-except-self\n---\nGiven an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.\n \n---\n## Test Cases\n**Example 1:**\n```Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n```\n\n**Example 2:**\n```Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n```\n \n**Constraints:**\n\t\n* `2 <= nums.length <= 10<sup>5</sup>`\n\t\n* `-30 <= nums[i] <= 30`\n\t\n* The input is generated such that `answer[i]` is **guaranteed** to fit in a **32-bit** integer.\n \n**Follow up:** Can you solve the problem in `O(1)` extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)\n\n        ",
      "body": "Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.\n \n---\n## Test Cases\n**Example 1:**\n```Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n```\n\n**Example 2:**\n```Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n```\n \n**Constraints:**\n\t\n* `2 <= nums.length <= 10<sup>5</sup>`\n\t\n* `-30 <= nums[i] <= 30`\n\t\n* The input is generated such that `answer[i]` is **guaranteed** to fit in a **32-bit** integer.\n \n**Follow up:** Can you solve the problem in `O(1)` extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)\n\n        ",
      "solutions": {
        "c": {
          "language": "c",
          "code": "int* productExceptSelf(int* nums, int numsSize, int* returnSize) {\n    int countZero = 0, indexZero = -1;\n    int product = 1;\n    *returnSize = numsSize;\n\n    int* result = (int*) malloc(numsSize * sizeof(int));\n    if (!result) return NULL;  // handle malloc failure\n\n    // First pass: count zeros and compute product\n    for (int i = 0; i < numsSize; i++) {\n        if (nums[i] == 0) {\n            countZero++;\n            indexZero = i;\n        } else {\n            product *= nums[i];\n        }\n    }\n\n    if (countZero > 1) {\n        for (int i = 0; i < numsSize; i++) {\n            result[i] = 0;\n        }\n    } else if (countZero == 1) {\n        for (int i = 0; i < numsSize; i++) {\n            result[i] = (i == indexZero) ? product : 0;\n        }\n    } else {\n        for (int i = 0; i < numsSize; i++) {\n            result[i] = product / nums[i];\n        }\n    }\n\n    return result;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> output(n, 1);\n        for(int i=1; i<n; i++) {\n            output[i] = output[i-1]*nums[i-1];\n        }\n        int m = 1;\n        for(int i=n-1; i>=0; i--) {\n            output[i] = m*output[i];\n            m *= nums[i];\n        }\n        return output;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int l = nums.length;\n        int[] out = new int[l];\n        out[0] = 1; out[l-1] = 1;\n        for(int i=1; i<l; i++) {\n            out[i] = nums[i-1]*out[i-1];\n        }\n        int m=1;\n        for(int i=l-1; i>=0; i--) {\n            out[i] = m*out[i];\n            m *= nums[i];\n        }\n        return out;\n    }\n}\n\n/**\n * Alternate solution that handles zeros:\n * class Solution {\n *     public int[] productExceptSelf(int[] nums) {\n *         int[] result = new int[nums.length];\n *         int countZero = 0, indexZero = 0, product = 1;\n *\n *         for (int i = 0; i < nums.length; i++) {\n *             if (nums[i] == 0) {\n *                 countZero++;\n *                 indexZero = i;\n *             } else {\n *                 product *= nums[i];\n *             }\n *         }\n *\n *         if (countZero > 1) {\n *             return result;\n *         } else if (countZero == 1) {\n *             result[indexZero] = product;\n *             return result;\n *         } else {\n *             for (int i = 0; i < nums.length; i++) {\n *                 result[i] = product / nums[i];\n *             }\n *         }\n *\n *         return result;\n *     }\n * }\n */",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1 for _ in range(len(nums))]\n        prev = 1\n        for i in range(len(nums)):\n            res[i] = prev\n            prev *= nums[i]\n        prev = 1\n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= prev\n            prev *= nums[i]\n        return res",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "random-pick-with-weight": {
      "id": "random-pick-with-weight",
      "title": "Random Pick with Weight",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "math",
        "binary-search",
        "prefix-sum",
        "randomized"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(log n)",
      "sc": "O(n)",
      "leetcode": "random-pick-with-weight",
      "gfg": null,
      "leetid": 912,
      "content": "---\nlayout: post\ntitle: Random Pick with Weight\ndifficulty: medium\ntopics: [array, math, binary-search, prefix-sum, randomized]\nlangs: [java]\ntc: O(log n)\nsc: O(n)\ncompanies: [facebook]\nleetid: 912\nleetcode: random-pick-with-weight\ngfg: \ninterviewbit: \nhackerrank: \n---\nYou are given a **0-indexed** array of positive integers `w` where `w[i]` describes the **weight** of the `i<sup>th</sup>` index.\nYou need to implement the function `pickIndex()`, which **randomly** picks an index in the range `[0, w.length - 1]` (**inclusive**) and returns it. The **probability** of picking an index `i` is `w[i] / sum(w)`.\n\t\n* For example, if `w = [1, 3]`, the probability of picking index `0` is `1 / (1 + 3) = 0.25` (i.e., `25%`), and the probability of picking index `1` is `3 / (1 + 3) = 0.75` (i.e., `75%`).\n \n---\n## Test Cases\n**Example 1:**\n```\n**Input**\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n**Output**\n[null,0]\n**Explanation**\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n```\n\n**Example 2:**\n```\n**Input**\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n**Output**\n[null,1,1,1,1,0]\n\n**Explanation**\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n```\n \n**Constraints:**\n\n* `1 <= w.length <= 10<sup>4</sup>`\n* `1 <= w[i] <= 10<sup>5</sup>`\n* `pickIndex` will be called at most `10<sup>4</sup>` times.\n\n",
      "body": "You are given a **0-indexed** array of positive integers `w` where `w[i]` describes the **weight** of the `i<sup>th</sup>` index.\nYou need to implement the function `pickIndex()`, which **randomly** picks an index in the range `[0, w.length - 1]` (**inclusive**) and returns it. The **probability** of picking an index `i` is `w[i] / sum(w)`.\n\t\n* For example, if `w = [1, 3]`, the probability of picking index `0` is `1 / (1 + 3) = 0.25` (i.e., `25%`), and the probability of picking index `1` is `3 / (1 + 3) = 0.75` (i.e., `75%`).\n \n---\n## Test Cases\n**Example 1:**\n```\n**Input**\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n**Output**\n[null,0]\n**Explanation**\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n```\n\n**Example 2:**\n```\n**Input**\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n**Output**\n[null,1,1,1,1,0]\n\n**Explanation**\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n```\n \n**Constraints:**\n\n* `1 <= w.length <= 10<sup>4</sup>`\n* `1 <= w[i] <= 10<sup>5</sup>`\n* `pickIndex` will be called at most `10<sup>4</sup>` times.\n\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    private int[] prefix;\n    private Random random;\n    public Solution(int[] w) {\n        random = new Random();\n        prefix = new int[w.length];\n        prefix[0] = w[0];\n        for(int i=1; i<w.length; i++) {\n            prefix[i] = w[i] + prefix[i-1];\n        }\n    }\n\n    public int pickIndex() {\n        int limit = prefix[prefix.length - 1];\n        int digit = random.nextInt(limit) + 1;\n        return search(digit);\n    }\n\n    private int search(int digit) {\n        int left = 0, right = prefix.length - 1;\n        while(left <= right) {\n            int mid = left + (right - left)/2;\n            if (prefix[mid] == digit) {\n                return mid;\n            }\n            if (prefix[mid] < digit) {\n                left = mid+1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(w);\n * int param_1 = obj.pickIndex();\n */",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n\n    def __init__(self, w: List[int]):\n        self.prefix = [0] * len(w)\n        self.prefix[0] = w[0]\n        for i in range(1, len(w)):\n            self.prefix[i] = self.prefix[i - 1] + w[i]\n        self.total = self.prefix[-1]\n\n    def pickIndex(self) -> int:\n        pick = random.randint(1, self.total)\n        left, right = 0, len(self.prefix) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if self.prefix[mid] < pick:\n                left = mid + 1\n            else:\n                right = mid\n        return left",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "reconstruct-itinerary": {
      "id": "reconstruct-itinerary",
      "title": "Reconstruct Itinerary",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(1)",
      "sc": "O(V<sup>2</sup>)",
      "leetcode": "reconstruct-itinerary",
      "gfg": null,
      "leetid": 332,
      "content": "---\nlayout: post\ntitle: Reconstruct Itinerary\ntopics: [string]\nlangs: [java]\ntc: O(1)\nsc: O(V<sup>2</sup>)\nleetid: 332\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: reconstruct-itinerary\n---\n\nYou are given a list of airline tickets where `tickets[i] = [from[i], to[i]]` represent the departure and the arrival airports of one flight. \nReconstruct the itinerary in order and return it.\n\nAll the tickets belong to a man who departs from `\"JFK\"`, thus, the itinerary must begin with \"JFK\". \nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\nFor example, the itinerary `[\"JFK\", \"LGA\"]` has a smaller lexical order than `[\"JFK\", \"LGB\"]`.\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\nOutput: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\nJFK -> MUC -> LHR -> SFO -> SJC\n```\n\n**Example 2:** \n```\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\nOutput: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\nExplanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n```",
      "body": "You are given a list of airline tickets where `tickets[i] = [from[i], to[i]]` represent the departure and the arrival airports of one flight. \nReconstruct the itinerary in order and return it.\n\nAll the tickets belong to a man who departs from `\"JFK\"`, thus, the itinerary must begin with \"JFK\". \nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\nFor example, the itinerary `[\"JFK\", \"LGA\"]` has a smaller lexical order than `[\"JFK\", \"LGB\"]`.\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\nOutput: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\nJFK -> MUC -> LHR -> SFO -> SJC\n```\n\n**Example 2:** \n```\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\nOutput: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\nExplanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        Map<String, PriorityQueue<String>> map = new HashMap<>();\n        for(List<String> ticket: tickets) {\n            String src = ticket.get(0);\n            String dst = ticket.get(1);\n            PriorityQueue<String> pq = map.getOrDefault(src, new PriorityQueue<>());\n            pq.offer(dst);\n            map.put(src, pq);\n        }\n        Stack<String> stack = new Stack<>();\n        stack.push(\"JFK\");\n        List<String> res = new ArrayList<>();\n        while(!stack.isEmpty()) {\n            while (map.containsKey(stack.peek()) && !map.get(stack.peek()).isEmpty()) {\n                stack.push(map.get(stack.peek()).poll());\n            }\n            res.add(0, stack.pop());\n        }\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "recover-binary-search-tree": {
      "id": "recover-binary-search-tree",
      "title": "Recover Binary Search Tree",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "binary-search-tree",
        "binary-tree",
        "depth-first-search",
        "tree"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "recover-binary-search-tree",
      "gfg": null,
      "leetid": 99,
      "content": "---\nlayout: post\ntitle: Recover Binary Search Tree\ntopics: [binary-search-tree, binary-tree, depth-first-search, tree]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 99\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: recover-binary-search-tree\n---\n\nYou are given the root of a binary search tree (BST), \nwhere the values of exactly two nodes of the tree were swapped by mistake. \nRecover the tree without changing its structure.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n```\n\n**Example 2:** \n```\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n```",
      "body": "You are given the root of a binary search tree (BST), \nwhere the values of exactly two nodes of the tree were swapped by mistake. \nRecover the tree without changing its structure.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n```\n\n**Example 2:** \n```\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private TreeNode prev, first, second;\n    public void recoverTree(TreeNode root) {\n        prev = null; first = null; second = null;\n        inorder(root);\n        int temp = first.val;\n        first.val = second.val;\n        second.val = temp;\n    }\n\n    private void inorder(TreeNode root) {\n        if (root == null) return;\n        inorder(root.left);\n        if (first == null && (prev == null || prev.val >= root.val)) {\n            first = prev;\n        }\n        if (first != null && (prev.val >= root.val)) {\n            second = root;\n        }\n        prev = root;\n        inorder(root.right);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "regular-expression-matching": {
      "id": "regular-expression-matching",
      "title": "Regular Expression Matching",
      "difficulty": "hard",
      "companies": [
        "facebook",
        "microsoft",
        "goldman",
        "uber",
        "google",
        "airbnb"
      ],
      "topics": [
        "string",
        "dynamic-programming",
        "recursion"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(mn)",
      "sc": "O(mn)",
      "leetcode": "regular-expression-matching",
      "gfg": null,
      "leetid": 10,
      "content": "---\nlayout: post\ntitle: Regular Expression Matching\ntopics: [string, dynamic-programming, recursion]\nlangs: [java, py]\ntc: O(mn)\nsc: O(mn)\nleetid: 10\ngfg: \ninterviewbit: regular-expression-match\nhackerrank: \ncompanies: [facebook, microsoft, goldman, uber, google, airbnb]\ndifficulty: hard\nleetcode: regular-expression-matching\n---\nGiven an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\t\n* `'.'` Matches any single character.\n\t\n* `'*'` Matches zero or more of the preceding element.\nThe matching should cover the **entire** input string (not partial).\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:**\n```\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n```\n\n**Example 3:**\n```\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 20`\n* `1 <= p.length <= 20`\n* `s` contains only lowercase English letters.\n* `p` contains only lowercase English letters, `'.'`, and `'*'`.\n* It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.\n",
      "body": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\t\n* `'.'` Matches any single character.\n\t\n* `'*'` Matches zero or more of the preceding element.\nThe matching should cover the **entire** input string (not partial).\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:**\n```\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n```\n\n**Example 3:**\n```\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 20`\n* `1 <= p.length <= 20`\n* `s` contains only lowercase English letters.\n* `p` contains only lowercase English letters, `'.'`, and `'*'`.\n* It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        lp, ls = len(p), len(s)\n        dp = [[False] * (lp+1) for _ in range(ls + 1)]\n        dp[-1][-1] = True\n        \n        for i in range(ls, -1, -1):\n            for j in range(lp - 1, -1, -1):\n                match = i < ls and p[j] in {s[i], '.'}\n                if j + 1 < lp and p[j+1] == '*':\n                    dp[i][j] = dp[i][j+2] or match and dp[i+1][j]\n                else:\n                    dp[i][j] = match and dp[i+1][j+1]\n        return dp[0][0]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "remove-duplicate-letters": {
      "id": "remove-duplicate-letters",
      "title": "Remove Duplicate Letters",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "greedy",
        "stack",
        "string"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "remove-duplicate-letters",
      "gfg": null,
      "leetid": 316,
      "content": "---\nlayout: post\ntitle: Remove Duplicate Letters\ntopics: [greedy, stack, string]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 316\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: remove-duplicate-letters\n---\n\nGiven a string `s`, remove duplicate letters so that every letter appears once and only once. \nYou must make sure your result is **the smallest in lexicographical order** among all possible results.\n\n---\n## How to Solve\n\n1. Store occurrences of every character\n2. For every character in string, do following-\n   1. decrement number of characters remaining in the string to be analysed\n   2. if character is already present in stack, don't bother\n   3. if current character is smaller than last character in stack which occurs later in the string again, \n      it can be removed and  added later e.g. stack = bc remaining string abc then a can pop b and then c\n   4. add current character in stack and mark it as visited\n3. pop character from stack and build answer string from back\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"bcabc\"\nOutput: \"abc\"\n```\n\n**Example 2:** \n```\nInput: s = \"cbacdcbc\"\nOutput: \"acdb\"\n```",
      "body": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. \nYou must make sure your result is **the smallest in lexicographical order** among all possible results.\n\n---\n## How to Solve\n\n1. Store occurrences of every character\n2. For every character in string, do following-\n   1. decrement number of characters remaining in the string to be analysed\n   2. if character is already present in stack, don't bother\n   3. if current character is smaller than last character in stack which occurs later in the string again, \n      it can be removed and  added later e.g. stack = bc remaining string abc then a can pop b and then c\n   4. add current character in stack and mark it as visited\n3. pop character from stack and build answer string from back\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"bcabc\"\nOutput: \"abc\"\n```\n\n**Example 2:** \n```\nInput: s = \"cbacdcbc\"\nOutput: \"acdb\"\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String removeDuplicateLetters(String s) {\n\n        int[] occ = new int[26];\n        boolean[] visited = new boolean[26];\n        char[] ch = s.toCharArray();\n        for(char c: ch){\n            occ[c - 'a']++;\n        }\n        Stack<Character> stack = new Stack<>();\n        int index;\n        for(char c: ch){\n            index= c-'a';\n            occ[index]--;\n            if(visited[index]) continue;\n            while(!stack.isEmpty() && c < stack.peek() && occ[stack.peek() - 'a'] != 0){\n                visited[stack.pop() - 'a']=false;\n            }\n            stack.push(c);\n            visited[index]=true;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()){\n            sb.insert(0,stack.pop());\n        }\n        return sb.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        stack, occ, visited = [], {}, {}\n        for c in s:\n            occ[c] = occ.get(c, 0) + 1\n            visited[c] = False\n        for c in s:\n            occ[c] -= 1\n            if visited[c]:\n                continue\n            while stack and c < stack[-1] and occ[stack[-1]] > 0:\n                visited[stack.pop()] = False\n            visited[c] = True\n            stack.append(c)\n        return ''.join(stack)",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "remove-duplicates-from-sorted-list-ii": {
      "id": "remove-duplicates-from-sorted-list-ii",
      "title": "Remove Duplicates from Sorted List II",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "linked-list"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "remove-duplicates-from-sorted-list-ii",
      "gfg": null,
      "leetid": 82,
      "content": "---\nlayout: post\ntitle: Remove Duplicates from Sorted List II\ntopics: [linked-list]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 82\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: remove-duplicates-from-sorted-list-ii\n---\n\nGiven the `head` of a sorted linked list, delete all nodes that have duplicate numbers, \nleaving only distinct numbers from the original list. Return the linked list sorted as well.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n```\n\n**Example 2:** \n```\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n```",
      "body": "Given the `head` of a sorted linked list, delete all nodes that have duplicate numbers, \nleaving only distinct numbers from the original list. Return the linked list sorted as well.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n```\n\n**Example 2:** \n```\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* prev = new ListNode(0, head);\n        ListNode* curr = prev;\n        while(head != nullptr) {\n            if (head->next != nullptr && head->val == head->next->val) {\n                while(head->next != nullptr && head->val == head->next->val) {\n                    head = head->next;\n                }\n                curr->next = head->next;\n            } else {\n                curr = curr->next;\n            }\n            head = head->next;\n        }\n        return prev->next;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode prev = new ListNode(0, head);\n        ListNode curr = prev;\n        while(head != null) {\n            if (head.next != null && head.val == head.next.val) {\n                while(head.next != null && head.val == head.next.val) {\n                    head = head.next;\n                }\n                curr.next = head.next;\n            } else {\n                curr = curr.next;\n            }\n            head = head.next;\n        }\n        return prev.next;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "remove-invalid-parentheses": {
      "id": "remove-invalid-parentheses",
      "title": "Remove Invalid Parentheses",
      "difficulty": "hard",
      "companies": [
        "facebook",
        "google"
      ],
      "topics": [
        "string",
        "backtracking",
        "breadth-first-search"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(2<sup>n</sup>)",
      "sc": "O(n2<sup>n</sup>)",
      "leetcode": "remove-invalid-parentheses",
      "gfg": "remove-invalid-parentheses",
      "leetid": 301,
      "content": "---\nlayout: post\ntitle: Remove Invalid Parentheses\ndifficulty: hard\ntopics: [string, backtracking, breadth-first-search]\nlangs: [java]\ntc: O(2<sup>n</sup>)\nsc: O(n2<sup>n</sup>)\ncompanies: [facebook, google]\nleetid: 301\nleetcode: remove-invalid-parentheses\ngfg: remove-invalid-parentheses\ninterviewbit: \nhackerrank: \n---\nGiven a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\nReturn *a list of **unique strings** that are valid with the minimum number of removals*. You may return the answer in **any order**.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\n```\n\n**Example 2:**\n```\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\n```\n\n**Example 3:**\n```\nInput: s = \")(\"\nOutput: [\"\"]\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 25`\n* `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n* There will be at most `20` parentheses in `s`.\n\n",
      "body": "Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\nReturn *a list of **unique strings** that are valid with the minimum number of removals*. You may return the answer in **any order**.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\n```\n\n**Example 2:**\n```\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\n```\n\n**Example 3:**\n```\nInput: s = \")(\"\nOutput: [\"\"]\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 25`\n* `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n* There will be at most `20` parentheses in `s`.\n\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        List<String> result = new ArrayList<>();\n        boolean found = false;\n\n        queue.offer(s);\n        visited.add(s);\n        while(!queue.isEmpty()) {\n            String current = queue.poll();\n            if (isValid(current)) {\n                result.add(current);\n                found = true;\n            }\n\n            if (found) {\n                continue;\n            }\n\n            for(int i=0; i<current.length(); i++) {\n                char c = current.charAt(i);\n                if (c != '(' && c != ')') {\n                    continue;\n                }\n                String next = current.substring(0, i) + current.substring(i+1);\n                if (!visited.contains(next)) {\n                    visited.add(next);\n                    queue.offer(next);\n                }\n            }\n        }\n        return result;\n    }\n\n    private boolean isValid(String s) {\n        int count = 0;\n        for(char c: s.toCharArray()) {\n            if (c == '(') {\n                count++;\n            }\n            else if (c == ')'){\n                if (count == 0) {\n                    return false;\n                }\n                count--;\n            }\n        }\n        return count == 0;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "remove-k-digits": {
      "id": "remove-k-digits",
      "title": "Remove K Digits",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "greedy",
        "string",
        "stack"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n+k)",
      "sc": "O(n)",
      "leetcode": "remove-k-digits",
      "gfg": null,
      "leetid": 402,
      "content": "---\nlayout: post\ntitle: Remove K Digits\ntopics: [greedy, string, stack]\nlangs: [java, py]\ntc: O(n+k)\nsc: O(n)\nleetid: 402\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: remove-k-digits\n---\n\nGiven string `num` representing a non-negative integer `num`, and an integer `k`, \nreturn the smallest possible integer after removing `k` digits from `num`.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) num = \"1432219\"\n(int) k = 3\n```\n\n**Output:**\n```\n(string) \"1219\"\n```\n\n**Explanation:**\n```\nRemove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n```\n\n---\n\n**Input:**\n```\n(string) num = \"10200\"\n(int) k = 1\n```\n\n**Output:**\n```\n(string) \"200\"\n```\n\n**Explanation:**\n```\nRemove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n```\n",
      "body": "Given string `num` representing a non-negative integer `num`, and an integer `k`, \nreturn the smallest possible integer after removing `k` digits from `num`.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) num = \"1432219\"\n(int) k = 3\n```\n\n**Output:**\n```\n(string) \"1219\"\n```\n\n**Explanation:**\n```\nRemove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n```\n\n---\n\n**Input:**\n```\n(string) num = \"10200\"\n(int) k = 1\n```\n\n**Output:**\n```\n(string) \"200\"\n```\n\n**Explanation:**\n```\nRemove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n```\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        if(num.length()==k) {\n            return \"0\";\n        }\n        int top = 0;\n        char[] ca = new char[num.length()];\n        for(char c: num.toCharArray()){\n            while(k>0 && top>0 && ca[top-1]>c){\n                top--;\n                k--;\n            }\n            ca[top++] = c;\n        }\n        int i = 0, len = top-k;\n        while(i < len-1 && ca[i] == '0') {\n            i++;\n        }\n        return String.valueOf(ca, i, len-i);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        if k == len(num):\n            return '0'\n        top = 0\n        arr = ['']*len(num)\n        for c in num:\n            while k>0 and top>0 and arr[top-1] > c:\n                top -= 1\n                k -= 1\n            arr[top] = c\n            top += 1\n        i = 0\n        while i < top-k-1 and arr[i] == '0':\n            i += 1\n        return ''.join(arr[i:top-k])",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "remove-nth-node-from-end-of-list": {
      "id": "remove-nth-node-from-end-of-list",
      "title": "Remove Nth Node From End of List",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "linked-list"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "remove-nth-node-from-end-of-list",
      "gfg": null,
      "leetid": 19,
      "content": "---\nlayout: post\ntitle: Remove Nth Node From End of List\ntopics: [linked-list]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(1)\nleetid: 19\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: remove-nth-node-from-end-of-list\nhellointerview: code/linked-list/remove-nth-node-from-end-of-list\n---\n\nGiven the `head` of a linked list, remove the `n`th node from the end of the list and return its `head`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n```\n\n**Example 2:** \n```\nInput: head = [1], n = 1\nOutput: []\n```",
      "body": "Given the `head` of a linked list, remove the `n`th node from the end of the list and return its `head`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n```\n\n**Example 2:** \n```\nInput: head = [1], n = 1\nOutput: []\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        if (head == nullptr || head->next == nullptr) return nullptr;\n        ListNode *slow = head, *fast = head;\n        while(n>0 && fast != nullptr) {\n            fast = fast->next;\n            n--;\n        }\n        if (fast == nullptr) return head->next;\n        while(fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        slow->next = slow->next->next;\n        return head;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if (head == null || head.next == null)  return null;\n        ListNode slow = head, fast = head;\n        while(n > 0 && fast != null) {\n            fast = fast.next;\n            n--;\n        }\n        if (fast == null) return head.next;\n        while(fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        slow, fast = head, head\n        while n > 0 and fast:\n            fast = fast.next\n            n -= 1\n        if not fast:\n            return head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        slow.next = slow.next.next\n        return head",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "reorder-list": {
      "id": "reorder-list",
      "title": "Reorder List",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "linked-list",
        "recursion",
        "stack",
        "two-pointers"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "reorder-list",
      "gfg": null,
      "leetid": 143,
      "content": "---\nlayout: post\ntitle: Reorder List\ntopics: [linked-list, recursion, stack, two-pointers]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\nleetid: 143\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: reorder-list\nhellointerview: code/linked-list/reorder-list\n---\n\nYou are given the head of a singly linked-list. The list can be represented as:\n```\nL0  L1    Ln - 1  Ln\n```\nReorder the list to be on the following form:\n\n```\nL0  Ln  L1  Ln - 1  L2  Ln - 2  \n```\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n```\n\n**Example 2:** \n```\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n```",
      "body": "You are given the head of a singly linked-list. The list can be represented as:\n```\nL0  L1    Ln - 1  Ln\n```\nReorder the list to be on the following form:\n\n```\nL0  Ln  L1  Ln - 1  L2  Ln - 2  \n```\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n```\n\n**Example 2:** \n```\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) return;\n        ListNode prev = null, slow = head, fast = head, l1 = head;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        prev.next = null;\n        ListNode l2 = reverse(slow);\n        merge(l1, l2);\n    }\n\n    ListNode reverse(ListNode head) {\n        ListNode prev = null, curr = head, next = null;\n        while (curr != null) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n\n    void merge(ListNode l1, ListNode l2) {\n        while (l1 != null) {\n            ListNode n1 = l1.next, n2 = l2.next;\n            l1.next = l2;\n            if (n1 == null) break;\n            l2.next = n1;\n            l1 = n1;\n            l2 = n2;\n        }\n    }\n\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        second = slow.next\n        slow.next = None\n\n        prev = None\n        while second:\n            temp = second.next\n            second.next = prev\n            prev = second\n            second = temp\n\n        first = head\n        second = prev\n        while second:\n            temp1, temp2 = first.next, second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "replace-words": {
      "id": "replace-words",
      "title": "Replace Words",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "hash-table",
        "string",
        "trie"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(nm)",
      "sc": "O(d)",
      "leetcode": "replace-words",
      "gfg": null,
      "leetid": 648,
      "content": "---\nlayout: post\ntitle: Replace Words\ntopics: [array, hash-table, string, trie]\nlangs: [java, py]\ntc: O(nm)\nsc: O(d)\nleetid: 648\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: replace-words\n---\nIn English, we have a concept called **root**, which can be followed by some other word to form another longer word - let's call this word **derivative**. For example, when the **root** `\"help\"` is followed by the word `\"ful\"`, we can form a derivative `\"helpful\"`.\nGiven a `dictionary` consisting of many **roots** and a `sentence` consisting of words separated by spaces, replace all the derivatives in the sentence with the **root** forming it. If a derivative can be replaced by more than one **root**, replace it with the **root** that has **the shortest length**.\nReturn *the `sentence`* after the replacement.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\nOutput: \"the cat was rat by the bat\"\n```\n\n**Example 2:**\n```\nInput: dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\nOutput: \"a a b c\"\n```\n \n**Constraints:**\n\t\n* `1 <= dictionary.length <= 1000`\n* `1 <= dictionary[i].length <= 100`\n* `dictionary[i]` consists of only lower-case letters.\n* `1 <= sentence.length <= 10<sup>6</sup>`\n* `sentence` consists of only lower-case letters and spaces.\n* The number of words in `sentence` is in the range `[1, 1000]`\n* The length of each word in `sentence` is in the range `[1, 1000]`\n* Every two consecutive words in `sentence` will be separated by exactly one space.\n* `sentence` does not have leading or trailing spaces.\n\n        ",
      "body": "In English, we have a concept called **root**, which can be followed by some other word to form another longer word - let's call this word **derivative**. For example, when the **root** `\"help\"` is followed by the word `\"ful\"`, we can form a derivative `\"helpful\"`.\nGiven a `dictionary` consisting of many **roots** and a `sentence` consisting of words separated by spaces, replace all the derivatives in the sentence with the **root** forming it. If a derivative can be replaced by more than one **root**, replace it with the **root** that has **the shortest length**.\nReturn *the `sentence`* after the replacement.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\nOutput: \"the cat was rat by the bat\"\n```\n\n**Example 2:**\n```\nInput: dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\nOutput: \"a a b c\"\n```\n \n**Constraints:**\n\t\n* `1 <= dictionary.length <= 1000`\n* `1 <= dictionary[i].length <= 100`\n* `dictionary[i]` consists of only lower-case letters.\n* `1 <= sentence.length <= 10<sup>6</sup>`\n* `sentence` consists of only lower-case letters and spaces.\n* The number of words in `sentence` is in the range `[1, 1000]`\n* The length of each word in `sentence` is in the range `[1, 1000]`\n* Every two consecutive words in `sentence` will be separated by exactly one space.\n* `sentence` does not have leading or trailing spaces.\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class TrieNode {\n\n    boolean isEnd;\n    TrieNode[] children;\n\n    TrieNode() {\n        isEnd = false;\n        children = new TrieNode[26];\n    }\n}\n\nclass Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode current = root;\n        for (char c : word.toCharArray()) {\n            if (current.children[c - 'a'] == null) {\n                current.children[c - 'a'] = new TrieNode();\n            }\n            current = current.children[c - 'a'];\n        }\n        current.isEnd = true;\n    }\n\n    // Find the shortest root of the word in the trie\n    public String shortestRoot(String word) {\n        TrieNode current = root;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            if (current.children[c - 'a'] == null) {\n                // There is not a corresponding root in the trie\n                return word;\n            }\n            current = current.children[c - 'a'];\n            if (current.isEnd) {\n                return word.substring(0, i + 1);\n            }\n        }\n        // There is not a corresponding root in the trie\n        return word;\n    }\n}\n\nclass Solution {\n\n    public String replaceWords(List<String> dictionary, String sentence) {\n        String wordArray[] = sentence.split(\" \");\n\n        Trie dictTrie = new Trie();\n        for (String word : dictionary) {\n            dictTrie.insert(word);\n        }\n\n        // Replace each word in the sentence with the corresponding shortest root\n        for (int word = 0; word < wordArray.length; word++) {\n            wordArray[word] = dictTrie.shortestRoot(wordArray[word]);\n        }\n\n        return String.join(\" \", wordArray);\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def replaceWords(self, dictionary: List[str], sentence: str) -> str:\n        root = Trie()\n        for word in dictionary:\n            root.insert(word)\n\n        res, split = [], sentence.split(' ')\n        for word in split:\n            res.append(root.search(word))\n\n        return ' '.join(res)\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.leaf = True\n\n    def search(self, word: str) -> str:\n        node = self.root\n        for i in range(len(word)):\n            c = word[i]\n            if c not in node.children:\n                return word\n            node = node.children[c]\n            if node.leaf:\n                return word[:i+1]\n        return word\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.leaf = False",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "restore-ip-addresses": {
      "id": "restore-ip-addresses",
      "title": "Restore IP Addresses",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "backtracking",
        "string"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n<sup>3</sup>)",
      "sc": "O(1)",
      "leetcode": "restore-ip-addresses",
      "gfg": null,
      "leetid": 93,
      "content": "---\nlayout: post\ntitle: Restore IP Addresses\ntopics: [backtracking, string]\nlangs: [java, py]\ntc: O(n<sup>3</sup>)\nsc: O(1)\nleetid: 93\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: restore-ip-addresses\n---\n\nA valid IP address consists of exactly four integers separated by single dots. \nEach integer is between `0` and `255` (inclusive) and cannot have leading zeros. \n- For example, `\"0.1.2.201\"` and `\"192.168.1.1\"` are valid IP addresses, \nbut `\"0.011.255.245\"`, `\"192.168.1.312\"` and `\"192.168@1.1\"` are invalid IP addresses.\n\nGiven a string s containing only digits, \nreturn all possible valid IP addresses that can be formed by inserting dots into s. \nYou are not allowed to reorder or remove any digits in s. \nYou may return the valid IP addresses in any order.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) s = \"25525511135\"\n```\n\n**Output:**\n```\n(string[]) [\"255.255.11.135\",\"255.255.111.35\"]\n```\n\n---\n\n**Input:**\n```\n(string) s = \"101023\"\n```\n\n**Output:**\n```\n(string[]) [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n```",
      "body": "A valid IP address consists of exactly four integers separated by single dots. \nEach integer is between `0` and `255` (inclusive) and cannot have leading zeros. \n- For example, `\"0.1.2.201\"` and `\"192.168.1.1\"` are valid IP addresses, \nbut `\"0.011.255.245\"`, `\"192.168.1.312\"` and `\"192.168@1.1\"` are invalid IP addresses.\n\nGiven a string s containing only digits, \nreturn all possible valid IP addresses that can be formed by inserting dots into s. \nYou are not allowed to reorder or remove any digits in s. \nYou may return the valid IP addresses in any order.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) s = \"25525511135\"\n```\n\n**Output:**\n```\n(string[]) [\"255.255.11.135\",\"255.255.111.35\"]\n```\n\n---\n\n**Input:**\n```\n(string) s = \"101023\"\n```\n\n**Output:**\n```\n(string[]) [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        int n = s.length();\n        List<String> res = new ArrayList<>();\n        for(int i=0; i<n-2; i++) {\n            for(int j=i+1; j<n-1; j++) {\n                for(int k=j+1; k<n; k++) {\n                    String s1 = s.substring(0, i);\n                    String s2 = s.substring(i, j);\n                    String s3 = s.substring(j, k);\n                    String s4 = s.substring(k, n);\n                    if (isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)) {\n                        res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    private boolean isValid(String s) {\n        if (s.length() == 0) return false;\n        if (s.length() > 3) return false;\n        if (s.charAt(0) == '0' && s.length() > 1) return false;\n        if (Integer.parseInt(s) > 255) return false;\n        return true;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res, n = [], len(s)\n        for i in range(0, n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    s1, s2, s3, s4 = s[:i], s[i:j], s[j:k], s[k:]\n                    if self.isValid([s1, s2, s3, s4]):\n                        res.append(s1 + \".\" + s2 + \".\" + s3 + \".\" + s4)\n        return res\n\n    def isValid(self, li):\n        valid = True\n        for s in li:\n            if len(s) == 0 or len(s) > 3 or (s[0] == '0' and len(s) > 1) or int(s) > 255:\n                valid = False\n                break\n        return valid",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "reverse-linked-list-ii": {
      "id": "reverse-linked-list-ii",
      "title": "Reverse Linked List II",
      "difficulty": "medium",
      "companies": [
        "facebook",
        "uber"
      ],
      "topics": [
        "linked-list"
      ],
      "langs": [
        "java",
        "c",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "reverse-linked-list-ii",
      "gfg": null,
      "leetid": 92,
      "content": "---\nlayout: post\ntitle: Reverse Linked List II\ntopics: [linked-list]\nlangs: [java, c, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 92\ninterviewbit: reverse-link-list-ii\ndifficulty: medium\ncompanies: [facebook, uber]\ngfg: \nhackerrank: \nleetcode: reverse-linked-list-ii\n---\n\nGiven the head of a singly linked list and two integers `left` and `right` where `left <= right`, \nreverse the nodes of the list from position `left` to position `right`, and return the reversed list.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/rev2ex2.jpeg\" alt=\"Linked list\" />\n\n**Input:**\n```\n(ListNode) head = [1,2,3,4,5]\n(int) left = 2\n(int) right = 4\n```\n\n**Output:**\n```\n(ListNode) [1,4,3,2,5]\n```",
      "body": "Given the head of a singly linked list and two integers `left` and `right` where `left <= right`, \nreverse the nodes of the list from position `left` to position `right`, and return the reversed list.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/rev2ex2.jpeg\" alt=\"Linked list\" />\n\n**Input:**\n```\n(ListNode) head = [1,2,3,4,5]\n(int) left = 2\n(int) right = 4\n```\n\n**Output:**\n```\n(ListNode) [1,4,3,2,5]\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\n    if (head == NULL) return head;\n    struct ListNode *prev = NULL, *curr = head;\n    while(left > 1) {\n        prev = curr;\n        curr = curr->next;\n        left--;\n        right--;\n    }\n\n    struct ListNode* tail = curr, *conn = prev;\n    while (right > 0) {\n        struct ListNode *third = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = third;\n        right--;\n    }\n\n    if (conn != NULL) {\n        conn->next = prev;\n    } else {\n        head = prev;\n    }\n    tail->next = curr;\n    return head;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        if (head == NULL) return head;\n        ListNode *prev = NULL, *curr = head;\n        while(left > 1) {\n            prev = curr;\n            curr = curr->next;\n            left--;\n            right--;\n        }\n\n        ListNode* tail = curr, *conn = prev;\n        while (right > 0) {\n            ListNode *third = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = third;\n            right--;\n        }\n\n        if (conn != NULL) {\n            conn->next = prev;\n        } else {\n            head = prev;\n        }\n        tail->next = curr;\n        return head;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (head == null) return head;\n        ListNode prev = null, curr = head;\n        while(left > 1) {\n            prev = curr;\n            curr = curr.next;\n            left--;\n            right--;\n        }\n\n        ListNode tail = curr, conn = prev;\n        while(right > 0) {\n            ListNode third = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = third;\n            right--;\n        }\n\n        if (conn != null) {\n            conn.next = prev;\n        } else {\n            head = prev;\n        }\n        tail.next = curr;\n        return head;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "reverse-nodes-in-k-group": {
      "id": "reverse-nodes-in-k-group",
      "title": "Reverse Nodes in k-Group",
      "difficulty": "hard",
      "companies": [
        "amazon",
        "apple",
        "facebook",
        "google",
        "microsoft",
        "oracle"
      ],
      "topics": [
        "linked-list",
        "recursion"
      ],
      "langs": [
        "java",
        "cpp",
        "py",
        "c"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "reverse-nodes-in-k-group",
      "gfg": "reverse-a-linked-list-in-groups-of-given-size",
      "leetid": 25,
      "content": "---\nlayout: post\ntitle: Reverse Nodes in k-Group\ntopics: [linked-list, recursion]\nlangs: [java, cpp, py, c]\ntc: O(n)\nsc: O(1)\nleetid: 25\ncompanies: [amazon, apple, facebook, google, microsoft, oracle]\ndifficulty: hard\ngfg: reverse-a-linked-list-in-groups-of-given-size\nhackerrank: \ninterviewbit: \nleetcode: reverse-nodes-in-k-group\n---\n\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. \nIf the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n```\n\n**Example 2:** \n```\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n```",
      "body": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. \nIf the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n```\n\n**Example 2:** \n```\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* reverseKGroup(struct ListNode* head, int k){\n    if (head == NULL) return head;\n    int count = 0;\n    struct ListNode* end = head;\n    while(count++ < k) {\n        if (end == NULL) return head;\n        end = end->next;\n    }\n    struct ListNode *next, *curr = head, *prev = reverseKGroup(end, k);\n    while(curr != end) {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n    return prev;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if (head == NULL) return head;\n        int count = 0;\n        ListNode* end = head;\n        while(count++ < k) {\n            if (end == NULL) return head;\n            end = end->next;\n        }\n        ListNode *curr = head, *prev = reverseKGroup(end, k);\n        while(curr != end) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null) return head;\n        ListNode end = head;\n        int i = 0;\n        while(i++ < k) {\n            if (end == null) return head;\n            end = end.next;\n        }\n        ListNode prev = reverseKGroup(end, k), curr = head;\n        while(curr != end) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        count, end = 0, head\n        while count < k:\n            if end is None:\n                return head\n            end = end.next\n            count += 1\n        curr, prev = head, self.reverseKGroup(end, k)\n        while curr != end:\n            next = curr.next\n            curr.next = prev\n            prev, curr = curr, next\n        return prev",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "rotate-array": {
      "id": "rotate-array",
      "title": "Rotate Array",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "two-pointers"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(logn)",
      "sc": "O(1)",
      "leetcode": "rotate-array",
      "gfg": null,
      "leetid": 189,
      "content": "---\nlayout: post\ntitle: Rotate Array\ntopics: [array, two-pointers]\nlangs: [java, cpp, py]\ntc: O(logn)\nsc: O(1)\nleetid: 189\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: rotate-array\n---\n\nGiven an array, rotate the array to the right by k steps, where k is non-negative.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n**Example 2:** \n```\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```",
      "body": "Given an array, rotate the array to the right by k steps, where k is non-negative.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n**Example 2:** \n```\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k %= n;\n        reverse(nums, 0, n-k-1);\n        reverse(nums, n-k, n-1);\n        reverse(nums, 0, n-1);\n    }\n\n    void reverse(vector<int> &nums, int start, int end) {\n        while(start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public void rotate(int[] nums, int k) {\n        int n = nums.length;\n        k %= n;\n        reverse(nums, 0, n-k-1);\n        reverse(nums, n-k, n-1);\n        reverse(nums, 0, n-1);\n    }\n\n    public void reverse(int[] nums, int start, int end) {\n        while(start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def rotate(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        k %= n\n        self.reverse(nums, 0, n-k-1)\n        self.reverse(nums, n-k, n-1)\n        self.reverse(nums, 0, n-1)\n\n    def reverse(self, nums, start, end) -> None:\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start+=1\n            end-=1",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "rotate-list": {
      "id": "rotate-list",
      "title": "Rotate List",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "linked-list"
      ],
      "langs": [
        "java",
        "cpp",
        "c"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "rotate-list",
      "gfg": null,
      "leetid": 61,
      "content": "---\nlayout: post\ntitle: Rotate List\ntopics: [linked-list]\nlangs: [java, cpp, c]\ntc: O(n)\nsc: O(1)\nleetid: 61\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: rotate-list\n---\n\nGiven the head of a linked list, rotate the list to the right by k places.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n```\n\n**Example 2:** \n```\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n```",
      "body": "Given the head of a linked list, rotate the list to the right by k places.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n```\n\n**Example 2:** \n```\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode* rotateRight(struct ListNode* head, int k){\n    if (k==0 || head == NULL || head->next == NULL) return head;\n    struct ListNode* fast = head;\n    int n=0;\n    while(fast != NULL) {\n        fast = fast->next;\n        n++;\n    }\n    if (n <= k) k = k%n;\n    if (k==0) return head;\n    fast = head;\n    while(k>0) {\n        k--;\n        fast = fast->next;\n    }\n    struct ListNode* slow = head;\n    while (fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next;\n    }\n    fast->next = head;\n    struct ListNode* newhead = slow->next;\n    slow->next = NULL;\n    return newhead;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(NULLptr) {}\n *     ListNode(int x) : val(x), next(NULLptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k==0 || head == NULL || head->next == NULL) return head;\n        ListNode* fast = head;\n        int n=0;\n        while(fast != NULL) {\n            fast = fast->next;\n            n++;\n        }\n        if (n <= k) k = k%n;\n        if (k==0) return head;\n        fast = head;\n        while(k>0) {\n            k--;\n            fast = fast->next;\n        }\n        ListNode* slow = head;\n        while (fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        fast->next = head;\n        ListNode* newhead = slow->next;\n        slow->next = NULL;\n        return newhead;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k==0 || head == null || head.next == null) return head;\n        ListNode fast = head;\n        int n=0;\n        while(fast != null) {\n            fast = fast.next;\n            n++;\n        }\n        if (n <= k) k = k%n;\n        if (k==0) return head;\n        fast = head;\n        while(k>0) {\n            k--;\n            fast = fast.next;\n        }\n        ListNode slow = head;\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode newhead = slow.next;\n        slow.next = null;\n        return newhead;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "rotational-cipher": {
      "id": "rotational-cipher",
      "title": "Rotational Cipher",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": null,
      "gfg": null,
      "content": "---\nlayout: post\ntitle: Rotational Cipher\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(1)\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nOne simple way to encrypt a string is to \"rotate\" every alphanumeric character by a certain amount. Rotating a character means replacing it with another character that is a certain number of steps away in normal alphabetic or numerical order.\nFor example, if the string \"Zebra-493?\" is rotated 3 places, the resulting string is \"Cheud-726?\". Every alphabetic character is replaced with the character 3 letters higher (wrapping around from Z to A), and every numeric character replaced with the character 3 digits higher (wrapping around from 9 to 0). Note that the non-alphanumeric characters remain unchanged.\nGiven a string and a rotation factor, return an encrypted string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\ninput = Zebra-493?\nrotationFactor = 3\noutput = Cheud-726?\n```\n\n**Example 2:** \n```\ninput = abcdefghijklmNOPQRSTUVWXYZ0123456789\nrotationFactor = 39\noutput = nopqrstuvwxyzABCDEFGHIJKLM9012345678\n```",
      "body": "One simple way to encrypt a string is to \"rotate\" every alphanumeric character by a certain amount. Rotating a character means replacing it with another character that is a certain number of steps away in normal alphabetic or numerical order.\nFor example, if the string \"Zebra-493?\" is rotated 3 places, the resulting string is \"Cheud-726?\". Every alphabetic character is replaced with the character 3 letters higher (wrapping around from Z to A), and every numeric character replaced with the character 3 digits higher (wrapping around from 9 to 0). Note that the non-alphanumeric characters remain unchanged.\nGiven a string and a rotation factor, return an encrypted string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\ninput = Zebra-493?\nrotationFactor = 3\noutput = Cheud-726?\n```\n\n**Example 2:** \n```\ninput = abcdefghijklmNOPQRSTUVWXYZ0123456789\nrotationFactor = 39\noutput = nopqrstuvwxyzABCDEFGHIJKLM9012345678\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    String rotationalCipher(String input, int rotationFactor) {\n        StringBuilder sb = new StringBuilder();\n        int n = input.length();\n        for(int i=0; i<n; i++) {\n            char c = input.charAt(i);\n            if ('a' <= c && c <= 'z') {\n                sb.append((char)('a' + (c - 'a' + rotationFactor)%26));\n            }\n            else if ('A' <= c && c <= 'Z') {\n                sb.append((char)('A' + (c - 'A' + rotationFactor)%26));\n            }\n            else if ('0' <= c && c <= '9') {\n                sb.append((char)('0' + (c - '0' + rotationFactor)%10));\n            } else {\n                sb.append(c);\n            }\n\n        }\n        return sb.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "russian-doll-envelopes": {
      "id": "russian-doll-envelopes",
      "title": "Russian Doll Envelopes",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "binary-search",
        "dynamic-programming",
        "sorting"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nlogn)",
      "sc": "O(n)",
      "leetcode": "russian-doll-envelopes",
      "gfg": null,
      "leetid": 354,
      "content": "---\nlayout: post\ntitle: Russian Doll Envelopes\ntopics: [array, binary-search, dynamic-programming, sorting]\nlangs: [java]\ntc: O(nlogn)\nsc: O(n)\nleetid: 354\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: russian-doll-envelopes\n---\n\nYou are given a 2D array of integers envelopes where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll_ (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n```\n\n**Example 2:** \n```\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n```",
      "body": "You are given a 2D array of integers envelopes where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll_ (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n```\n\n**Example 2:** \n```\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        Arrays.sort(envelopes, (a, b) -> a[0] != b[0] ? a[0]-b[0] : -a[1]+b[1]);\n        int n = envelopes.length;\n        int[] lis = new int[n];\n        int size = 0;\n        for(int i=0; i<n; i++) {\n            int start = 0, end = size;\n            while(start != end) {\n                int mid = start + (end-start)/2;\n                if (envelopes[i][1] > lis[mid]) {\n                    start = mid+1;\n                } else {\n                    end = mid;\n                }\n            }\n            lis[start] = envelopes[i][1];\n            if (start == size) ++size;\n        }\n        return size;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "score-of-parentheses": {
      "id": "score-of-parentheses",
      "title": "Score of Parentheses",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "stack",
        "string"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "score-of-parentheses",
      "gfg": null,
      "leetid": 856,
      "content": "---\nlayout: post\ntitle: Score of Parentheses\ntopics: [stack, string]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 856\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: score-of-parentheses\n---\n\nGiven a balanced parentheses string `s`, return the score of the string.\n\nThe score of a balanced parentheses string is based on the following rule:\n- `\"()\"` has score `1`.\n- `AB` has score `A + B`, where `A` and `B` are balanced parentheses strings.\n- `(A)` has score `2 * A`, where `A` is a balanced parentheses string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"()\"\nOutput: 1\n```\n\n**Example 2:** \n```\nInput: s = \"(())\"\nOutput: 2\n```\n\n**Example 3:**\n```\nInput: s = \"()()\"\nOutput: 2\n```",
      "body": "Given a balanced parentheses string `s`, return the score of the string.\n\nThe score of a balanced parentheses string is based on the following rule:\n- `\"()\"` has score `1`.\n- `AB` has score `A + B`, where `A` and `B` are balanced parentheses strings.\n- `(A)` has score `2 * A`, where `A` is a balanced parentheses string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"()\"\nOutput: 1\n```\n\n**Example 2:** \n```\nInput: s = \"(())\"\nOutput: 2\n```\n\n**Example 3:**\n```\nInput: s = \"()()\"\nOutput: 2\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int scoreOfParentheses(String s) {\n        Stack<Integer> stack = new Stack<>();\n        stack.push(0);\n        for(int i=0; i<s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(0);\n            } else {\n                int curr = stack.pop();\n                int prev = stack.pop();\n                stack.push(prev + Math.max(2*curr, 1));\n            }\n        }\n        return stack.pop();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def scoreOfParentheses(self, s: str) -> int:\n        stack = [0]\n        for c in s:\n            if c == '(':\n                stack.append(0)\n            else:\n                curr, prev = stack.pop(), stack.pop()\n                stack.append(prev + max(1, 2*curr))\n        return stack.pop()",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "scramble-string": {
      "id": "scramble-string",
      "title": "Scramble String",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "dynamic-programming",
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(2<sup>n</sup>)",
      "sc": "O(m+n)",
      "leetcode": "scramble-string",
      "gfg": null,
      "leetid": 87,
      "content": "---\nlayout: post\ntitle: Scramble String\ntopics: [dynamic-programming, string]\nlangs: [java]\ntc: O(2<sup>n</sup>)\nsc: O(m+n)\nleetid: 87\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: scramble-string\n---\n\nWe can scramble a string `s` to get a string `t` using the following algorithm:\n1. If the length of the string is 1, stop. \n2. If the length of the string is > 1, do the following:\n   - Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to `x` and `y` where `s = x + y`. \n   - **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`. \n   - Apply step 1 recursively on each of the two substrings `x` and `y`.\n   \nGiven two strings `s1` and `s2` of the same length, return true if `s2` is a scrambled string of `s1`, otherwise, return false.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n```\n\n**Example 2:** \n```\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n```\n\n**Example 3:**\n```\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n```",
      "body": "We can scramble a string `s` to get a string `t` using the following algorithm:\n1. If the length of the string is 1, stop. \n2. If the length of the string is > 1, do the following:\n   - Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to `x` and `y` where `s = x + y`. \n   - **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`. \n   - Apply step 1 recursively on each of the two substrings `x` and `y`.\n   \nGiven two strings `s1` and `s2` of the same length, return true if `s2` is a scrambled string of `s1`, otherwise, return false.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n```\n\n**Example 2:** \n```\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n```\n\n**Example 3:**\n```\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean isScramble(String s1, String s2) {\n        Map<String, Boolean> map = new HashMap<>();\n        return isScramble(s1, s2, map);\n    }\n\n    public boolean isScramble(String s1, String s2, Map<String, Boolean> map) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(s1).append(s2);\n        String key = sb.toString();\n        if (map.containsKey(key)) return map.get(key);\n        if (s1.equals(s2)) {\n            map.put(key, true);\n            return true;\n        }\n        int[] count = new int[26];\n        int l = s1.length();\n        for(int i=0; i<l; i++) {\n            count[s1.charAt(i) - 'a']++;\n            count[s2.charAt(i) - 'a']--;\n        }\n        for(int i=0; i<26; i++) {\n            if (count[i] != 0) {\n                map.put(key, false);\n                return false;\n            }\n        }\n        for(int i=1; i<=l-1; i++) {\n            if (isScramble(s1.substring(0, i), s2.substring(0, i), map) &&\n                    isScramble(s1.substring(i), s2.substring(i), map)) {\n                map.put(key, true);\n                return true;\n            }\n            if (isScramble(s1.substring(0, i), s2.substring(l-i), map) &&\n                    isScramble(s1.substring(i), s2.substring(0, l-i), map)) {\n                map.put(key, true);\n                return true;\n            }\n        }\n        map.put(key, false);\n        return false;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "search-a-2d-matrix": {
      "id": "search-a-2d-matrix",
      "title": "Search a 2D Matrix",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "binary-search",
        "matrix"
      ],
      "langs": [
        "java",
        "cpp",
        "c",
        "py",
        "go"
      ],
      "tc": "O(mn)",
      "sc": "O(1)",
      "leetcode": "search-a-2d-matrix",
      "gfg": null,
      "leetid": 74,
      "content": "---\nlayout: post\ntitle: Search a 2D Matrix\ntopics: [array, binary-search, matrix]\nlangs: [java, cpp, c, py, go]\ntc: O(mn)\nsc: O(1)\nleetid: 74\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: search-a-2d-matrix\n---\n\nWrite an efficient algorithm that searches for a value target in an `m` x `n` integer `matrix`. This matrix has the following properties:\n- Integers in each row are sorted from left to right.\n- The first integer of each row is greater than the last integer of the previous row.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n```\n\n**Example 2:** \n\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n```",
      "body": "Write an efficient algorithm that searches for a value target in an `m` x `n` integer `matrix`. This matrix has the following properties:\n- Integers in each row are sorted from left to right.\n- The first integer of each row is greater than the last integer of the previous row.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n```\n\n**Example 2:** \n\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\n    int row = 0, col = *matrixColSize-1;\n    while(row < matrixSize && col >= 0) {\n        int cell = matrix[row][col];\n        if (cell == target) return true;\n        if (cell < target) {\n            row++;\n        } else {\n            col--;\n        }\n    }\n    return false;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int n = matrix.size(), m = matrix[0].size();\n        int row = 0, col = m-1;\n        while(row < n && col >= 0) {\n            int cell = matrix[row][col];\n            if (cell == target) return true;\n            if (cell < target) {\n                row++;\n            } else {\n                col--;\n            }\n        }\n        return false;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "package search_a_2d_matrix\n\nfunc searchMatrix(matrix [][]int, target int) bool {\n\tn := len(matrix)\n\tm := len(matrix[0])\n\trow := 0\n\tcol := m-1\n\tfor row < n && col >=0 {\n\t\tcell := matrix[row][col]\n\t\tif cell == target {\n\t\t\treturn true\n\t\t}\n\t\tif cell < target {\n\t\t\trow++\n\t\t} else {\n\t\t\tcol--\n\t\t}\n\t}\n\treturn false\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int n = matrix.length, m = matrix[0].length;\n        int row = 0, col = m-1;\n        while(row < n && col >= 0) {\n            int cell = matrix[row][col];\n            if (cell == target) return true;\n            if (cell < target) {\n                row++;\n            } else {\n                col--;\n            }\n        }\n        return false;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        n, m = len(matrix), len(matrix[0])\n        row, col = 0, m - 1\n        while row < n and col >= 0:\n            cell = matrix[row][col]\n            if cell == target:\n                return True\n            if cell < target:\n                row += 1\n            else:\n                col -= 1\n        return False",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "search-in-rotated-sorted-array-ii": {
      "id": "search-in-rotated-sorted-array-ii",
      "title": "Search in Rotated Sorted Array II",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "binary-search"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "search-in-rotated-sorted-array-ii",
      "gfg": "search-an-element-in-a-sorted-and-pivoted-array",
      "leetid": 81,
      "content": "---\nlayout: post\ntitle: Search in Rotated Sorted Array II\ntopics: [array, binary-search]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 81\ngfg: search-an-element-in-a-sorted-and-pivoted-array\ncompanies: [facebook]\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: search-in-rotated-sorted-array-ii\nhellointerview: code/binary-search/search-in-rotated-sorted-array\n---\n\nThere is an integer array `nums` sorted in non-decreasing order (not necessarily with distinct values).\n\nBefore being passed to your function, \n`nums` is rotated at an unknown pivot index `k` (`0` &lt;= `k` &lt; `nums.length`) \nsuch that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). \nFor example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index 5 and become `[4,5,6,6,7,0,1,2,4,4]`.\n\nGiven the array `nums` after the rotation and an integer `target`, return true if `target` is in nums, or false if it is not in nums.\n\nYou must decrease the overall operation steps as much as possible.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n```\n\n**Example 2:** \n```\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n```",
      "body": "There is an integer array `nums` sorted in non-decreasing order (not necessarily with distinct values).\n\nBefore being passed to your function, \n`nums` is rotated at an unknown pivot index `k` (`0` &lt;= `k` &lt; `nums.length`) \nsuch that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). \nFor example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index 5 and become `[4,5,6,6,7,0,1,2,4,4]`.\n\nGiven the array `nums` after the rotation and an integer `target`, return true if `target` is in nums, or false if it is not in nums.\n\nYou must decrease the overall operation steps as much as possible.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n```\n\n**Example 2:** \n```\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean search(int[] nums, int target) {\n        int low = 0, high = nums.length-1;\n        while(low <= high) {\n            int mid = low + (high-low)/2;\n            if (nums[mid] == target) return true;\n            if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\n                low++;\n                high--;\n            }\n            else if (nums[low] <= nums[mid]) {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid-1;\n                } else {\n                    low = mid+1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid+1;\n                } else {\n                    high = mid-1;\n                }\n            }\n        }\n        return false;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "search-in-rotated-sorted-array": {
      "id": "search-in-rotated-sorted-array",
      "title": "Search in Rotated Sorted Array",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "two-pointers"
      ],
      "langs": [
        "java",
        "go",
        "cpp",
        "py",
        "c"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "search-in-rotated-sorted-array",
      "gfg": "search-an-element-in-a-sorted-and-pivoted-array",
      "leetid": 33,
      "content": "---\nlayout: post\ntitle: Search in Rotated Sorted Array\ntopics: [array, two-pointers]\nlangs: [java, go, cpp, py, c]\ntc: O(n)\nsc: O(n)\nleetid: 33\ngfg: search-an-element-in-a-sorted-and-pivoted-array\ncompanies: [facebook]\ndifficulty: medium\nhackerrank: \ninterviewbit: rotated-sorted-array-search\nleetcode: search-in-rotated-sorted-array\nhellointerview: code/binary-search/search-in-rotated-sorted-array\n---\n\nThere is an integer array `nums` sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, \nnums is possibly rotated at an unknown pivot index `k (1 <= k < nums.length)` \nsuch that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0],nums[1], ..., nums[k-1]]` (0-indexed). \nFor example, `[0,1,2,4,5,6,7]` might be rotated at pivot index 3 and become `[4,5,6,7,0,1,2]`.\n\nGiven the array nums after the possible rotation and an integer `target`, return the index of target if it is in `nums`, or `-1` if it is not in nums.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) nums = [4,5,6,7,0,1,2]\n(int) target = 0\n```\n\n**Output:**\n```\n(int) 4\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [4,5,6,7,0,1,2]\n(int) target = 3\n```\n\n**Output:**\n```\n(int) -1\n```",
      "body": "There is an integer array `nums` sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, \nnums is possibly rotated at an unknown pivot index `k (1 <= k < nums.length)` \nsuch that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0],nums[1], ..., nums[k-1]]` (0-indexed). \nFor example, `[0,1,2,4,5,6,7]` might be rotated at pivot index 3 and become `[4,5,6,7,0,1,2]`.\n\nGiven the array nums after the possible rotation and an integer `target`, return the index of target if it is in `nums`, or `-1` if it is not in nums.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) nums = [4,5,6,7,0,1,2]\n(int) target = 0\n```\n\n**Output:**\n```\n(int) 4\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [4,5,6,7,0,1,2]\n(int) target = 3\n```\n\n**Output:**\n```\n(int) -1\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "int search(int* nums, int numsSize, int target) {\n    int left = 0, right = numsSize-1;\n    while(left <= right) {\n        int mid = left + (right - left)/2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target <= nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] <= target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int low = 0, high = nums.size() - 1, mid;\n        while(low <= high) {\n            mid = low + (high-low)/2;\n            cout<<low<<\" \"<<mid<<\" \"<<high<<endl;\n            if (nums[mid] == target) return mid;\n            if (nums[low] <= nums[mid]) {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid-1;\n                } else {\n                    low = mid+1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid+1;\n                } else {\n                    high = mid-1;\n                }\n            }\n        }\n        return -1;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "package search_in_rotated_sorted_array\n\nfunc search(nums []int, target int) int {\n\tlow, high := 0, len(nums)-1\n\tfor low <= high {\n\t\tmid := low + (high-low)/2\n\t\tif nums[mid] == target {\n\t\t\treturn mid\n\t\t}\n\t\tif nums[low] <= nums[mid] {\n\t\t\tif nums[low] <= target && target < nums[mid] {\n\t\t\t\thigh = mid-1\n\t\t\t} else {\n\t\t\t\tlow = mid+1\n\t\t\t}\n\t\t} else {\n\t\t\tif nums[mid] < target && target <= nums[high] {\n\t\t\t\tlow = mid+1\n\t\t\t} else {\n\t\t\t\thigh = mid-1\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int search(int[] nums, int target) {\n        int low = 0, high = nums.length-1;\n        while(low <= high) {\n            int mid = low + (high-low)/2;\n            if (nums[mid] == target) return mid;\n            if (nums[low] <= nums[mid]) {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid-1;\n                } else {\n                    low = mid+1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid+1;\n                } else {\n                    high = mid-1;\n                }\n            }\n        }\n        return -1;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if not nums: return -1\n        l = len(nums)\n        ll, ul = 0, l-1\n        while ll <= ul:\n            m = (ll + ul) // 2\n            print(ll, m, ul)\n            if nums[m] == target:\n                return m\n            if nums[ll] <= nums[m]:\n                if nums[ll] <= target <= nums[m]:\n                    ul = m - 1\n                else:\n                    ll = m + 1\n            else:\n                if nums[m] <= target <= nums[ul]:\n                    ll = m + 1\n                else:\n                    ul = m - 1\n            \n        return -1",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "search-suggestions-system": {
      "id": "search-suggestions-system",
      "title": "Search Suggestions System",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "string",
        "trie"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(ns)",
      "sc": "O(1)",
      "leetcode": "search-suggestions-system",
      "gfg": null,
      "leetid": 1268,
      "content": "---\nlayout: post\ntitle: Search Suggestions System\ntopics: [array, string, trie]\nlangs: [java]\ntc: O(ns)\nsc: O(1)\nleetid: 1268\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: search-suggestions-system\n---\n\nYou are given an array of strings `products` and a string `searchWord`.\n\nDesign a system that suggests at most three `product` names from products after each character of `searchWord` is typed. \nSuggested products should have common prefix with `searchWord`. \nIf there are more than three products with a common prefix return the three **lexicographically** minimums products.\n\nReturn a list of lists of the suggested products after each character of searchWord is typed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\nOutput: [\n[\"mobile\",\"moneypot\",\"monitor\"],\n[\"mobile\",\"moneypot\",\"monitor\"],\n[\"mouse\",\"mousepad\"],\n[\"mouse\",\"mousepad\"],\n[\"mouse\",\"mousepad\"]\n]\nExplanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"]\nAfter typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"]\nAfter typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"]\n```\n\n**Example 2:** \n```\nInput: products = [\"havana\"], searchWord = \"havana\"\nOutput: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n```\n\n**Example 3:**\n```\nInput: products = [\"havana\"], searchWord = \"tatiana\"\nOutput: [[],[],[],[],[],[],[]]\n```\n\n**Example 4:**\n```\nInput: products = [\"bags\",\"baggage\",\"banner\",\"box\",\"cloths\"], searchWord = \"bags\"\nOutput: [[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\"],[\"bags\"]]\n```",
      "body": "You are given an array of strings `products` and a string `searchWord`.\n\nDesign a system that suggests at most three `product` names from products after each character of `searchWord` is typed. \nSuggested products should have common prefix with `searchWord`. \nIf there are more than three products with a common prefix return the three **lexicographically** minimums products.\n\nReturn a list of lists of the suggested products after each character of searchWord is typed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\nOutput: [\n[\"mobile\",\"moneypot\",\"monitor\"],\n[\"mobile\",\"moneypot\",\"monitor\"],\n[\"mouse\",\"mousepad\"],\n[\"mouse\",\"mousepad\"],\n[\"mouse\",\"mousepad\"]\n]\nExplanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"]\nAfter typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"]\nAfter typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"]\n```\n\n**Example 2:** \n```\nInput: products = [\"havana\"], searchWord = \"havana\"\nOutput: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n```\n\n**Example 3:**\n```\nInput: products = [\"havana\"], searchWord = \"tatiana\"\nOutput: [[],[],[],[],[],[],[]]\n```\n\n**Example 4:**\n```\nInput: products = [\"bags\",\"baggage\",\"banner\",\"box\",\"cloths\"], searchWord = \"bags\"\nOutput: [[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\"],[\"bags\"]]\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<List<String>> suggestedProducts(String[] products, String searchWord) {\n        TrieNode root = new TrieNode();\n        for(String product: products) {\n            root.add(product);\n        }\n        int n = searchWord.length();\n        List<List<String>> res = new ArrayList<>();\n        for(int i=0; i<n; i++) {\n            char c = searchWord.charAt(i);\n            int pos = c - 'a';\n            List<String> list = new ArrayList<>();\n            if (root != null && root.children[pos] != null) {\n                PriorityQueue<String> pq = root.children[pos].top;\n                while(!pq.isEmpty()) list.add(0, pq.poll());\n                pq.addAll(list);\n            }\n            res.add(list);\n            if (root == null) continue;\n            root = root.children[pos];\n        }\n        return res;\n    }\n}\n\nclass TrieNode {\n    PriorityQueue<String> top;\n    TrieNode[] children;\n    boolean isEndWord;\n    static int MAX_SIZE = 3;\n    TrieNode() {\n        top = new PriorityQueue<>((a,b) -> b.compareTo(a));\n        children = new TrieNode[26];\n        isEndWord = false;\n    }\n\n    public void add(String s) {\n        TrieNode root = this;\n        int n = s.length();\n        for(int i=0; i<n; i++) {\n            char c = s.charAt(i);\n            int pos = c - 'a';\n            if (root.children[pos] == null) {\n                root.children[pos] = new TrieNode();\n            }\n            PriorityQueue<String> pq = root.children[pos].top;\n            if (pq.size() < MAX_SIZE) pq.offer(s);\n            else {\n                if (pq.peek().compareTo(s) > 0) {\n                    pq.poll();\n                    pq.offer(s);\n                }\n            }\n            root.children[pos].top = pq;\n            root = root.children[pos];\n        }\n        root.isEndWord = true;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "serialize-and-deserialize-binary-tree": {
      "id": "serialize-and-deserialize-binary-tree",
      "title": "Serialize and Deserialize Binary Tree",
      "difficulty": "hard",
      "companies": [
        "facebook",
        "google",
        "linkedin",
        "uber"
      ],
      "topics": [
        "string",
        "tree",
        "depth-first-search",
        "breadth-first-search",
        "design",
        "binary-tree"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "serialize-and-deserialize-binary-tree",
      "gfg": null,
      "leetid": 297,
      "content": "---\nlayout: post\ntitle: Serialize and Deserialize Binary Tree\ntopics: [string, tree, depth-first-search, breadth-first-search, design, binary-tree]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 297\ncompanies: [facebook, google, linkedin, uber]\ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: serialize-and-deserialize-binary-tree\n---\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n \n---\n## Test Cases\n**Example 1:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" />\n\n```\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n* The number of nodes in the tree is in the range `[0, 10<sup>4</sup>]`.\n* `-1000 <= Node.val <= 1000`\n\n        ",
      "body": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n \n---\n## Test Cases\n**Example 1:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" />\n\n```\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n* The number of nodes in the tree is in the range `[0, 10<sup>4</sup>]`.\n* `-1000 <= Node.val <= 1000`\n\n        ",
      "solutions": {
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb=new StringBuilder();\n        dfs(root,sb);\n        return sb.toString();\n    }\n\n    private void dfs(TreeNode x, StringBuilder sb) {\n        if (x==null) {\n            sb.append(\"null \");\n            return;\n        }\n        sb.append(String.valueOf(x.val));\n        sb.append(' ');\n        dfs(x.left,sb);\n        dfs(x.right,sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] node=data.split(\" \");\n        int[] d=new int[1];\n        return dfs(node,d);\n    }\n    private TreeNode dfs(String[] node, int[] d) {\n        if (node[d[0]].equals(\"null\")) {\n            d[0]++;\n            return null;\n        }\n        TreeNode x=new TreeNode(Integer.valueOf(node[d[0]]));\n        d[0]++;\n        x.left=dfs(node,d);\n        x.right=dfs(node,d);\n        return x;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n    def __init__(self):\n        self.separator = '#'\n        self.null = 'null'\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        ser = []\n        self._dfs(root, ser)\n        return self.separator.join(ser)\n\n    def _dfs(self, root, ser: []):\n        if root is None:\n            ser.append(self.null)\n            return\n        ser.append(f'{root.val}')\n        self._dfs(root.left, ser)\n        self._dfs(root.right, ser)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        parsed = data.split(self.separator)\n        index = [0]\n        return self._deser_dfs(parsed, index)\n\n    def _deser_dfs(self, parsed: [], index: []):\n        if parsed[index[0]] == self.null:\n            index[0] += 1\n            return None\n        node = TreeNode(parsed[index[0]])\n        index[0] += 1\n        node.left = self._deser_dfs(parsed, index)\n        node.right = self._deser_dfs(parsed, index)\n        return node\n\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "set-intersection-size-at-least-two": {
      "id": "set-intersection-size-at-least-two",
      "title": "Set Intersection Size At Least Two",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "greedy",
        "sorting"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nlogn)",
      "sc": "O(1)",
      "leetcode": "set-intersection-size-at-least-two",
      "gfg": null,
      "leetid": 757,
      "content": "---\nlayout: post\ntitle: Set Intersection Size At Least Two\ntopics: [array, greedy, sorting]\nlangs: [java]\ntc: O(nlogn)\nsc: O(1)\nleetid: 757\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: set-intersection-size-at-least-two\n---\n\nAn integer interval `[a, b]` (for integers `a < b`) is a set of all consecutive integers from `a` to `b`, including `a` and `b`.\n\nFind the minimum size of a set S such that for every integer interval A in `intervals`, \nthe intersection of S with A has a size of at least two.\n\n---\n## How to Solve\n\nFirst sort the intervals, with their ending points from low to high\n\nWe deal with the sorted intervals one by one.\n1. If there is no number in this interval being chosen before, we pick up 2 biggest number in this interval. \n(the biggest number have the most possibility to be used by next interval)\n2. If there is one number in this interval being chosen before, we pick up the biggest number in this interval.\n3. If there are already two numbers in this interval being chosen before, we can skip this interval since the requirement has been fulfilled.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) intervals = [[1,3],[1,4],[2,5],[3,5]]\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nConsider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.\nAlso, there isn't a smaller size set that fulfills the above condition.\nThus, we output the size of this set, which is 3.\n```\n\n---\n\n**Input:**\n```\n(int[]) intervals = [[1,2],[2,3],[2,4],[4,5]]\n```\n\n**Output:**\n```\n(int) 5\n```\n\n**Explanation:**\n```\nAn example of a minimum sized set is {1, 2, 3, 4, 5}.\n```",
      "body": "An integer interval `[a, b]` (for integers `a < b`) is a set of all consecutive integers from `a` to `b`, including `a` and `b`.\n\nFind the minimum size of a set S such that for every integer interval A in `intervals`, \nthe intersection of S with A has a size of at least two.\n\n---\n## How to Solve\n\nFirst sort the intervals, with their ending points from low to high\n\nWe deal with the sorted intervals one by one.\n1. If there is no number in this interval being chosen before, we pick up 2 biggest number in this interval. \n(the biggest number have the most possibility to be used by next interval)\n2. If there is one number in this interval being chosen before, we pick up the biggest number in this interval.\n3. If there are already two numbers in this interval being chosen before, we can skip this interval since the requirement has been fulfilled.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) intervals = [[1,3],[1,4],[2,5],[3,5]]\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nConsider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.\nAlso, there isn't a smaller size set that fulfills the above condition.\nThus, we output the size of this set, which is 3.\n```\n\n---\n\n**Input:**\n```\n(int[]) intervals = [[1,2],[2,3],[2,4],[4,5]]\n```\n\n**Output:**\n```\n(int) 5\n```\n\n**Explanation:**\n```\nAn example of a minimum sized set is {1, 2, 3, 4, 5}.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int intersectionSizeTwo(int[][] intervals) {\n        int largest = -1, second = -1, n = intervals.length, res = 0;\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n        for(int i=0; i<n; i++) {\n            int start = intervals[i][0], end = intervals[i][1];\n            if(start > largest) {\n                res += 2;\n                second = end - 1;\n                largest = end;\n            } else if (start > second) {\n                res++;\n                second = largest == end ? largest - 1 : largest;\n                largest = end;\n            }\n        }\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "set-matrix-zeroes": {
      "id": "set-matrix-zeroes",
      "title": "Set Matrix Zeroes",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "microsoft",
        "oracle"
      ],
      "topics": [
        "array",
        "hash-table",
        "matrix"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n<sup>2</sup>)",
      "sc": "O(1)",
      "leetcode": "set-matrix-zeroes",
      "gfg": null,
      "leetid": 73,
      "content": "---\nlayout: post\ntitle: Set Matrix Zeroes\ntopics: [array, hash-table, matrix]\nlangs: [java]\ntc: O(n<sup>2</sup>)\nsc: O(1)\nleetid: 73\ncompanies: [adobe, amazon, apple, bloomberg, facebook, microsoft, oracle]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: set-matrix-zeros\nleetcode: set-matrix-zeroes\n---\n\nGiven an `m x n` integer `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it in place.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" alt=\"image\" />\n\n```\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n```\n\n**Example 2:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" alt=\"Image\" />\n```\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n```",
      "body": "Given an `m x n` integer `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it in place.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" alt=\"image\" />\n\n```\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n```\n\n**Example 2:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" alt=\"Image\" />\n```\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        boolean rz = false, cz = false;\n        for(int i=0; i<n; i++) {\n            if (matrix[i][0] == 0) {\n                cz = true;\n                break;\n            }\n        }\n        for(int i=0; i<m; i++) {\n            if (matrix[0][i] == 0) {\n                rz = true;\n                break;\n            }\n        }\n        for(int i=1; i<n; i++) {\n            for(int j=1; j<m; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        for(int i=1; i<n; i++) {\n            for(int j=1; j<m; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        for(int i=0; i<n; i++) {\n            if (cz) matrix[i][0] = 0;\n        }\n        for(int j=0; j<m; j++) {\n            if (rz) matrix[0][j] = 0;\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "shortest-path-in-binary-matrix": {
      "id": "shortest-path-in-binary-matrix",
      "title": "Shortest Path in Binary Matrix",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "breadth-first-search",
        "matrix"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(1)",
      "sc": "O(1)",
      "leetcode": "shortest-path-in-binary-matrix",
      "gfg": null,
      "leetid": 1091,
      "content": "---\nlayout: post\ntitle: Shortest Path in Binary Matrix\ntopics: [array, breadth-first-search, matrix]\nlangs: [java]\ntc: O(1)\nsc: O(1)\nleetid: 1091\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: shortest-path-in-binary-matrix\n---\n\nGiven an `n x n` binary matrix `grid`, return the length of the shortest clear path in the matrix. If there is no clear path, return `-1`.\n\nA clear path in a binary matrix is a path from the top-left cell (i.e., (`0`, `0`)) to the bottom-right cell (i.e., (`n - 1`, `n - 1`)) such that:\n- All the visited cells of the path are 0. \n- All the adjacent cells of the path are 8-directionally connected (i.e., they are different, and they share an edge or a corner).\n\nThe length of a clear path is the number of visited cells of this path.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: grid = [[0,1],[1,0]]\nOutput: 2\n```\n\n**Example 2:**\n\n```\nInput: grid = [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\n```",
      "body": "Given an `n x n` binary matrix `grid`, return the length of the shortest clear path in the matrix. If there is no clear path, return `-1`.\n\nA clear path in a binary matrix is a path from the top-left cell (i.e., (`0`, `0`)) to the bottom-right cell (i.e., (`n - 1`, `n - 1`)) such that:\n- All the visited cells of the path are 0. \n- All the adjacent cells of the path are 8-directionally connected (i.e., they are different, and they share an edge or a corner).\n\nThe length of a clear path is the number of visited cells of this path.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: grid = [[0,1],[1,0]]\nOutput: 2\n```\n\n**Example 2:**\n\n```\nInput: grid = [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int shortestPathBinaryMatrix(int[][] grid) {\n        if (grid[0][0] == 1) return -1;\n        int n = grid.length, m = grid[0].length;\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0});\n        int steps = 1;\n        int[] dx = new int[]{-1,-1,-1,0,0,1,1,1};\n        int[] dy = new int[]{-1,0,1,-1,1,-1,0,1};\n        while(!q.isEmpty()) {\n            int qs = q.size();\n            for(int i=0; i<qs; i++) {\n                int[] first = q.poll();\n                if (grid[first[0]][first[1]] != 0) continue;\n                grid[first[0]][first[1]] = 1;\n                if (first[0] == n-1 && first[1] == m-1) {\n                    return steps;\n                }\n                for(int j=0; j<8; j++) {\n                    int nx = first[0] + dx[j], ny = first[1]+dy[j];\n                    if (nx>=0 && ny >=0 && nx<n && ny<m && grid[nx][ny] == 0) {\n                        q.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n            steps++;\n        }\n        return -1;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "simplify-path": {
      "id": "simplify-path",
      "title": "Simplify Path",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "string",
        "stack"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "simplify-path",
      "gfg": null,
      "leetid": 71,
      "content": "---\nlayout: post\ntitle: Simplify Path\ndifficulty: medium\ntopics: [string, stack]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\ncompanies: [facebook]\nleetid: 71\nleetcode: simplify-path\ngfg: \ninterviewbit: \nhackerrank: \n---\nYou are given an *absolute* path for a Unix-style file system, which always begins with a slash `'/'`. Your task is to transform this absolute path into its **simplified canonical path**.\nThe *rules* of a Unix-style file system are as follows:\n\t\n* A single period `'.'` represents the current directory.\n\t\n* A double period `'..'` represents the previous/parent directory.\n\t\n* Multiple consecutive slashes such as `'//'` and `'///'` are treated as a single slash `'/'`.\n\t\n* Any sequence of periods that does **not match** the rules above should be treated as a **valid directory or** **file ****name**. For example, `'...' `and `'....'` are valid directory or file names.\nThe simplified canonical path should follow these *rules*:\n\t\n* The path must start with a single slash `'/'`.\n\t\n* Directories within the path must be separated by exactly one slash `'/'`.\n\t\n* The path must not end with a slash `'/'`, unless it is the root directory.\n\t\n* The path must not have any single or double periods (`'.'` and `'..'`) used to denote current or parent directories.\nReturn the **simplified canonical path**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation:\nThe trailing slash should be removed.\n```\n\n**Example 2:**\n```\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation:\nMultiple consecutive slashes are replaced by a single one.\n```\n\n**Example 3:**\n```\nInput: path = \"/home/user/Documents/../Pictures\"\nOutput: \"/home/user/Pictures\"\nExplanation:\nA double period \"..\" refers to the directory up a level (the parent directory).\n```\n\n**Example 4:**\n```\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation:\nGoing one level up from the root directory is not possible.\n```\n\n**Example 5:**\n```\nInput: path = \"/.../a/../b/c/../d/./\"\nOutput: \"/.../b/d\"\nExplanation:\n\"...\" is a valid name for a directory in this problem.\n```\n \n**Constraints:**\n\t\n* `1 <= path.length <= 3000`\n\t\n* `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.\n\t\n* `path` is a valid absolute Unix path.\n\n",
      "body": "You are given an *absolute* path for a Unix-style file system, which always begins with a slash `'/'`. Your task is to transform this absolute path into its **simplified canonical path**.\nThe *rules* of a Unix-style file system are as follows:\n\t\n* A single period `'.'` represents the current directory.\n\t\n* A double period `'..'` represents the previous/parent directory.\n\t\n* Multiple consecutive slashes such as `'//'` and `'///'` are treated as a single slash `'/'`.\n\t\n* Any sequence of periods that does **not match** the rules above should be treated as a **valid directory or** **file ****name**. For example, `'...' `and `'....'` are valid directory or file names.\nThe simplified canonical path should follow these *rules*:\n\t\n* The path must start with a single slash `'/'`.\n\t\n* Directories within the path must be separated by exactly one slash `'/'`.\n\t\n* The path must not end with a slash `'/'`, unless it is the root directory.\n\t\n* The path must not have any single or double periods (`'.'` and `'..'`) used to denote current or parent directories.\nReturn the **simplified canonical path**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation:\nThe trailing slash should be removed.\n```\n\n**Example 2:**\n```\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation:\nMultiple consecutive slashes are replaced by a single one.\n```\n\n**Example 3:**\n```\nInput: path = \"/home/user/Documents/../Pictures\"\nOutput: \"/home/user/Pictures\"\nExplanation:\nA double period \"..\" refers to the directory up a level (the parent directory).\n```\n\n**Example 4:**\n```\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation:\nGoing one level up from the root directory is not possible.\n```\n\n**Example 5:**\n```\nInput: path = \"/.../a/../b/c/../d/./\"\nOutput: \"/.../b/d\"\nExplanation:\n\"...\" is a valid name for a directory in this problem.\n```\n \n**Constraints:**\n\t\n* `1 <= path.length <= 3000`\n\t\n* `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.\n\t\n* `path` is a valid absolute Unix path.\n\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String simplifyPath(String path) {\n        Stack<String> stack = new Stack<>();\n        Set<String> skip = new HashSet<>(Arrays.asList(\"..\",\".\",\"\"));\n        for(String dir: path.split(\"/\")) {\n            if (dir.equals(\"..\") && !stack.isEmpty()) stack.pop();\n            else if (!skip.contains(dir)) stack.push(dir);\n        }\n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()) {\n            sb.insert(0, stack.pop());\n            sb.insert(0, \"/\");\n        }\n        return sb.length() == 0 ? \"/\" : sb.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        split = path.split(\"/\")\n        for dr in split:\n            if dr == '.':\n                # do nothing\n                pass\n            elif dr == '..':\n                if len(stack) > 0:\n                    stack.pop()\n            elif dr == '':\n                # do nothing\n                pass\n            else:\n                stack.append(dr)\n        return f\"/{'/'.join(stack)}\"",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "single-number-ii": {
      "id": "single-number-ii",
      "title": "Single Number II",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "bit-manipulation"
      ],
      "langs": [
        "java",
        "cpp",
        "c"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "single-number-ii",
      "gfg": null,
      "leetid": 137,
      "content": "---\nlayout: post\ntitle: Single Number II\ntopics: [array, bit-manipulation]\nlangs: [java, cpp, c]\ntc: O(n)\nsc: O(1)\nleetid: 137\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: single-number-ii\n---\nGiven an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. *Find the single element and return it*.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [2,2,3,2]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 3 * 10<sup>4</sup>`\n\t\n* `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`\n\t\n* Each element in `nums` appears exactly **three times** except for one element which appears **once**.\n\n        ",
      "body": "Given an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. *Find the single element and return it*.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [2,2,3,2]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 3 * 10<sup>4</sup>`\n\t\n* `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`\n\t\n* Each element in `nums` appears exactly **three times** except for one element which appears **once**.\n\n        ",
      "solutions": {
        "c": {
          "language": "c",
          "code": "int singleNumber(int* nums, int size) {\n    int ones = 0, twos = 0;\n    for(int i=0; i<size; i++) {\n        ones = (ones ^ nums[i]) & ~twos;\n        twos = (twos ^ nums[i]) & ~ones;\n    }\n    return ones;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ones = 0, twos = 0;\n        for(int i=0; i<nums.size(); i++) {\n            ones = (ones ^ nums[i]) & ~twos;\n            twos = (twos ^ nums[i]) & ~ones;\n        }\n        return ones;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int singleNumber(int[] nums) {\n        int ones = 0, twos = 0;\n        for (int num : nums) {\n            ones = (ones ^ num) & ~twos;\n            twos = (twos ^ num) & ~ones;\n        }\n        return ones;\n    }\n\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "sliding-window-maximum": {
      "id": "sliding-window-maximum",
      "title": "Sliding Window Maximum",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "heap",
        "queue",
        "sliding-window"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(k)",
      "leetcode": "sliding-window-maximum",
      "gfg": null,
      "leetid": 239,
      "content": "---\nlayout: post\ntitle: Sliding Window Maximum\ntopics: [array, heap, queue, sliding-window]\nlangs: [java, py]\ntc: O(n)\nsc: O(k)\nleetid: 239\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: sliding-window-maximum\n---\n\nYou are given an array of integers nums, \nthere is a sliding window of size `k` which is moving from the very left of the array to the very right. \nYou can only see the `k` numbers in the window. \nEach time the sliding window moves right by one position.\n\nReturn the _max sliding window_.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [1,3,-1,-3,5,3,6,7]\n(int) k = 3\n```\n\n**Output:** \n```\n(int[]) [3,3,5,5,6,7]\n```\n\n**Explanation:**\n```\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [1]\n(int) k = 1\n```\n\n**Output:**\n```\n(int[]) [1]\n```",
      "body": "You are given an array of integers nums, \nthere is a sliding window of size `k` which is moving from the very left of the array to the very right. \nYou can only see the `k` numbers in the window. \nEach time the sliding window moves right by one position.\n\nReturn the _max sliding window_.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [1,3,-1,-3,5,3,6,7]\n(int) k = 3\n```\n\n**Output:** \n```\n(int[]) [3,3,5,5,6,7]\n```\n\n**Explanation:**\n```\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [1]\n(int) k = 1\n```\n\n**Output:**\n```\n(int[]) [1]\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        if (n == 0 || k == 0) {\n            return new int[0];\n        }\n        int[] result = new int[n - k + 1]; // number of windows\n        Deque<Integer> win = new ArrayDeque<>(); // stores indices\n\n        for (int i = 0; i < n; ++i) {\n            // remove indices that are out of bound\n            while (win.size() > 0 && win.peekFirst() <= i - k) {\n                win.pollFirst();\n            }\n            // remove indices whose corresponding values are less than nums[i]\n            while (win.size() > 0 && nums[win.peekLast()] < nums[i]) {\n                win.pollLast();\n            }\n            // add nums[i]\n            win.offerLast(i);\n            // add to result\n            if (i >= k - 1) {\n                result[i - k + 1] = nums[win.peekFirst()];\n            }\n        }\n        return result;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        if n == 0 or k == 0:\n            return []\n        res, window = [0]*(n-k+1), []\n        for i in range(n):\n            while window and window[0] <= i-k:\n                window.pop(0)\n            while window and nums[window[-1]] < nums[i]:\n                window.pop()\n            window.append(i)\n            if i >= k - 1:\n                res[i-k+1] = nums[window[0]]\n        return res",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "sort-colors": {
      "id": "sort-colors",
      "title": "Sort Colors",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "sorting",
        "two-pointers"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "sort-colors",
      "gfg": "sort-an-array-of-0s-1s-and-2s",
      "leetid": 75,
      "content": "---\nlayout: post\ntitle: Sort Colors\ntopics: [array, sorting, two-pointers]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 75\ncompanies: [facebook]\ngfg: sort-an-array-of-0s-1s-and-2s\ndifficulty: medium\nhackerrank: \ninterviewbit: sort-colors\nleetcode: sort-colors\nhellointerview: code/two-pointers/sort-colors\n---\n\nGiven an array `nums` with `n` objects colored red, white, or blue, \nsort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [2,0,2,1,1,0]\n```\n\n**Output:** \n```\n(int[]) [0,0,1,1,2,2]\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [2,0,1]\n```\n\n**Output:**\n```\n(int[]) [0,1,2]\n```\n",
      "body": "Given an array `nums` with `n` objects colored red, white, or blue, \nsort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [2,0,2,1,1,0]\n```\n\n**Output:** \n```\n(int[]) [0,0,1,1,2,2]\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [2,0,1]\n```\n\n**Output:**\n```\n(int[]) [0,1,2]\n```\n",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int n0 = -1, n1 = -1, n2 = -1;\n        for(int i=0; i<nums.size(); i++) {\n            if (nums[i] == 0) {\n                nums[++n2] = 2; nums[++n1] = 1; nums[++n0] = 0;\n            } else if (nums[i] == 1) {\n                nums[++n2] = 2; nums[++n1] = 1;\n            } else {\n                nums[++n2] = 2;\n            }\n        }\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public void sortColors(int[] nums) {\n        int n0 = -1, n1 = -1, n2 = -1;\n        for(int i =0; i<nums.length; i++) {\n            if (nums[i] == 0) {\n                nums[++n2] = 2; nums[++n1] = 1; nums[++n0] = 0;\n            }\n            else if (nums[i] == 1) {\n                nums[++n2] = 2; nums[++n1] = 1;\n            }\n            else if (nums[i] == 2) {\n                nums[++n2] = 2;\n            }\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "sort-list": {
      "id": "sort-list",
      "title": "Sort List",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "divide-and-conquer",
        "linked-list",
        "sorting",
        "two-pointers"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(nlogn)",
      "sc": "O(1)",
      "leetcode": "sort-list",
      "gfg": null,
      "leetid": 148,
      "content": "---\nlayout: post\ntitle: Sort List\ntopics: [divide-and-conquer, linked-list, sorting, two-pointers]\nlangs: [java, cpp]\ntc: O(nlogn)\nsc: O(1)\nleetid: 148\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: sort-list\n---\n\nGiven the `head` of a linked list, return the list after sorting it in ascending order.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n```\n\n**Example 2:**\n```\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n```",
      "body": "Given the `head` of a linked list, return the list after sorting it in ascending order.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n```\n\n**Example 2:**\n```\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) return head;\n        ListNode *slow = head, *fast = head;\n        while(fast->next != nullptr && fast->next->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        ListNode *next = slow->next;\n        slow->next = nullptr;\n        ListNode *first = sortList(head);\n        ListNode *second = sortList(next);\n        return merge(first, second);\n    }\n    \n    ListNode* merge(ListNode* first, ListNode* second) {\n        ListNode *prev = new ListNode();\n        ListNode *head = prev;\n        while(first != nullptr || second != nullptr) {\n            if (first == nullptr) {\n                prev->next = second;\n                second = second->next;\n            }\n            else if (second == nullptr) {\n                prev->next = first;\n                first = first->next;\n            } else {\n                if (first->val < second->val) {\n                    prev->next = first;\n                    first = first->next;\n                } else {\n                    prev->next = second;\n                    second = second->next;\n                }\n            }\n            prev = prev->next;\n            prev->next = nullptr;\n        }\n        return head->next;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode slow = head, fast = head;\n        while(fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        ListNode next = slow.next;\n        slow.next = null;\n        ListNode first = sortList(head);\n        ListNode second = sortList(next);\n        return merge(first, second);\n    }\n\n    private ListNode merge(ListNode first, ListNode second) {\n        ListNode prev = new ListNode();\n        ListNode head = prev;\n        while(first != null || second != null) {\n            if (first == null) {\n                prev.next = second;\n                second = second.next;\n            }\n            else if (second == null) {\n                prev.next = first;\n                first = first.next;\n            } else {\n                if (first.val < second.val) {\n                    prev.next = first;\n                    first = first.next;\n                } else {\n                    prev.next = second;\n                    second = second.next;\n                }\n            }\n            prev = prev.next;\n            prev.next = null;\n        }\n        return head.next;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "split-array-largest-sum": {
      "id": "split-array-largest-sum",
      "title": "Split Array Largest Sum",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "dynamic-programming",
        "greedy"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n<sup>2</sup>m)",
      "sc": "O(nm)",
      "leetcode": "split-array-largest-sum",
      "gfg": null,
      "leetid": 410,
      "content": "---\nlayout: post\ntitle: Split Array Largest Sum\ntopics: [array, dynamic-programming, greedy]\nlangs: [java]\ntc: O(n<sup>2</sup>m)\nsc: O(nm)\nleetid: 410\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: split-array-largest-sum\n---\n\nGiven an array nums which consists of non-negative integers and an integer `m`, \nyou can split the array into `m` non-empty continuous subarrays.\n\nWrite an algorithm to minimize the largest sum among these `m` subarrays.\n\n---\n\n## How to Solve\n\n1. Fill the array `prefixSum`. The i<sup>th</sup> index of `prefixSum` will have the sum of integers in nums in the range `[0, i - 1]` with `prefix[0] = 0`.\n2. Initialize an array memo where `memo[currIndex][subarrayCount]` will store the result for the subproblem `(currIndex, subarrayCount)`. \n3. We need to find the value of `memo[0][m]` which represents the minimum largest subarray sum starting at index `0` with `m` subarrays. \n   1. But we only know what the result will be for the base cases. \n   2. To fill the memo array, we will iterate subarrayCount over the range `[1, m]` (starting at `1` because that is our base case) and iterate `currIndex` over the range `[0, n - 1]`.\n4. For each value of `subarrayCount` and `currIndex`, we will update `memo[subarrayCount][currIndex]`:\n   1. As the sum of the elements between `currIndex` and the end of the array if we are at a base case (`subarrayCount` equals 1).\n   2. Otherwise, we will use the recurrence relation and the results from previously solved subproblems to calculate `memo[subarrayCount][currIndex]`.\n5. Return the value stored at `memo[0][m]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [7,2,5,10,8], m = 2\nOutput: 18\nExplanation:\nThere are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8],\nwhere the largest sum among the two subarrays is only 18.\n```\n\n**Example 2:** \n```\nInput: nums = [1,2,3,4,5], m = 2\nOutput: 9\n```\n\n**Example 3:**\n```\nInput: nums = [1,4,4], m = 3\nOutput: 4\n```",
      "body": "Given an array nums which consists of non-negative integers and an integer `m`, \nyou can split the array into `m` non-empty continuous subarrays.\n\nWrite an algorithm to minimize the largest sum among these `m` subarrays.\n\n---\n\n## How to Solve\n\n1. Fill the array `prefixSum`. The i<sup>th</sup> index of `prefixSum` will have the sum of integers in nums in the range `[0, i - 1]` with `prefix[0] = 0`.\n2. Initialize an array memo where `memo[currIndex][subarrayCount]` will store the result for the subproblem `(currIndex, subarrayCount)`. \n3. We need to find the value of `memo[0][m]` which represents the minimum largest subarray sum starting at index `0` with `m` subarrays. \n   1. But we only know what the result will be for the base cases. \n   2. To fill the memo array, we will iterate subarrayCount over the range `[1, m]` (starting at `1` because that is our base case) and iterate `currIndex` over the range `[0, n - 1]`.\n4. For each value of `subarrayCount` and `currIndex`, we will update `memo[subarrayCount][currIndex]`:\n   1. As the sum of the elements between `currIndex` and the end of the array if we are at a base case (`subarrayCount` equals 1).\n   2. Otherwise, we will use the recurrence relation and the results from previously solved subproblems to calculate `memo[subarrayCount][currIndex]`.\n5. Return the value stored at `memo[0][m]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [7,2,5,10,8], m = 2\nOutput: 18\nExplanation:\nThere are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8],\nwhere the largest sum among the two subarrays is only 18.\n```\n\n**Example 2:** \n```\nInput: nums = [1,2,3,4,5], m = 2\nOutput: 9\n```\n\n**Example 3:**\n```\nInput: nums = [1,4,4], m = 3\nOutput: 4\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int splitArray(int[] nums, int m) {\n        int n = nums.length;\n        int[][] memo = new int[n+1][m+1];\n        int[] prefixSum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        for (int subarrayCount = 1; subarrayCount <= m; subarrayCount++) {\n            for (int currIndex = 0; currIndex < n; currIndex++) {\n                if (subarrayCount == 1) {\n                    memo[currIndex][subarrayCount] = prefixSum[n] - prefixSum[currIndex];\n                    continue;\n                }\n\n                int minimumLargestSplitSum = Integer.MAX_VALUE;\n                for (int i = currIndex; i <= n - subarrayCount; i++) {\n                    int firstSplitSum = prefixSum[i + 1] - prefixSum[currIndex];\n                    int largestSplitSum = Math.max(firstSplitSum, memo[i + 1][subarrayCount - 1]);\n                    minimumLargestSplitSum = Math.min(minimumLargestSplitSum, largestSplitSum);\n                    if (firstSplitSum >= minimumLargestSplitSum) {\n                        break;\n                    }\n                }\n                memo[currIndex][subarrayCount] = minimumLargestSplitSum;\n            }\n        }\n\n        return memo[0][m];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "string-to-integer-atoi": {
      "id": "string-to-integer-atoi",
      "title": "String to Integer Atoi",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "string"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "string-to-integer-atoi",
      "gfg": null,
      "leetid": 8,
      "content": "---\nlayout: post\ntitle: String to Integer Atoi\ntopics: [string]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 8\ncompanies: [facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: string-to-integer-atoi\n---\n\nImplement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n\nThe algorithm for myAtoi(string s) is as follows:\n1. Read in and ignore any leading whitespace. \n2. Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. \n3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. \n4. Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). \n5. If the integer is out of the `32`-bit signed integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -2<sup>31</sup> should be clamped to -2<sup>31</sup>, and integers greater than 2<sup>31</sup> - 1 should be clamped to 2<sup>31</sup> - 1. \n6. Return the integer as the final result.\n\n_**Note:**_\n- Only the space character ' ' is considered a whitespace character.\n- Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-2^31, 2^31 - 1], the final result is 42.\n```\n\n**Example 2:** \n```\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-2^31, 2^31 - 1], the final result is -42.\n```\n\n**Example 3:**\n```\nInput: s = \"4193 with words 54\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.\n```",
      "body": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n\nThe algorithm for myAtoi(string s) is as follows:\n1. Read in and ignore any leading whitespace. \n2. Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. \n3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. \n4. Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). \n5. If the integer is out of the `32`-bit signed integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -2<sup>31</sup> should be clamped to -2<sup>31</sup>, and integers greater than 2<sup>31</sup> - 1 should be clamped to 2<sup>31</sup> - 1. \n6. Return the integer as the final result.\n\n_**Note:**_\n- Only the space character ' ' is considered a whitespace character.\n- Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-2^31, 2^31 - 1], the final result is 42.\n```\n\n**Example 2:** \n```\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-2^31, 2^31 - 1], the final result is -42.\n```\n\n**Example 3:**\n```\nInput: s = \"4193 with words 54\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        int n = s.length();\n        if (n==0) return 0;\n        int i=0;\n        while(i<n && s[i] == ' ') {\n            i++;\n        }\n        if (i==n) return 0;\n        bool isneg = false;\n        if (s[i] != '-' && s[i] != '+' && s[i] < '0' && s[i] > '9') {\n            return 0;\n        }\n        if (s[i] == '-') {\n            isneg = true;\n            i++;\n        }\n        else if (s[i] == '+') {\n            i++;\n        }\n        long res = 0;\n        while(i<n && s[i] >= '0' && s[i] <= '9') {\n            res = res*10 + s[i] - '0';\n            if (res > INT_MAX) {\n                break;\n            }\n            i++;\n        }\n        res = isneg ? (-res > INT_MIN ? -res : INT_MIN) : (res < INT_MAX ? res : INT_MAX);\n        return (int) res;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int myAtoi(String s) {\n        int n = s.length();\n        if (n==0) return 0;\n        int i=0;\n        while(i<n && s.charAt(i) == ' ') {\n            i++;\n        }\n        if (i==n) return 0;\n        boolean isneg = false;\n        if (s.charAt(i) != '-' && s.charAt(i) != '+' && s.charAt(i) < '0' && s.charAt(i) > '9') {\n            return 0;\n        }\n        if (s.charAt(i) == '-') {\n            isneg = true;\n            i++;\n        }\n        else if (s.charAt(i) == '+') {\n            i++;\n        }\n        long res = 0;\n        while(i<n && s.charAt(i) >= '0' && s.charAt(i) <= '9') {\n            res = res*10 + s.charAt(i) - '0';\n            if (res > Integer.MAX_VALUE) {\n                break;\n            }\n            i++;\n        }\n        res = isneg ? Math.max(-res, Integer.MIN_VALUE) : Math.min(res, Integer.MAX_VALUE);\n        return (int) res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "subarray-sum-equals-k": {
      "id": "subarray-sum-equals-k",
      "title": "Subarray Sum Equals K",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "hash-table"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "subarray-sum-equals-k",
      "gfg": null,
      "leetid": 560,
      "content": "---\nlayout: post\ntitle: Subarray Sum Equals K\ntopics: [array, hash-table]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 560\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: subarray-sum-equals-k\nmetacareers: 840934449713537\n---\n\nGiven an array of integers nums and an integer `k`, return the total number of continuous subarray whose sum equals to `k`.\n\n---\n## How to Solve\n\nThe idea behind this approach is as follows: \n\nIf the cumulative sum(represented by `sum[i]` for sum up to i<sup>th</sup> index) up to two indices is the same, \nthe sum of the elements lying in between those indices is zero. \nExtending the same thought further, if the cumulative sum up to two indices, say `i` and `j` is at a difference of `k` \ni.e. `if sum[i] - sum[j] = k`, the sum of elements lying between indices `i` and `j` is `k`.\n\nBased on these thoughts, we make use of a hashmap `map` which is used to store the cumulative sum up to all the indices possible along with the number of times the same sum occurs. \nWe store the data in the form: `(sum_i, no. of occurrences of sum_i)`. \nWe traverse over the array `nums` and keep on finding the cumulative sum. \nEvery time we encounter a new sum, we make a new entry in the hashmap corresponding to that sum. \nIf the same sum occurs again, we increment the count corresponding to that sum in the hashmap. \nFurther, for every sum encountered, we also determine the number of times the sum `sum-k` has occurred already, \nsince it will determine the number of times a subarray with sum `k` has occurred up to the current index. \nWe increment the `count` by the same amount.\n\nAfter the complete array has been traversed, the `count` gives the required result.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums = [1,1,1], k = 2\nOutput: 2\n```\n\n**Example 2:**\n```\nInput: nums = [1,2,3], k = 3\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= nums.length <= 2 * 104`\n* `-1000 <= nums[i] <= 1000`\n* `-107 <= k <= 107`",
      "body": "Given an array of integers nums and an integer `k`, return the total number of continuous subarray whose sum equals to `k`.\n\n---\n## How to Solve\n\nThe idea behind this approach is as follows: \n\nIf the cumulative sum(represented by `sum[i]` for sum up to i<sup>th</sup> index) up to two indices is the same, \nthe sum of the elements lying in between those indices is zero. \nExtending the same thought further, if the cumulative sum up to two indices, say `i` and `j` is at a difference of `k` \ni.e. `if sum[i] - sum[j] = k`, the sum of elements lying between indices `i` and `j` is `k`.\n\nBased on these thoughts, we make use of a hashmap `map` which is used to store the cumulative sum up to all the indices possible along with the number of times the same sum occurs. \nWe store the data in the form: `(sum_i, no. of occurrences of sum_i)`. \nWe traverse over the array `nums` and keep on finding the cumulative sum. \nEvery time we encounter a new sum, we make a new entry in the hashmap corresponding to that sum. \nIf the same sum occurs again, we increment the count corresponding to that sum in the hashmap. \nFurther, for every sum encountered, we also determine the number of times the sum `sum-k` has occurred already, \nsince it will determine the number of times a subarray with sum `k` has occurred up to the current index. \nWe increment the `count` by the same amount.\n\nAfter the complete array has been traversed, the `count` gives the required result.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums = [1,1,1], k = 2\nOutput: 2\n```\n\n**Example 2:**\n```\nInput: nums = [1,2,3], k = 3\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= nums.length <= 2 * 104`\n* `-1000 <= nums[i] <= 1000`\n* `-107 <= k <= 107`",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int subarraySum(int[] nums, int k) {\n        int count = 0, sum = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, 1);\n        for(int i=0; i<nums.length; i++) {\n            sum += nums[i];\n            if (map.containsKey(sum - k)) {\n                count += map.get(sum - k);\n            }\n            map.put(sum, map.getOrDefault(sum, 0)+1);\n        }\n        return count;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        mp, sm, count = {}, 0, 0\n        mp[0] = 1\n        for i in range(0, len(nums)):\n            sm += nums[i]\n            if sm-k in mp:\n                count += mp[sm - k]\n            mp[sm] = mp.get(sm, 0) + 1\n        return count",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "subsets": {
      "id": "subsets",
      "title": "Subsets",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "amazon",
        "bloomberg",
        "facebook",
        "goldman",
        "google",
        "twitter"
      ],
      "topics": [
        "array",
        "backtracking"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n2<sup>n</sup>)",
      "sc": "O(n)",
      "leetcode": "subsets",
      "gfg": null,
      "leetid": 78,
      "content": "---\nlayout: post\ntitle: Subsets\ntopics: [array, backtracking]\nlangs: [java, cpp]\ntc: O(n2<sup>n</sup>)\nsc: O(n)\nleetid: 78\ncompanies: [adobe, amazon, bloomberg, facebook, goldman, google, twitter]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: subsets\n---\n\nGiven an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**Example 2:** \n```\nInput: nums = [0]\nOutput: [[],[0]]\n```",
      "body": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**Example 2:** \n```\nInput: nums = [0]\nOutput: [[],[0]]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> result;\n        vector<int> subset = {};\n        backtrack(nums, result, subset, 0);\n        return result;\n    }\n\n    void backtrack(vector<int>& nums, vector<vector<int>>& result, vector<int>& subset, int pos) {\n        result.push_back(subset);\n        for(int i=pos; i<nums.size(); i++) {\n            subset.push_back(nums[i]);\n            backtrack(nums, result, subset, i+1);\n            subset.pop_back();\n        }\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        backtrack(nums, res, new ArrayList<>(), 0);\n        return res;\n    }\n\n    private void backtrack(int[] nums, List<List<Integer>> res, List<Integer> subset, int pos) {\n        res.add(new ArrayList<>(subset));\n        for(int i=pos; i<nums.length; i++) {\n            subset.add(nums[i]);\n            backtrack(nums, res, subset, i+1);\n            subset.remove(subset.size() - 1);\n        }\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "super-egg-drop": {
      "id": "super-egg-drop",
      "title": "Super Egg Drop",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "binary-search",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(KlogN)",
      "sc": "O(NK)",
      "leetcode": "super-egg-drop",
      "gfg": null,
      "leetid": 887,
      "content": "---\nlayout: post\ntitle: Super Egg Drop\ntopics: [binary-search, dynamic-programming]\nlangs: [java, py, cpp]\ntc: O(KlogN)\nsc: O(NK)\nleetid: 887\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: super-egg-drop\n---\n\nYou are given `K` identical eggs and you have access to a building with `N` floors labeled from `1` to `N`.\n\nYou know that there exists a floor `F` where `0 <= F <= N` such that any egg dropped at a floor higher than `F` will break, \nand any egg dropped at or below floor `F` will not break.\n\nEach move, \nyou may take an unbroken egg and drop it from any floor `X` (where `1 <= X <= N`). \nIf the egg breaks, you can no longer use it. \nHowever, if the egg does not break, you may **reuse** it in future moves.\n\nReturn the **_minimum number of moves_** that you need to determine with certainty what the value of `F` is.\n\n---\n\n## How to Solve\n\nConsider this problem in a different way:\n`dp[M][K]` means that, given `K` eggs and `M` moves,\nwhat is the maximum number of floor that we can check.\n\nThe dp equation is:\n```\ndp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1,\n```\n\nwhich means we take `1` move to a floor,\nif egg breaks, then we can check `dp[m - 1][k - 1]` floors.\nif egg doesn't breaks, then we can check `dp[m - 1][k]` floors.\n\n`dp[m][k]` is the number of combinations, and it increases exponentially to `N`\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int) k = 1\n(int) n = 2\n```\n\n**Output:** \n```\n(int) 2\n```\n\n**Explanation:**\n```\nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n```\n\n---\n\n**Input:** \n```\n(int) k = 2\n(int) n = 6\n```\n\n**Output:** \n```\n(int) 3\n```\n\n---\n\n**Input:**\n```\n(int) k = 3\n(int) n = 14\n```\n\n**Output:**\n```\n(int) 4\n```\n",
      "body": "You are given `K` identical eggs and you have access to a building with `N` floors labeled from `1` to `N`.\n\nYou know that there exists a floor `F` where `0 <= F <= N` such that any egg dropped at a floor higher than `F` will break, \nand any egg dropped at or below floor `F` will not break.\n\nEach move, \nyou may take an unbroken egg and drop it from any floor `X` (where `1 <= X <= N`). \nIf the egg breaks, you can no longer use it. \nHowever, if the egg does not break, you may **reuse** it in future moves.\n\nReturn the **_minimum number of moves_** that you need to determine with certainty what the value of `F` is.\n\n---\n\n## How to Solve\n\nConsider this problem in a different way:\n`dp[M][K]` means that, given `K` eggs and `M` moves,\nwhat is the maximum number of floor that we can check.\n\nThe dp equation is:\n```\ndp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1,\n```\n\nwhich means we take `1` move to a floor,\nif egg breaks, then we can check `dp[m - 1][k - 1]` floors.\nif egg doesn't breaks, then we can check `dp[m - 1][k]` floors.\n\n`dp[m][k]` is the number of combinations, and it increases exponentially to `N`\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int) k = 1\n(int) n = 2\n```\n\n**Output:** \n```\n(int) 2\n```\n\n**Explanation:**\n```\nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n```\n\n---\n\n**Input:** \n```\n(int) k = 2\n(int) n = 6\n```\n\n**Output:** \n```\n(int) 3\n```\n\n---\n\n**Input:**\n```\n(int) k = 3\n(int) n = 14\n```\n\n**Output:**\n```\n(int) 4\n```\n",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int superEggDrop(int K, int N) {\n        vector<vector<int>> dp(N + 1, vector<int>(K + 1, 0));\n        int m = 0;\n        while (dp[m][K] < N) {\n            m++;\n            for (int k = 1; k <= K; ++k)\n                dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1;\n        }\n        return m;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int superEggDrop(int K, int N) {\n        int[][] dp = new int[N + 1][K + 1];\n        int m = 0;\n        while (dp[m][K] < N) {\n            ++m;\n            for (int k = 1; k <= K; ++k)\n                dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1;\n        }\n        return m;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0] * (K + 1) for i in range(N + 1)]\n        for m in range(1, N + 1):\n            for k in range(1, K + 1):\n                dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1\n            if dp[m][K] >= N: return m",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "swap-nodes-in-pairs": {
      "id": "swap-nodes-in-pairs",
      "title": "Swap Nodes in Pairs",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "linked-list",
        "recursion"
      ],
      "langs": [
        "java",
        "cpp",
        "py",
        "c",
        "go"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "swap-nodes-in-pairs",
      "gfg": null,
      "leetid": 24,
      "content": "---\nlayout: post\ntitle: Swap Nodes in Pairs\ntopics: [linked-list, recursion]\nlangs: [java, cpp, py, c, go]\ntc: O(n)\nsc: O(1)\nleetid: 24\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: swap-nodes-in-pairs\n---\n\nGiven a linked list, swap every two adjacent nodes and return its head. \nYou must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\nExplanation:\n1->2->3->4      ->     2->1->4->3\n```\n\n**Example 2:** \n```\nInput: head = []\nOutput: []\n```",
      "body": "Given a linked list, swap every two adjacent nodes and return its head. \nYou must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\nExplanation:\n1->2->3->4      ->     2->1->4->3\n```\n\n**Example 2:** \n```\nInput: head = []\nOutput: []\n```",
      "solutions": {
        "c": {
          "language": "c",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\n\nstruct ListNode* swapPairs(struct ListNode* head){\n    if (head == NULL || head->next == NULL) return head;\n    struct ListNode *l1 = head, *l2 = head->next;\n    l1->next = l2->next;\n    l2->next = l1;\n    l1->next = swapPairs(l1->next);\n    return l2;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == NULL || head->next == NULL) return head;\n        ListNode *l1 = head, *l2 = head->next;\n        l1->next = l2->next;\n        l2->next = l1;\n        l1->next = swapPairs(l1->next);\n        return l2;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "go": {
          "language": "go",
          "code": "package swap_nodes_in_pairs\n\ntype ListNode struct {\n\tVal int\n\tNext *ListNode\n}\n\nfunc swapPairs(head *ListNode) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn head\n\t}\n\tl1 := head\n\tl2 := head.Next\n\tl1.Next = l2.Next\n\tl2.Next = l1\n\tl1.Next = swapPairs(l1.Next)\n\treturn l2\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode l1 = head, l2 = head.next;\n        l1.next = l2.next;\n        l2.next = l1;\n        l1.next = swapPairs(l1.next);\n        return l2;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import Optional\n\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        l1, l2 = head, head.next\n        l1.next = l2.next\n        l2.next = l1\n        l1.next = self.swapPairs(l1.next)\n        return l2",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "task-scheduler": {
      "id": "task-scheduler",
      "title": "Task Scheduler",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "greedy",
        "hash-table"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "task-scheduler",
      "gfg": null,
      "leetid": 621,
      "content": "---\nlayout: post\ntitle: Task Scheduler\ntopics: [array, greedy, hash-table]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 621\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: task-scheduler\n---\n\nGiven a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. \nTasks could be done in any order. \nEach task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer `n` that represents the cool-down period between two same tasks (the same letter in the array), \nthat is that there must be at least `n` units of time between any two same tasks.\n\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\nOutput: 8\nExplanation: \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.\n```\n\n**Example 2:** \n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\nOutput: 6\nExplanation: On this case any permutation of size 6 would work since n = 0.\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\nAnd so on.\n```\n\n**Example 2:**\n```\nInput: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\nOutput: 16\nExplanation: \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n```",
      "body": "Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. \nTasks could be done in any order. \nEach task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer `n` that represents the cool-down period between two same tasks (the same letter in the array), \nthat is that there must be at least `n` units of time between any two same tasks.\n\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\nOutput: 8\nExplanation: \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.\n```\n\n**Example 2:** \n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\nOutput: 6\nExplanation: On this case any permutation of size 6 would work since n = 0.\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\nAnd so on.\n```\n\n**Example 2:**\n```\nInput: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\nOutput: 16\nExplanation: \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        Map<Character, Task> map = new HashMap<>();\n        for(char c: tasks) {\n            map.putIfAbsent(c, new Task(0));\n            map.get(c).freq++;\n        }\n\n        PriorityQueue<Task> pq = new PriorityQueue<>((a, b) -> b.freq - a.freq);\n        Queue<Task> cooling = new LinkedList<>();\n        pq.addAll(map.values());\n        int timer = 0;\n        while(!pq.isEmpty() || !cooling.isEmpty()) {\n            if (pq.isEmpty()) timer = cooling.peek().lastUsed + n + 1;\n            while(!cooling.isEmpty() && cooling.peek().lastUsed + n < timer) {\n                pq.offer(cooling.poll());\n            }\n            Task task = pq.poll();\n            task.lastUsed = timer++;\n            task.freq--;\n\n            if (task.freq > 0) cooling.offer(task);\n        }\n        return timer;\n    }\n}\n\nclass Task {\n    int freq;\n    int lastUsed;\n    Task(int freq) {\n        this.freq = freq;\n        lastUsed = -1;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "text-justification": {
      "id": "text-justification",
      "title": "Text Justification",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "array",
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nm)",
      "sc": "O(n)",
      "leetcode": "text-justification",
      "gfg": "justify-the-given-text-based-on-the-given-width-of-each-line",
      "leetid": 68,
      "content": "---\nlayout: post\ntitle: Text Justification\ntopics: [array, string]\nlangs: [java]\ntc: O(nm)\nsc: O(n)\nleetid: 68\ncompanies: [facebook]\ngfg: justify-the-given-text-based-on-the-given-width-of-each-line\ndifficulty: hard\nhackerrank: \ninterviewbit: \nleetcode: text-justification\n---\n\nGiven an array of strings `words` and a width `maxWidth`, \nformat the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; \nthat is, pack as many words as you can in each line. \nPad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\n\nExtra spaces between `words` should be distributed as evenly as possible. \nIf the number of spaces on a line does not divide evenly between `words`, \nthe empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified and no extra space is inserted between words.\n\nNote:\n\nA `word` is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed `maxWidth`.\nThe input array `words` contains at least one word.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n```\n\n**Example 2:** \n```\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified becase it contains only one word.\n```\n\n**Example 3:**\n```\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n```",
      "body": "Given an array of strings `words` and a width `maxWidth`, \nformat the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; \nthat is, pack as many words as you can in each line. \nPad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\n\nExtra spaces between `words` should be distributed as evenly as possible. \nIf the number of spaces on a line does not divide evenly between `words`, \nthe empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified and no extra space is inserted between words.\n\nNote:\n\nA `word` is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed `maxWidth`.\nThe input array `words` contains at least one word.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n```\n\n**Example 2:** \n```\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified becase it contains only one word.\n```\n\n**Example 3:**\n```\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        int left = 0; List<String> result = new ArrayList<>();\n\n        while (left < words.length) {\n            int right = findRight(left, words, maxWidth);\n            result.add(justify(left, right, words, maxWidth));\n            left = right + 1;\n        }\n\n        return result;\n    }\n\n    private int findRight(int left, String[] words, int maxWidth) {\n        int right = left;\n        int sum = words[right++].length();\n\n        while (right < words.length && (sum + 1 + words[right].length()) <= maxWidth)\n            sum += 1 + words[right++].length();\n\n        return right - 1;\n    }\n\n    private String justify(int left, int right, String[] words, int maxWidth) {\n        if (right - left == 0) return padResult(words[left], maxWidth);\n\n        boolean isLastLine = right == words.length - 1;\n        int numSpaces = right - left;\n        int totalSpace = maxWidth - wordsLength(left, right, words);\n\n        String space = isLastLine ? \" \" : blank(totalSpace / numSpaces);\n        int remainder = isLastLine ? 0 : totalSpace % numSpaces;\n\n        StringBuilder result = new StringBuilder();\n        for (int i = left; i <= right; i++)\n            result.append(words[i])\n                    .append(space)\n                    .append(remainder-- > 0 ? \" \" : \"\");\n\n        return padResult(result.toString().trim(), maxWidth);\n    }\n\n    private int wordsLength(int left, int right, String[] words) {\n        int wordsLength = 0;\n        for (int i = left; i <= right; i++) wordsLength += words[i].length();\n        return wordsLength;\n    }\n\n    private String padResult(String result, int maxWidth) {\n        return result + blank(maxWidth - result.length());\n    }\n\n    private String blank(int length) {\n        return new String(new char[length]).replace('\\0', ' ');\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "the-skyline-problem": {
      "id": "the-skyline-problem",
      "title": "The Skyline Problem",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "divide-and-conquer",
        "heap"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nlogn)",
      "sc": "O(n)",
      "leetcode": "the-skyline-problem",
      "gfg": null,
      "leetid": 218,
      "content": "---\nlayout: post\ntitle: The Skyline Problem\ntopics: [array, divide-and-conquer, heap]\nlangs: [java]\ntc: O(nlogn)\nsc: O(n)\nleetid: 218\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: the-skyline-problem\n---\n\nA city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. \nGiven the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n\nThe geometric information of each building is given in the array `buildings` where\n<pre class=\"highlight\">\n<code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>\n</pre>\n\n\n- left<sub>i</sub> is the `x` coordinate of the left edge of the ith building.\n- right<sub>i</sub> is the `x` coordinate of the right edge of the ith building.\n- height<sub>i</sub> is the height of the ith building.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nThe skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. \nEach key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, \nwhich always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. \nAny ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\nNote: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[][]) buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n```\n\n**Output:** \n```\n(int[][]) [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n```",
      "body": "A city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. \nGiven the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n\nThe geometric information of each building is given in the array `buildings` where\n<pre class=\"highlight\">\n<code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>\n</pre>\n\n\n- left<sub>i</sub> is the `x` coordinate of the left edge of the ith building.\n- right<sub>i</sub> is the `x` coordinate of the right edge of the ith building.\n- height<sub>i</sub> is the height of the ith building.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nThe skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. \nEach key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, \nwhich always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. \nAny ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\nNote: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[][]) buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n```\n\n**Output:** \n```\n(int[][]) [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        int totalBuildings = buildings.length;\n        BuildingPoint[] buildingPoints = new BuildingPoint[totalBuildings*2];\n        int index = 0;\n        for(int[] building: buildings) {\n            buildingPoints[index++] = new BuildingPoint(building[0], building[2], true);\n            buildingPoints[index++] = new BuildingPoint(building[1], building[2], false);\n        }\n        Arrays.sort(buildingPoints);\n\n        TreeMap<Integer, Integer> queue = new TreeMap<>();\n        queue.put(0, 1);\n        int prevMaxHeight = 0;\n        List<List<Integer>> result = new ArrayList<>();\n\n        for(BuildingPoint buildingPoint: buildingPoints) {\n            if (buildingPoint.isStart) {\n                queue.compute(buildingPoint.y, (key, value) -> value != null ? value + 1: 1);\n            } else {\n                queue.compute(buildingPoint.y, (key, value) -> value == 1 ? null: value - 1);\n            }\n            int currentMaxHeight = queue.lastKey();\n            if (prevMaxHeight != currentMaxHeight) {\n                result.add(Arrays.asList(buildingPoint.x, currentMaxHeight));\n                prevMaxHeight = currentMaxHeight;\n            }\n        }\n        return result;\n    }\n}\n\nclass BuildingPoint implements Comparable<BuildingPoint>{\n    int x;\n    int y;\n    boolean isStart;\n    BuildingPoint(int x, int y, boolean isStart) {\n        this.x = x;\n        this.y = y;\n        this.isStart = isStart;\n    }\n\n    public  int compareTo(BuildingPoint o) {\n        if (this.x != o.x) {\n            return this.x - o.x;\n        }\n        // if two starts are compared, then higher y should be picked first\n        // if two ends are compared, then lower y should be picked first\n        // if one start and one end is compared, then start should appear before end\n        int h1 = isStart ? -y : y;\n        int h2 = o.isStart ? -o.y : o.y;\n        return h1 - h2;\n    }\n\n    public String toString() {\n        return \"{\"+x+\", \"+y+\", \"+isStart+\"}\";\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "top-k-frequent-elements": {
      "id": "top-k-frequent-elements",
      "title": "Top K Frequent Elements",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "hash-table",
        "divide-and-conquer",
        "sorting",
        "heap-priority-queue",
        "bucket-sort",
        "counting",
        "quickselect"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nlogn)",
      "sc": "O(n)",
      "leetcode": "top-k-frequent-elements",
      "gfg": null,
      "leetid": 347,
      "content": "---\nlayout: post\ntitle: Top K Frequent Elements\ntopics: [array, hash-table, divide-and-conquer, sorting, heap-priority-queue, bucket-sort, counting, quickselect]\nlangs: [java]\ntc: O(nlogn)\nsc: O(n)\nleetid: 347\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: top-k-frequent-elements\n---\nGiven an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n```\n\n**Example 2:**\n```\nInput: nums = [1], k = 1\nOutput: [1]\n```\n\n**Constraints:**\n\t\n* `1 <= nums.length <= 10<sup>5</sup>`\n* `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`\n* `k` is in the range `[1, the number of unique elements in the array]`.\n* It is **guaranteed** that the answer is **unique**.\n**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.",
      "body": "Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n```\n\n**Example 2:**\n```\nInput: nums = [1], k = 1\nOutput: [1]\n```\n\n**Constraints:**\n\t\n* `1 <= nums.length <= 10<sup>5</sup>`\n* `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`\n* `k` is in the range `[1, the number of unique elements in the array]`.\n* It is **guaranteed** that the answer is **unique**.\n**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue((a, b) -> count.getOrDefault(b,0) - count.getOrDefault(a, 0));\n        for(int n: nums) {\n            if (!count.containsKey(n)) {\n                pq.offer(n);\n            }\n            count.put(n, count.getOrDefault(n, 0) + 1);\n        }\n        int[] result = new int[k];\n        int i = 0;\n        while(!pq.isEmpty() && i<k) {\n            result[i++] = pq.poll();\n        }\n        return result;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "trapping-rain-water": {
      "id": "trapping-rain-water",
      "title": "Trapping Rain Water",
      "difficulty": "hard",
      "companies": [
        "facebook",
        "google",
        "amazon",
        "adobe"
      ],
      "topics": [
        "array",
        "stack",
        "two-pointers"
      ],
      "langs": [
        "java",
        "go",
        "c",
        "cpp",
        "py",
        "js",
        "ts",
        "cs"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "trapping-rain-water",
      "gfg": "trapping-rain-water",
      "leetid": 42,
      "content": "---\nlayout: post\ntitle: Trapping Rain Water\ntopics: [array, stack, two-pointers]\nlangs: [java, go, c, cpp, py, js, ts, cs]\ntc: O(n)\nsc: O(1)\nleetid: 42\ngfg: trapping-rain-water\ndifficulty: hard\ncompanies: [facebook, google, amazon, adobe]\nhackerrank: \ninterviewbit: container-with-most-water\nleetcode: trapping-rain-water\nhellointerview: code/two-pointers/container-with-most-water\n---\n\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, \ncompute how much water it can trap after raining.\n\n---\n## Test Cases\n\n**Example 1:**\n<MdxImage src=\"code/rainwatertrap.png\" alt=\"Rain Water\" />\n\n```\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. \nIn this case, 6 units of rain water (blue section) are being trapped.\n```\n\n**Example 2:**\n```\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n```\n",
      "body": "Given n non-negative integers representing an elevation map where the width of each bar is 1, \ncompute how much water it can trap after raining.\n\n---\n## Test Cases\n\n**Example 1:**\n<MdxImage src=\"code/rainwatertrap.png\" alt=\"Rain Water\" />\n\n```\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. \nIn this case, 6 units of rain water (blue section) are being trapped.\n```\n\n**Example 2:**\n```\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n```\n",
      "solutions": {
        "c": {
          "language": "c",
          "code": "int trap(int* height, int n){\n    int left = 0, right = n-1;\n    int maxleft = 0, maxright = 0, total = 0;\n    while(left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] < maxleft) {\n                total += maxleft - height[left];\n            } else {\n                maxleft = height[left];\n            }\n            left++;\n        } else {\n            if (height[right] < maxright) {\n                total += maxright - height[right];\n            } else {\n                maxright = height[right];\n            }\n            right--;\n        }\n    }\n    return total;\n}",
          "subPath": "",
          "fileName": "solution.c"
        },
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        int left = 0, right = n-1;\n        int maxleft = 0, maxright = 0, total = 0;\n        while(left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] < maxleft) {\n                    total += maxleft - height[left];\n                } else {\n                    maxleft = height[left];\n                }\n                left++;\n            } else {\n                if (height[right] < maxright) {\n                    total += maxright - height[right];\n                } else {\n                    maxright = height[right];\n                }\n                right--;\n            }\n        }\n        return total;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "cs": {
          "language": "cs",
          "code": "public class Solution {\n    public int Trap(int[] height) {\n        int left=0, right=height.Length-1, min, level=0, water=0;\n        while(left < right) {\n            if (height[left] < height[right]) {\n                min = height[left++];\n            } else {\n                min = height[right--];\n            }\n            if (min > level) level = min;\n            water += level - min;\n        }\n        return water;\n    }\n}",
          "subPath": "",
          "fileName": "solution.cs"
        },
        "go": {
          "language": "go",
          "code": "package trapping_rain_water\n\nfunc trap(height []int) int {\n\tn := len(height)\n\tleft, right := 0, n-1\n\tmaxLeft, maxRight, total := 0, 0, 0\n\tfor left < right {\n\t\tif height[left] < height[right] {\n\t\t\tif height[left] >= maxLeft {\n\t\t\t\tmaxLeft = height[left]\n\t\t\t} else {\n\t\t\t\ttotal += maxLeft - height[left]\n\t\t\t}\n\t\t\tleft++\n\t\t} else {\n\t\t\tif height[right] >= maxRight {\n\t\t\t\tmaxRight = height[right]\n\t\t\t} else {\n\t\t\t\ttotal += maxRight - height[right]\n\t\t\t}\n\t\t\tright--\n\t\t}\n\t}\n\treturn total\n}",
          "subPath": "",
          "fileName": "solution.go"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        int left = 0, right = n-1;\n        int total = 0;\n        int maxLeft = 0, maxRight = 0;\n        while(left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= maxLeft) {\n                    maxLeft = height[left];\n                } else {\n                    total += maxLeft - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= maxRight) {\n                    maxRight = height[right];\n                } else {\n                    total += maxRight - height[right];\n                }\n                right--;\n            }\n        }\n        return total;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "js": {
          "language": "js",
          "code": "/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function(height) {\n    let left=0, right=height.length-1, min, level=0, water=0;\n    while(left < right) {\n        if (height[left] < height[right]) {\n            min = height[left++];\n        } else {\n            min = height[right--];\n        }\n        if (min > level) level = min;\n        water += level - min;\n    }\n    return water;\n};",
          "subPath": "",
          "fileName": "solution.js"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        left, right = 0, len(height) - 1\n        maxleft, maxright, total = 0, 0, 0\n        while left < right:\n            if height[left] < height[right]:\n                if height[left] < maxleft:\n                    total += maxleft - height[left]\n                else:\n                    maxleft = height[left]\n\n                left += 1\n            else:\n                if height[right] < maxright:\n                    total += maxright - height[right]\n                else:\n                    maxright = height[right]\n\n                right -= 1\n\n        return total",
          "subPath": "",
          "fileName": "solution.py"
        },
        "ts": {
          "language": "ts",
          "code": "function trap(height: number[]): number {\n    let maxLeft = 0;\n    let maxRight = 0;\n    let left = 0;\n    let right = height.length - 1;\n    let total = 0;\n    while(left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] < maxLeft) {\n                total += maxLeft - height[left];\n            } else {\n                maxLeft = height[left];\n            }\n            left++;\n        } else {\n            if (height[right] < maxRight) {\n                total += maxRight - height[right];\n            } else {\n                maxRight = height[right];\n            }\n            right--;\n        }\n    }\n    return total;\n};",
          "subPath": "",
          "fileName": "solution.ts"
        }
      }
    },
    "valid-number": {
      "id": "valid-number",
      "title": "Valid Number",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "string"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(n)",
      "sc": "O(1)",
      "leetcode": "valid-number",
      "gfg": null,
      "leetid": 65,
      "content": "---\nlayout: post\ntitle: Valid Number\ntopics: [string]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(1)\nleetid: 65\ndifficulty: hard\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: valid-number\n---\n\nA valid number can be split up into these components (in order):\n1. A decimal number or an integer.\n2. (Optional) An `'e'` or `'E'`, followed by an integer.\n\nA decimal number can be split up into these components (in order):\n1. (Optional) A sign character (either `'+'` or `'-'`).\n2. One of the following formats:\n   1. One or more digits, followed by a dot `'.'`.\n   2. One or more digits, followed by a dot `'.'`, followed by one or more digits.\n   3. A dot `'.'`, followed by one or more digits.\n   \nAn integer can be split up into these components (in order):\n1. (Optional) A sign character (either '+' or '-').\n2. One or more digits.\n\nFor example, \nall the following are valid numbers: \n`[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]`, \nwhile the following are not valid numbers: `[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]`.\n\nGiven a string `s`, return true if `s` is a valid number.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"e\"\nOutput: false\n```\n\n**Example 2:** \n```\nInput: s = \"5.\"\nOutput: true\n```",
      "body": "A valid number can be split up into these components (in order):\n1. A decimal number or an integer.\n2. (Optional) An `'e'` or `'E'`, followed by an integer.\n\nA decimal number can be split up into these components (in order):\n1. (Optional) A sign character (either `'+'` or `'-'`).\n2. One of the following formats:\n   1. One or more digits, followed by a dot `'.'`.\n   2. One or more digits, followed by a dot `'.'`, followed by one or more digits.\n   3. A dot `'.'`, followed by one or more digits.\n   \nAn integer can be split up into these components (in order):\n1. (Optional) A sign character (either '+' or '-').\n2. One or more digits.\n\nFor example, \nall the following are valid numbers: \n`[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]`, \nwhile the following are not valid numbers: `[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]`.\n\nGiven a string `s`, return true if `s` is a valid number.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"e\"\nOutput: false\n```\n\n**Example 2:** \n```\nInput: s = \"5.\"\nOutput: true\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        bool num = false, dec = false, sign = false, exp = false;\n        for(int i=0; i<s.size(); i++) {\n            char c = s[i];\n            if (c >= '0' && c <= '9') {\n                num = true;\n            } else if (c == 'e' || c == 'E') {\n                if (exp || !num) {\n                    return false;\n                }\n                exp = true;\n                sign = false;\n                dec = false;\n                num = false;\n            } else if (c == '+' || c == '-') {\n                if (sign || num || dec) {\n                    return false;\n                }\n                sign = true;\n            } else if (c == '.') {\n                if (dec || exp) {\n                    return false;\n                }\n                dec = true;\n            } else {\n                return false;\n            }\n        }\n        return num;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n        boolean eseen = false, numseen = false, pointseen = false;\n        for(int i=0; i<s.length(); i++) {\n            if ('0' <= s.charAt(i) && s.charAt(i) <= '9') {\n                numseen = true;\n            } else if (s.charAt(i) == '.') {\n                if (pointseen || eseen) {\n                    return false;\n                }\n                pointseen = true;\n            } else if (s.charAt(i) == 'e' || s.charAt(i) == 'E') {\n                if (eseen || !numseen) {\n                    return false;\n                }\n                numseen = false;\n                eseen = true;\n            } else if (s.charAt(i) == '-' || s.charAt(i) == '+') {\n                if (i != 0 && s.charAt(i-1) != 'e') {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return numseen;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        num, exp, dec, sign = [False]*4\n        for c in s:\n            if '0' <= c <= '9':\n                num = True\n            elif c == 'e' or c == 'E':\n                if not num or exp:\n                    return False\n                exp = True\n                sign = False\n                dec = False\n                num = False\n            elif c == '.':\n                if exp or dec:\n                    return False\n                dec = True\n            elif c == '+' or c == '-':\n                if sign or num or dec:\n                    return False\n                sign = True\n            else:\n                return False\n        return num",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "valid-sudoku": {
      "id": "valid-sudoku",
      "title": "Valid Sudoku",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "hash-table",
        "matrix"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(81)",
      "sc": "O(81)",
      "leetcode": "valid-sudoku",
      "gfg": null,
      "leetid": 36,
      "content": "---\nlayout: post\ntitle: Valid Sudoku\ntopics: [array, hash-table, matrix]\nlangs: [java]\ntc: O(81)\nsc: O(81)\nleetid: 36\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: valid-sudoku\n---\n\nDetermine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n- Each row must contain the digits 1-9 without repetition.\n- Each column must contain the digits 1-9 without repetition.\n- Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n_**Note:**_\n- A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n- Only the filled cells need to be validated according to the mentioned rules.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. \nSince there are two 8's in the top left 3x3 sub-box, it is invalid.\n```",
      "body": "Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n- Each row must contain the digits 1-9 without repetition.\n- Each column must contain the digits 1-9 without repetition.\n- Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n_**Note:**_\n- A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n- Only the filled cells need to be validated according to the mentioned rules.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. \nSince there are two 8's in the top left 3x3 sub-box, it is invalid.\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        boolean[][] col = new boolean[9][9];\n        boolean[][] row = new boolean[9][9];\n        boolean[][] block = new boolean[9][9];\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    continue;\n                }\n                int digit = board[i][j] - '1';\n                int blockId = i / 3 * 3 + j / 3;\n                if (row[i][digit]) return false;\n                if (col[j][digit]) return false;\n                if (block[blockId][digit]) return false;\n                row[i][digit] = true;\n                col[j][digit] = true;\n                block[blockId][digit] = true;\n            }\n        }\n        return true;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "vertical-order-traversal-of-a-binary-tree": {
      "id": "vertical-order-traversal-of-a-binary-tree",
      "title": "Vertical Order Traversal of a Binary Tree",
      "difficulty": "hard",
      "companies": [
        "facebook",
        "google"
      ],
      "topics": [
        "hash-table",
        "tree",
        "depth-first-search",
        "breadth-first-search",
        "sorting",
        "binary-tree"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "vertical-order-traversal-of-a-binary-tree",
      "gfg": null,
      "leetid": 1029,
      "content": "---\nlayout: post\ntitle: Vertical Order Traversal of a Binary Tree\ndifficulty: hard\ntopics: [hash-table, tree, depth-first-search, breadth-first-search, sorting, binary-tree]\nlangs: [java]\ntc: O(n)\nsc: O(n)\ncompanies: [facebook, google]\nleetid: 1029\nleetcode: vertical-order-traversal-of-a-binary-tree\ngfg: \ninterviewbit: \nhackerrank: \n---\nGiven the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.\nFor each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.\nThe **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\nReturn *the **vertical order traversal** of the binary tree*.\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\" style={{width: '431px', height: '304px'}} />\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\nExplanation:\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\n```\n\n**Example 2:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\" style={{width: '512px', height: '304px'}} />\n```\nInput: root = [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n```\n\n**Example 3:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\" style={{width: '512px', height: '304px'}} />\n```\nInput: root = [1,2,3,4,6,5,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[1, 1000]`.\n\t\n* `0 <= Node.val <= 1000`\n\n",
      "body": "Given the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.\nFor each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.\nThe **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\nReturn *the **vertical order traversal** of the binary tree*.\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\" style={{width: '431px', height: '304px'}} />\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\nExplanation:\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\n```\n\n**Example 2:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\" style={{width: '512px', height: '304px'}} />\n```\nInput: root = [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n```\n\n**Example 3:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\" style={{width: '512px', height: '304px'}} />\n```\nInput: root = [1,2,3,4,6,5,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[1, 1000]`.\n\t\n* `0 <= Node.val <= 1000`\n\n",
      "solutions": {
        "java": {
          "language": "java",
          "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map = new TreeMap<>();\n        Queue<Tuple> queue = new LinkedList<>();\n\n        queue.offer(new Tuple(root, 0, 0));\n        while(!queue.isEmpty()) {\n            Tuple tuple = queue.poll();\n            TreeNode node = tuple.node;\n            int row = tuple.row;\n            int col = tuple.col;\n\n            if (!map.containsKey(row)) {\n                map.put(row, new TreeMap<>());\n            }\n            if (!map.get(row).containsKey(col)) {\n                map.get(row).put(col, new PriorityQueue<>());\n            }\n\n            map.get(row).get(col).offer(node.val);\n\n            if (node.left != null) {\n                queue.offer(new Tuple(node.left, row-1, col+1));\n            }\n\n            if (node.right != null) {\n                queue.offer(new Tuple(node.right, row+1, col+1));\n            }\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n        for(TreeMap<Integer, PriorityQueue<Integer>> mapValues: map.values()) {\n            result.add(new ArrayList<>());\n            for (PriorityQueue<Integer> nodes: mapValues.values()) {\n                while(!nodes.isEmpty()) {\n                    result.get(result.size() - 1).add(nodes.poll());\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\nclass Tuple {\n    TreeNode node;\n    int row;\n    int col;\n    Tuple(TreeNode node, int row, int col) {\n        this.node = node;\n        this.row = row;\n        this.col = col;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "where-will-the-ball-fall": {
      "id": "where-will-the-ball-fall",
      "title": "Where Will the Ball Fall",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "array",
        "depth-first-search",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(nm)",
      "sc": "O(m)",
      "leetcode": "where-will-the-ball-fall",
      "gfg": null,
      "leetid": 1706,
      "content": "---\nlayout: post\ntitle: Where Will the Ball Fall\ntopics: [array, depth-first-search, dynamic-programming]\nlangs: [java, cpp]\ntc: O(nm)\nsc: O(m)\nleetid: 1706\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: where-will-the-ball-fall\n---\n\nYou have a 2-D grid of size `m x n` representing a box, and you have `n` balls. The box is open on the top and bottom sides.\n\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n- A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`. \n- A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.\n\nWe drop one ball at the top of each column of the box. \nEach ball can get stuck in the box or fall out of the bottom. \nA ball gets stuck if it hits a `\"V\"` shaped pattern between two boards or if a board redirects the ball into either wall of the box.\n\nReturn an array answer of size `n` where `answer[i]` is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, \nor `-1` if the ball gets stuck in the box.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/ball.jpeg\" alt=\"Ball\" />\n\n**Example 1:** \n```\nInput: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\nOutput: [1,-1,-1,-1,-1]\nExplanation: This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n```\n\n**Example 2:** \n```\nInput: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\nOutput: [0,1,2,3,4,-1]\n```",
      "body": "You have a 2-D grid of size `m x n` representing a box, and you have `n` balls. The box is open on the top and bottom sides.\n\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n- A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`. \n- A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.\n\nWe drop one ball at the top of each column of the box. \nEach ball can get stuck in the box or fall out of the bottom. \nA ball gets stuck if it hits a `\"V\"` shaped pattern between two boards or if a board redirects the ball into either wall of the box.\n\nReturn an array answer of size `n` where `answer[i]` is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, \nor `-1` if the ball gets stuck in the box.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/ball.jpeg\" alt=\"Ball\" />\n\n**Example 1:** \n```\nInput: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\nOutput: [1,-1,-1,-1,-1]\nExplanation: This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n```\n\n**Example 2:** \n```\nInput: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\nOutput: [0,1,2,3,4,-1]\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    vector<int> findBall(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<int> res;\n        for(int j=0; j<m; j++) {\n            int startCol = j;\n            for(int i=0; i<n; i++) {\n                int endCol = startCol + grid[i][startCol];\n                if (endCol < 0 || endCol >= m || grid[i][endCol] != grid[i][startCol]) {\n                    startCol = -1;\n                    break;\n                }\n                startCol = endCol;\n            }\n            res.push_back(startCol);\n        }\n        return res;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int[] findBall(int[][] grid) {\n        int n = grid.length, m = grid[0].length;\n        int[] res = new int[m];\n        for(int j=0; j<m; j++) {\n            int startCol = j;\n            for(int i=0; i<n; i++) {\n                int endCol = startCol + grid[i][startCol];\n                if (endCol < 0 || endCol >= m || grid[i][endCol] != grid[i][startCol]) {\n                    startCol = -1;\n                    break;\n                }\n                startCol = endCol;\n            }\n            res[j] = startCol;\n        }\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "wildcard-matching": {
      "id": "wildcard-matching",
      "title": "Wildcard Matching",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "dynamic-programming",
        "greedy",
        "string"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(n+m)",
      "sc": "O(m)",
      "leetcode": "wildcard-matching",
      "gfg": null,
      "leetid": 44,
      "content": "---\nlayout: post\ntitle: Wildcard Matching\ntopics: [dynamic-programming, greedy, string]\nlangs: [java, cpp]\ntc: O(n+m)\nsc: O(m)\nleetid: 44\ndifficulty: hard\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: wildcard-matching\n---\n\nGiven an input string `(s)` and a pattern `(p)`, implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n- `'?'` Matches any single character.\n- `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:** \n```\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n```\n\n**Example 3:**\n```\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n```",
      "body": "Given an input string `(s)` and a pattern `(p)`, implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n- `'?'` Matches any single character.\n- `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:** \n```\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n```\n\n**Example 3:**\n```\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool isMatch(string text, string pattern) {\n        int n1 = text.size();\n        int n2 = pattern.size();\n        vector<vector<bool>> dp(n1+1, vector<bool>(n2+1, false));\n        dp[0][0] = true;\n        for (int j = 1; j <= n2; j++) {\n            if (pattern[j - 1] == '*') dp[0][j] = dp[0][j - 1];\n        }\n        for (int i = 1; i <= n1; i++) {\n            dp[i][0] = false;\n        }\n        for (int i = 1; i <= n1; i++) {\n            for (int j = 1; j <= n2; j++) {\n                if (text[i - 1] == pattern[j - 1] || pattern[j - 1] == '?') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (pattern[j - 1] == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                } else {\n                    dp[i][j] = false;\n                }\n            }\n        }\n        return dp[n1][n2];\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int n = s.length(), m = p.length();\n        boolean[][] dp = new boolean[n+1][m+1];\n        dp[0][0] = true;\n        for(int i=1; i<=m; i++) {\n            if (p.charAt(i-1) == '*') dp[0][i] = dp[0][i-1];\n        }\n        for(int i=1; i<=n; i++) {\n            for(int j=1; j<=m; j++) {\n                if (p.charAt(j-1) == '*') {\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\n                } else if (p.charAt(j-1) == '?' || p.charAt(j-1) == s.charAt(i-1)) {\n                    dp[i][j] = dp[i-1][j-1];\n                } else {\n                    dp[i][j] = false;\n                }\n            }\n        }\n        return dp[n][m];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "word-break-ii": {
      "id": "word-break-ii",
      "title": "Word Break II",
      "difficulty": "hard",
      "companies": [
        "facebook"
      ],
      "topics": [
        "backtracking",
        "dynamic-programming",
        "hash-table",
        "string"
      ],
      "langs": [
        "java",
        "py"
      ],
      "tc": "O(2<sup>n</sup>)",
      "sc": "O(n)",
      "leetcode": "word-break-ii",
      "gfg": null,
      "leetid": 140,
      "content": "---\nlayout: post\ntitle: Word Break II\ntopics: [backtracking, dynamic-programming, hash-table, string]\nlangs: [java, py]\ntc: O(2<sup>n</sup>)\nsc: O(n)\nleetid: 140\ndifficulty: hard\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: word-break-ii\nleetcode: word-break-ii\n---\nGiven a string `s` and a dictionary of strings `wordDict`, \nadd spaces in `s` to construct a sentence where each word is a valid dictionary word. \nReturn all such possible sentences in any order.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\n```\n\n**Example 2:** \n```\nInput: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\nExplanation: Note that you are allowed to reuse a dictionary word.\n```\n\n**Example 3:**\n```\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []\n```",
      "body": "Given a string `s` and a dictionary of strings `wordDict`, \nadd spaces in `s` to construct a sentence where each word is a valid dictionary word. \nReturn all such possible sentences in any order.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\n```\n\n**Example 2:** \n```\nInput: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\nExplanation: Note that you are allowed to reuse a dictionary word.\n```\n\n**Example 3:**\n```\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        Set<String> wordSet = new HashSet<>(wordDict);\n        return dfs(s, wordSet, new HashMap<String, List<String>>());\n    }\n\n    private List<String> dfs(String s, Set<String> wordDict, Map<String, List<String>> map) {\n        if (map.containsKey(s)) {\n            return map.get(s);\n        }\n\n        List<String> res = new ArrayList<String>();\n        if (s.length() == 0) {\n            res.add(\"\");\n            return res;\n        }\n        for (String word : wordDict) {\n            int wlen = word.length();\n            if (s.length() < wlen) continue;\n            boolean match = true;\n            for(int i=0; i<wlen; i++) {\n                if (s.charAt(i) != word.charAt(i)) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                List<String>sublist = dfs(s.substring(word.length()), wordDict, map);\n                for (String sub : sublist)\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\n            }\n        }\n        map.put(s, res);\n        return res;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        size = len(s)\n        memo = [None for _ in range(size + 1)]\n\n        def dfs(start):\n            if start > size - 1:\n                return [[]]\n            if memo[start]:\n                return memo[start]\n            res = []\n            for i in range(start, size):\n                word = s[start: i + 1]\n                if word in wordDict:\n                    rest_res = dfs(i + 1)\n                    for item in rest_res:\n                        res.append([word] + item)\n            memo[start] = res\n            return res\n        res = dfs(0)\n        ans = []\n        for item in res:\n            ans.append(\" \".join(item))\n        return ans",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "word-break": {
      "id": "word-break",
      "title": "Word Break",
      "difficulty": "medium",
      "companies": [
        "facebook"
      ],
      "topics": [
        "string",
        "dynamic-programming"
      ],
      "langs": [
        "java",
        "cpp",
        "py"
      ],
      "tc": "O(n<sup>2</sup>)",
      "sc": "O(n)",
      "leetcode": "word-break",
      "gfg": "word-break-problem-dp-32",
      "leetid": 139,
      "content": "---\nlayout: post\ntitle: Word Break\ntopics: [string, dynamic-programming]\nlangs: [java, cpp, py]\ntc: O(n<sup>2</sup>)\nsc: O(n)\nleetid: 139\ngfg: word-break-problem-dp-32\ncompanies: [facebook]\ndifficulty: medium\nhackerrank: \ninterviewbit: word-break\nleetcode: word-break\n---\n\nGiven a string s and a dictionary of strings `wordDict`, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n---\n## Test Cases\n\n**Input:**\n\n    (String)    s = \"leetcode\"\n    (String[])  wordDict = [\"leet\",\"code\"]\n\n**Output:**\n\n    (boolean) true\n\n---\n\n**Input:**\n\n    (String)    s = \"applepenapple\"\n    (String[])  wordDict = [\"apple\",\"pen\"]\n\n**Output:**\n\n    (boolean) true\n\n**Explanation**\n\n    Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word.\n\n---\n\n**Input:**\n\n    (String)    s = \"catsandog\"\n    (String[])  wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\n**Output:**\n\n    (boolean) false",
      "body": "Given a string s and a dictionary of strings `wordDict`, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n---\n## Test Cases\n\n**Input:**\n\n    (String)    s = \"leetcode\"\n    (String[])  wordDict = [\"leet\",\"code\"]\n\n**Output:**\n\n    (boolean) true\n\n---\n\n**Input:**\n\n    (String)    s = \"applepenapple\"\n    (String[])  wordDict = [\"apple\",\"pen\"]\n\n**Output:**\n\n    (boolean) true\n\n**Explanation**\n\n    Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word.\n\n---\n\n**Input:**\n\n    (String)    s = \"catsandog\"\n    (String[])  wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\n**Output:**\n\n    (boolean) false",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        int n = s.length();\n        vector<bool> dp(n, false);\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<=i; j++) {\n                string sub = s.substr(j, i-j+1);\n                if (contains(wordDict, sub) && (j==0 || dp[j-1])) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n-1];\n    }\n\n    bool contains(vector<string> &v, string s) {\n        return find(v.begin(), v.end(), s) != v.end();\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        if (s == null || s.length() == 0) return false;\n\n        int n = s.length();\n        Set<String> dict = new HashSet<>(wordDict);\n        // dp[i] represents whether s[0...i] can be formed by dict\n        boolean[] dp = new boolean[n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n                String sub = s.substring(j, i + 1);\n\n                if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[n - 1];\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        n = len(s)\n        dp, st = [False]*n, set(wordDict)\n        for i in range(n):\n            for j in range(i+1):\n                if s[j:i+1] in st and (j==0 or dp[j-1]):\n                    dp[i] = True\n                    break\n        return dp[n-1]",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "word-ladder": {
      "id": "word-ladder",
      "title": "Word Ladder",
      "difficulty": "hard",
      "companies": [
        "linkedin",
        "facebook"
      ],
      "topics": [
        "hash-table",
        "string"
      ],
      "langs": [
        "java",
        "cpp"
      ],
      "tc": "O(m<sup>2</sup>n)",
      "sc": "O(m<sup>2</sup>n)",
      "leetcode": "word-ladder",
      "gfg": null,
      "leetid": 127,
      "content": "---\nlayout: post\ntitle: Word Ladder\ntopics: [hash-table, string]\nlangs: [java, cpp]\ntc: O(m<sup>2</sup>n)\nsc: O(m<sup>2</sup>n)\nleetid: 127\ndifficulty: hard\ncompanies: [linkedin, facebook]\ngfg: \nhackerrank: \ninterviewbit: word-ladder-i\nleetcode: word-ladder\n---\n\nA transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words \n```\nbeginWord -> s1 -> s2 -> ... -> sk\n```\nsuch that: \n- Every adjacent pair of words differs by a single letter. \n- Every s<sub>i</sub> for `1 <= i <= k` is in wordList. Note that beginWord does not need to be in wordList.\n- `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, \nreturn the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.\n\n---\n## Test Cases\n\n**Input:**\n\n    (String)    beginWord = \"hit\"\n    (String)    endWord = \"cog\"\n    (String[])  wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\n**Output:**\n\n      (int) 5\n\n---\n\n**Input:**\n\n    (String)    beginWord = \"hit\"\n    (String)    endWord = \"cog\"\n    (String[])  wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\n**Output:**\n\n      (int) 0",
      "body": "A transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words \n```\nbeginWord -> s1 -> s2 -> ... -> sk\n```\nsuch that: \n- Every adjacent pair of words differs by a single letter. \n- Every s<sub>i</sub> for `1 <= i <= k` is in wordList. Note that beginWord does not need to be in wordList.\n- `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, \nreturn the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.\n\n---\n## Test Cases\n\n**Input:**\n\n    (String)    beginWord = \"hit\"\n    (String)    endWord = \"cog\"\n    (String[])  wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\n**Output:**\n\n      (int) 5\n\n---\n\n**Input:**\n\n    (String)    beginWord = \"hit\"\n    (String)    endWord = \"cog\"\n    (String[])  wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\n**Output:**\n\n      (int) 0",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        set<string> wordSet(wordList.begin(), wordList.end());\n        if (!wordSet.count(endWord)) {\n            return 0;\n        }\n        queue<string> q;\n        q.push(beginWord);\n        int steps = 0;\n        while(!q.empty()) {\n            int qs = q.size();\n            for(int i=0; i<qs; i++) {\n                string s = q.front();\n                q.pop();\n                if (s == endWord) return steps+1;\n                for(int j=0; j<s.length(); j++) {\n                    char orig = s[j];\n                    for(char k='a'; k<='z'; k++) {\n                        s[j] = k;\n                        if (wordSet.count(s)) {\n                            q.push(s);\n                            wordSet.erase(s);\n                        }\n                    }\n                    s[j] = orig;\n                }\n            }\n            steps++;\n        }\n        return 0;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> set = new HashSet<>(wordList);\n        if (!set.contains(endWord)) {\n            return 0;\n        }\n        Queue<String> q = new LinkedList<>();\n        q.offer(beginWord);\n        int steps = 0, n = beginWord.length();\n        while(!q.isEmpty()) {\n            int qs = q.size();\n            for(int i=0; i<qs; i++) {\n                StringBuilder sb = new StringBuilder(q.poll());\n                if (endWord.equals(sb.toString())) {\n                    return steps+1;\n                }\n                for(int j=0; j<n; j++) {\n                    char orig = sb.charAt(j);\n                    for(char k='a'; k<='z'; k++) {\n                        sb.setCharAt(j, k);\n                        if (set.contains(sb.toString())) {\n                            q.offer(sb.toString());\n                            set.remove(sb.toString());\n                        }\n                    }\n                    sb.setCharAt(j, orig);\n                }\n            }\n            steps++;\n        }\n        return 0;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "word-search-ii": {
      "id": "word-search-ii",
      "title": "Word Search II",
      "difficulty": "hard",
      "companies": [],
      "topics": [
        "array",
        "backtracking",
        "string",
        "trie"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(nm)",
      "sc": "O(w)",
      "leetcode": "word-search-ii",
      "gfg": "boggle-using-trie",
      "leetid": 212,
      "content": "---\nlayout: post\ntitle: Word Search II\ntopics: [array, backtracking, string, trie]\nlangs: [java]\ntc: O(nm)\nsc: O(w)\nleetid: 212\ngfg: boggle-using-trie\ndifficulty: hard\ncompanies: \nhackerrank: \ninterviewbit: \nleetcode: word-search-ii\n---\n\nGiven an `m x n` board of characters and a list of strings words, return all words on the board.\n\nEach word must be constructed from letters of sequentially **adjacent cells**, \nwhere adjacent cells are horizontally or vertically neighboring. \nThe same letter cell may not be used more than once in a word.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<table class=\"post-example-table\">\n    <tr>\n        <td class=\"green\">o</td>\n        <td class=\"green\">a</td>\n        <td>a</td>\n        <td>n</td>\n    </tr>\n    <tr>\n        <td>e</td>\n        <td class=\"red\">t</td>\n        <td class=\"red\">a</td>\n        <td class=\"red\">e</td>\n    </tr>\n    <tr>\n        <td>i</td>\n        <td class=\"green\">h</td>\n        <td>k</td>\n        <td>r</td>\n    </tr>\n    <tr>\n        <td>i</td>\n        <td>f</td>\n        <td>l</td>\n        <td>v</td>\n    </tr>\n</table>\n\n\n```\nInput: board = [\n    [\"o\",\"a\",\"a\",\"n\"],\n    [\"e\",\"t\",\"a\",\"e\"],\n    [\"i\",\"h\",\"k\",\"r\"],\n    [\"i\",\"f\",\"l\",\"v\"]\n], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n```\n\n**Example 2:** \n\n<table class=\"post-example-table\">\n    <tr>\n        <td>a</td>\n        <td>b</td>\n    </tr>\n    <tr>\n        <td>c</td>\n        <td>d</td>\n    </tr>\n</table>\n\n```\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []\n```",
      "body": "Given an `m x n` board of characters and a list of strings words, return all words on the board.\n\nEach word must be constructed from letters of sequentially **adjacent cells**, \nwhere adjacent cells are horizontally or vertically neighboring. \nThe same letter cell may not be used more than once in a word.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<table class=\"post-example-table\">\n    <tr>\n        <td class=\"green\">o</td>\n        <td class=\"green\">a</td>\n        <td>a</td>\n        <td>n</td>\n    </tr>\n    <tr>\n        <td>e</td>\n        <td class=\"red\">t</td>\n        <td class=\"red\">a</td>\n        <td class=\"red\">e</td>\n    </tr>\n    <tr>\n        <td>i</td>\n        <td class=\"green\">h</td>\n        <td>k</td>\n        <td>r</td>\n    </tr>\n    <tr>\n        <td>i</td>\n        <td>f</td>\n        <td>l</td>\n        <td>v</td>\n    </tr>\n</table>\n\n\n```\nInput: board = [\n    [\"o\",\"a\",\"a\",\"n\"],\n    [\"e\",\"t\",\"a\",\"e\"],\n    [\"i\",\"h\",\"k\",\"r\"],\n    [\"i\",\"f\",\"l\",\"v\"]\n], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n```\n\n**Example 2:** \n\n<table class=\"post-example-table\">\n    <tr>\n        <td>a</td>\n        <td>b</td>\n    </tr>\n    <tr>\n        <td>c</td>\n        <td>d</td>\n    </tr>\n</table>\n\n```\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> res = new ArrayList<>();\n        TrieNode root = buildTrie(words);\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                dfs (board, i, j, root, res);\n            }\n        }\n        return res;\n    }\n\n    public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {\n        char c = board[i][j];\n        if (c == '#' || p.next[c - 'a'] == null) return;\n        p = p.next[c - 'a'];\n        if (p.word != null) {   // found one\n            res.add(p.word);\n            p.word = null;     // de-duplicate\n        }\n\n        board[i][j] = '#';\n        if (i > 0) dfs(board, i - 1, j ,p, res);\n        if (j > 0) dfs(board, i, j - 1, p, res);\n        if (i < board.length - 1) dfs(board, i + 1, j, p, res);\n        if (j < board[0].length - 1) dfs(board, i, j + 1, p, res);\n        board[i][j] = c;\n    }\n\n    public TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String w : words) {\n            TrieNode p = root;\n            for (char c : w.toCharArray()) {\n                int i = c - 'a';\n                if (p.next[i] == null) p.next[i] = new TrieNode();\n                p = p.next[i];\n            }\n            p.word = w;\n        }\n        return root;\n    }\n}\n\nclass TrieNode {\n    TrieNode[] next = new TrieNode[26];\n    String word;\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    },
    "word-search": {
      "id": "word-search",
      "title": "Word Search",
      "difficulty": "medium",
      "companies": [
        "adobe",
        "amazon",
        "apple",
        "bloomberg",
        "facebook",
        "goldman",
        "google",
        "microsoft",
        "oracle",
        "twitter"
      ],
      "topics": [
        "array",
        "backtracking",
        "string"
      ],
      "langs": [
        "java",
        "py",
        "cpp"
      ],
      "tc": "O(nmw)",
      "sc": "O(n)",
      "leetcode": "word-search",
      "gfg": "word-ladder-length-of-shortest-chain-to-reach-a-target-word",
      "leetid": 79,
      "content": "---\nlayout: post\ntitle: Word Search\ntopics: [array, backtracking, string]\nlangs: [java, py, cpp]\ntc: O(nmw)\nsc: O(n)\nleetid: 79\ncompanies: [adobe, amazon, apple, bloomberg, facebook, goldman, google, microsoft, oracle, twitter]\ndifficulty: medium\ngfg: word-ladder-length-of-shortest-chain-to-reach-a-target-word\nhackerrank: \ninterviewbit: \nleetcode: word-search\n---\n\nGiven an `m x n` grid of characters `board` and a string `word`, \nreturn `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, \nwhere adjacent cells are horizontally or vertically neighboring. \nThe same letter cell may not be used more than once.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/word2.jpeg\" alt=\"Word Search\" />\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"ABCCED\"\n```\n\n**Output:**\n```\n(boolean) true\n```\n\n---\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"See\"\n```\n\n**Output:**\n```\n(boolean) true\n```\n\n---\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"ABCB\"\n```\n\n**Output:**\n```\n(boolean) false\n```",
      "body": "Given an `m x n` grid of characters `board` and a string `word`, \nreturn `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, \nwhere adjacent cells are horizontally or vertically neighboring. \nThe same letter cell may not be used more than once.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/word2.jpeg\" alt=\"Word Search\" />\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"ABCCED\"\n```\n\n**Output:**\n```\n(boolean) true\n```\n\n---\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"See\"\n```\n\n**Output:**\n```\n(boolean) true\n```\n\n---\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"ABCB\"\n```\n\n**Output:**\n```\n(boolean) false\n```",
      "solutions": {
        "cpp": {
          "language": "cpp",
          "code": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int n = board.size(), m = board[0].size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                if (exist(board, word, i, j, 0)) return true;\n            }\n        }\n        return false;\n    }\n\n    bool exist(vector<vector<char>> &board, string word, int x, int y, int w) {\n        if (w == word.length()) return true;\n        if (x < 0 || y < 0 || x == board.size() || y == board[0].size()) return false;\n        if (board[x][y] != word[w]) return false;\n        char c = board[x][y];\n        board[x][y] = '*';\n        bool res = exist(board, word, x+1, y, w+1)\n            || exist(board, word, x, y+1, w+1)\n            || exist(board, word, x-1, y, w+1)\n            || exist(board, word, x, y-1, w+1);\n        board[x][y] = c;\n        return res;\n    }\n};",
          "subPath": "",
          "fileName": "solution.cpp"
        },
        "java": {
          "language": "java",
          "code": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] w = word.toCharArray();\n        for (int y=0; y<board.length; y++) {\n            for (int x=0; x<board[y].length; x++) {\n                if (exist(board, y, x, w, 0)) return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean exist(char[][] board, int y, int x, char[] word, int i) {\n        if (i == word.length) return true;\n        if (y<0 || x<0 || y == board.length || x == board[y].length) return false;\n        if (board[y][x] != word[i]) return false;\n        board[y][x] ^= 256;\n        boolean exist = exist(board, y, x+1, word, i+1)\n                || exist(board, y, x-1, word, i+1)\n                || exist(board, y+1, x, word, i+1)\n                || exist(board, y-1, x, word, i+1);\n        board[y][x] ^= 256;\n        return exist;\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        },
        "py": {
          "language": "py",
          "code": "from typing import List\n\n\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.check(board, word, i, j, 0):\n                    return True\n        return False\n\n    def check(self, board: List[List[str]], word: str, r: int, c: int, pos: int):\n        if pos == len(word):\n            return True\n        if r < 0 or r == len(board) or c < 0 or c == len(board[0]):\n            return False\n        if board[r][c] != word[pos]:\n            return False\n        board[r][c], orig = '0', board[r][c]\n        res = self.check(board, word, r + 1, c, pos + 1) or self.check(board, word, r - 1, c, pos + 1) or self.check(\n            board, word, r, c + 1, pos + 1) or self.check(board, word, r, c - 1, pos + 1)\n        board[r][c] = orig\n        return res",
          "subPath": "",
          "fileName": "solution.py"
        }
      }
    },
    "zigzag-conversion": {
      "id": "zigzag-conversion",
      "title": "Zigzag Conversion",
      "difficulty": "medium",
      "companies": [],
      "topics": [
        "string"
      ],
      "langs": [
        "java"
      ],
      "tc": "O(n)",
      "sc": "O(n)",
      "leetcode": "zigzag-conversion",
      "gfg": null,
      "leetid": 6,
      "content": "---\nlayout: post\ntitle: Zigzag Conversion\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 6\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: zigzag-conversion\n---\n\nThe string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR\"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n```\nstring convert(string s, int numRows);\n```\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n```\n\n**Example 2:** \n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```",
      "body": "The string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR\"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n```\nstring convert(string s, int numRows);\n```\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n```\n\n**Example 2:** \n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```",
      "solutions": {
        "java": {
          "language": "java",
          "code": "class Solution {\n    public String convert(String s, int numRows) {\n\n        if (numRows == 1) return s;\n\n        List<StringBuilder> rows = new ArrayList<>();\n        for (int i = 0; i < Math.min(numRows, s.length()); i++)\n            rows.add(new StringBuilder());\n\n        int curRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows.get(curRow).append(c);\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder ret = new StringBuilder();\n        for (StringBuilder row : rows) ret.append(row);\n        return ret.toString();\n    }\n}",
          "subPath": "",
          "fileName": "solution.java"
        }
      }
    }
  },
  "system-design": {
    "library-management": {
      "id": "library-management",
      "title": "Design a Library Management System",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Design a Library Management System\"\nauthor: \"Rajat Srivastava\"\ncategories: system-designs\ntags: [system-design, hld, lld]\ndifficulty: medium\n---\n\nA Library Management System is a software built to handle the primary housekeeping functions of a library. Libraries rely on library management systems to manage asset collections as well as relationships with their members. Library management systems help libraries keep track of the books and their checkouts, as well as members subscriptions and profiles.\n\nLibrary management systems also involve maintaining the database for entering new books and recording books that have been borrowed with their respective due dates.\n\n---\n\n## System Requirements\n\nWe will focus on the following set of requirements while designing the Library Management System:\n\n1. Any library member should be able to search books by their title, author, subject category as well by the publication date.\n2. Each book will have a unique identification number and other details including a rack number which will help to physically locate the book.\n3. There could be more than one copy of a book, and library members should be able to check-out and reserve any copy. We will call each copy of a book, a book item.\n4. The system should be able to retrieve information like who took a particular book or what are the books checked-out by a specific library member.\n5. There should be a maximum limit (5) on how many books a member can check-out.\n6. There should be a maximum limit (10) on how many days a member can keep a book.\n7. The system should be able to collect fines for books returned after the due date.\n8. Members should be able to reserve books that are not currently available.\n9. The system should be able to send notifications whenever the reserved books become available, as well as when the book is not returned within the due date.\n10. Each book and member card will have a unique barcode. The system will be able to read barcodes from books and members library cards.\n\n---\n## Use Case Diagrams\n\nWe have three main actors in our system:\n\n- **Librarian:** Mainly responsible for adding and modifying books, book items, and users. The Librarian can also issue, reserve, and return book items.\n- **Member:** All members can search the catalog, as well as check-out, reserve, renew, and return a book.\n- **System:** Mainly responsible for sending notifications for overdue books, canceled reservations, etc.\n\nHere are the top use cases of the Library Management System:\n\n- **Add/Remove/Edit book:** To add, remove or modify a book or book item.\n- **Search catalog:** To search books by title, author, subject or publication date.\n- **Register new account/cancel membership:** To add a new member or cancel the membership of an existing member.\n- **Check-out book:** To borrow a book from the library.\n- **Reserve book:** To reserve a book which is not currently available.\n- **Renew a book:** To reborrow an already checked-out book.\n- **Return a book:** To return a book to the library which was issued to a member.\n\n<MdxImage \n  src=\"design/library-management/use-case.png\" \n  alt=\"Use Case Diagram for Library Management System\"\n/>\n\n---\n## Class Diagrams\nHere are the main classes of our Library Management System:\n\n- **Library:** The central part of the organization for which this software has been designed. It has attributes like Name to distinguish it from any other libraries and Address to describe its location.\n- **Book:** The basic building block of the system. Every book will have ISBN, Title, Subject, Publishers, etc.\n- **BookItem:** Any book can have multiple copies, each copy will be considered a book item in our system. Each book item will have a unique barcode.\n- **Account:** We will have two types of accounts in the system, one will be a general member, and the other will be a librarian.\n- **LibraryCard:** Each library user will be issued a library card, which will be used to identify users while issuing or returning books.\n- **BookReservation:** Responsible for managing reservations against book items.\n- **BookLending:** Manage the checking-out of book items.\n- **Catalog:** Catalogs contain list of books sorted on certain criteria. Our system will support searching through four catalogs: Title, Author, Subject, and Publish-date.\n- **Fine:** This class will be responsible for calculating and collecting fines from library members.\n- **Author:** This class will encapsulate a book author.\n- **Rack:** Books will be placed on racks. Each rack will be identified by a rack number and will have a location identifier to describe the physical location of the rack in the library.\n- **Notification:** This class will take care of sending notifications to library members.\n\n<MdxImage \n  src=\"design/library-management/class-diagram.png\" \n  alt=\"Class Diagram for Library Management System\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"UML Diagram for Library Management System\"\n/>\n\n---\n## Activity diagrams\n\n- **Check-out a book:** Any library member or librarian can perform this activity. Here are the set of steps to check-out a book:\n  1. Verify member eligibility and check book availability\n  2. Scan book and member card barcodes\n  3. Update book status to \"checked out\"\n  4. Set due date (default 10 days)\n  5. Create lending record\n  6. Send confirmation to member\n\n<MdxImage \n  src=\"design/library-management/activity-checkout.svg\" \n  alt=\"Activity Diagram for Library Management System\"\n/>\n\n- **Return a book:** Any library member or librarian can perform this activity. The system will collect fines from members if they return books after the due date. Here are the steps for returning a book:\n  1. Scan book barcode to identify the book\n  2. Verify the book is checked out\n  3. Check if book is overdue\n  4. Calculate and collect fine if applicable\n  5. Update book status to \"available\"\n  6. Close lending record\n  7. Send confirmation to member\n\n<MdxImage \n  src=\"design/library-management/activity-return.png\" \n  alt=\"Activity Diagram for Library Management System\"\n/>\n\n- **Renew a book:** While renewing (re-issuing) a book, the system will check for fines and see if any other member has not reserved the same book, in that case the book item cannot be renewed. Here are the different steps for renewing a book:\n  1. Verify member and book information\n  2. Check if book has pending reservations\n  3. Check for outstanding fines\n  4. Extend due date if renewal is allowed\n  5. Update lending record\n  6. Send confirmation to member\n\n<MdxImage \n  src=\"design/library-management/activity-renew.svg\" \n  alt=\"Activity Diagram for Movie Booking System\"\n/>\n\n---\n## Code\nHere is the code for the use cases mentioned above: 1) Check-out a book, 2) Return a book, and 3) Renew a book.\n\nNote: This code only focuses on the design part of the use cases. Since you are not required to write a fully executable code in an interview, you can assume parts of the code to interact with the database, payment system, etc.\n\n### Enums and Constants\n- **BookStatus:** Available, Reserved, Loaned, Lost\n- **BookFormat:** Hardcover, Paperback, AudioBook, Ebook, Newspaper, Magazine, Journal\n- **AccountStatus:** Active, Closed, Canceled, Blacklisted, None\n- **ReservationStatus:** Waiting, Pending, Canceled, None\n- **Address:** Basic address information for members\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/enums\"\n/>\n\n\n### Account Management\n- **Account:** Base class for all system users\n- **Member:** Library members who can borrow books\n- **Librarian:** Staff members with administrative privileges\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/accounts\"\n/>\n\n### Core Library Operations\n- **BookReservation:** Manages book reservations\n- **BookLending:** Handles the lending process\n- **Fine:** Calculates and manages overdue fines\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/reservation\"\n/>\n\n### Book and Catalog Management\n- **Book:** Represents a book in the library\n- **BookItem:** Individual copies of books\n- **Catalog:** Implements search functionality across different criteria\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/books\"\n/>\n\n### Search Interface\nThe system supports searching by:\n- Title\n- Author\n- Subject\n- Publication date\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/search\"\n/>\n",
      "body": "A Library Management System is a software built to handle the primary housekeeping functions of a library. Libraries rely on library management systems to manage asset collections as well as relationships with their members. Library management systems help libraries keep track of the books and their checkouts, as well as members subscriptions and profiles.\n\nLibrary management systems also involve maintaining the database for entering new books and recording books that have been borrowed with their respective due dates.\n\n---\n\n## System Requirements\n\nWe will focus on the following set of requirements while designing the Library Management System:\n\n1. Any library member should be able to search books by their title, author, subject category as well by the publication date.\n2. Each book will have a unique identification number and other details including a rack number which will help to physically locate the book.\n3. There could be more than one copy of a book, and library members should be able to check-out and reserve any copy. We will call each copy of a book, a book item.\n4. The system should be able to retrieve information like who took a particular book or what are the books checked-out by a specific library member.\n5. There should be a maximum limit (5) on how many books a member can check-out.\n6. There should be a maximum limit (10) on how many days a member can keep a book.\n7. The system should be able to collect fines for books returned after the due date.\n8. Members should be able to reserve books that are not currently available.\n9. The system should be able to send notifications whenever the reserved books become available, as well as when the book is not returned within the due date.\n10. Each book and member card will have a unique barcode. The system will be able to read barcodes from books and members library cards.\n\n---\n## Use Case Diagrams\n\nWe have three main actors in our system:\n\n- **Librarian:** Mainly responsible for adding and modifying books, book items, and users. The Librarian can also issue, reserve, and return book items.\n- **Member:** All members can search the catalog, as well as check-out, reserve, renew, and return a book.\n- **System:** Mainly responsible for sending notifications for overdue books, canceled reservations, etc.\n\nHere are the top use cases of the Library Management System:\n\n- **Add/Remove/Edit book:** To add, remove or modify a book or book item.\n- **Search catalog:** To search books by title, author, subject or publication date.\n- **Register new account/cancel membership:** To add a new member or cancel the membership of an existing member.\n- **Check-out book:** To borrow a book from the library.\n- **Reserve book:** To reserve a book which is not currently available.\n- **Renew a book:** To reborrow an already checked-out book.\n- **Return a book:** To return a book to the library which was issued to a member.\n\n<MdxImage \n  src=\"design/library-management/use-case.png\" \n  alt=\"Use Case Diagram for Library Management System\"\n/>\n\n---\n## Class Diagrams\nHere are the main classes of our Library Management System:\n\n- **Library:** The central part of the organization for which this software has been designed. It has attributes like Name to distinguish it from any other libraries and Address to describe its location.\n- **Book:** The basic building block of the system. Every book will have ISBN, Title, Subject, Publishers, etc.\n- **BookItem:** Any book can have multiple copies, each copy will be considered a book item in our system. Each book item will have a unique barcode.\n- **Account:** We will have two types of accounts in the system, one will be a general member, and the other will be a librarian.\n- **LibraryCard:** Each library user will be issued a library card, which will be used to identify users while issuing or returning books.\n- **BookReservation:** Responsible for managing reservations against book items.\n- **BookLending:** Manage the checking-out of book items.\n- **Catalog:** Catalogs contain list of books sorted on certain criteria. Our system will support searching through four catalogs: Title, Author, Subject, and Publish-date.\n- **Fine:** This class will be responsible for calculating and collecting fines from library members.\n- **Author:** This class will encapsulate a book author.\n- **Rack:** Books will be placed on racks. Each rack will be identified by a rack number and will have a location identifier to describe the physical location of the rack in the library.\n- **Notification:** This class will take care of sending notifications to library members.\n\n<MdxImage \n  src=\"design/library-management/class-diagram.png\" \n  alt=\"Class Diagram for Library Management System\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"UML Diagram for Library Management System\"\n/>\n\n---\n## Activity diagrams\n\n- **Check-out a book:** Any library member or librarian can perform this activity. Here are the set of steps to check-out a book:\n  1. Verify member eligibility and check book availability\n  2. Scan book and member card barcodes\n  3. Update book status to \"checked out\"\n  4. Set due date (default 10 days)\n  5. Create lending record\n  6. Send confirmation to member\n\n<MdxImage \n  src=\"design/library-management/activity-checkout.svg\" \n  alt=\"Activity Diagram for Library Management System\"\n/>\n\n- **Return a book:** Any library member or librarian can perform this activity. The system will collect fines from members if they return books after the due date. Here are the steps for returning a book:\n  1. Scan book barcode to identify the book\n  2. Verify the book is checked out\n  3. Check if book is overdue\n  4. Calculate and collect fine if applicable\n  5. Update book status to \"available\"\n  6. Close lending record\n  7. Send confirmation to member\n\n<MdxImage \n  src=\"design/library-management/activity-return.png\" \n  alt=\"Activity Diagram for Library Management System\"\n/>\n\n- **Renew a book:** While renewing (re-issuing) a book, the system will check for fines and see if any other member has not reserved the same book, in that case the book item cannot be renewed. Here are the different steps for renewing a book:\n  1. Verify member and book information\n  2. Check if book has pending reservations\n  3. Check for outstanding fines\n  4. Extend due date if renewal is allowed\n  5. Update lending record\n  6. Send confirmation to member\n\n<MdxImage \n  src=\"design/library-management/activity-renew.svg\" \n  alt=\"Activity Diagram for Movie Booking System\"\n/>\n\n---\n## Code\nHere is the code for the use cases mentioned above: 1) Check-out a book, 2) Return a book, and 3) Renew a book.\n\nNote: This code only focuses on the design part of the use cases. Since you are not required to write a fully executable code in an interview, you can assume parts of the code to interact with the database, payment system, etc.\n\n### Enums and Constants\n- **BookStatus:** Available, Reserved, Loaned, Lost\n- **BookFormat:** Hardcover, Paperback, AudioBook, Ebook, Newspaper, Magazine, Journal\n- **AccountStatus:** Active, Closed, Canceled, Blacklisted, None\n- **ReservationStatus:** Waiting, Pending, Canceled, None\n- **Address:** Basic address information for members\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/enums\"\n/>\n\n\n### Account Management\n- **Account:** Base class for all system users\n- **Member:** Library members who can borrow books\n- **Librarian:** Staff members with administrative privileges\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/accounts\"\n/>\n\n### Core Library Operations\n- **BookReservation:** Manages book reservations\n- **BookLending:** Handles the lending process\n- **Fine:** Calculates and manages overdue fines\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/reservation\"\n/>\n\n### Book and Catalog Management\n- **Book:** Represents a book in the library\n- **BookItem:** Individual copies of books\n- **Catalog:** Implements search functionality across different criteria\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/books\"\n/>\n\n### Search Interface\nThe system supports searching by:\n- Title\n- Author\n- Subject\n- Publication date\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/library-management/search\"\n/>\n",
      "solutions": {
        "accounts_java": {
          "language": "java",
          "code": "// For simplicity, we are not defining getter and setter functions. The reader can\n// assume that all class attributes are private and accessed through their respective\n// public getter methods and modified only through their public methods function.\n\npublic abstract class Account {\n  private String id;\n  private String password;\n  private AccountStatus status;\n  private Person person;\n\n  public boolean resetPassword();\n}\n\npublic class Librarian extends Account {\n  public boolean addBookItem(BookItem bookItem);\n\n  public boolean blockMember(Member member);\n\n  public boolean unBlockMember(Member member);\n}\n\npublic class Member extends Account {\n  private Date dateOfMembership;\n  private int totalBooksCheckedout;\n\n  public int getTotalBooksCheckedout();\n\n  public boolean reserveBookItem(BookItem bookItem);\n\n  private void incrementTotalBooksCheckedout();\n\n  public boolean checkoutBookItem(BookItem bookItem) {\n\tif (this.getTotalBooksCheckedOut() >= Constants.MAX_BOOKS_ISSUED_TO_A_USER) {\n\t  ShowError(\"The user has already checked-out maximum number of books\");\n\t  return false;\n\t}\n\tBookReservation bookReservation = BookReservation.fetchReservationDetails(bookItem.getBarcode());\n\tif (bookReservation != null && bookReservation.getMemberId() != this.getId()) {\n\t  // book item has a pending reservation from another user\n\t  ShowError(\"This book is reserved by another member\");\n\t  return false;\n\t} else if (bookReservation != null) {\n\t  // book item has a pending reservation from the give member, update it\n\t  bookReservation.updateStatus(ReservationStatus.COMPLETED);\n\t}\n\n\tif (!bookItem.checkout(this.getId())) {\n\t  return false;\n\t}\n\n\tthis.incrementTotalBooksCheckedout();\n\treturn true;\n  }\n\n  private void checkForFine(String bookItemBarcode) {\n\tBookLending bookLending = BookLending.fetchLendingDetails(bookItemBarcode);\n\tDate dueDate = bookLending.getDueDate();\n\tDate today = new Date();\n\t// check if the book has been returned within the due date\n\tif (today.compareTo(dueDate) > 0) {\n\t  long diff = todayDate.getTime() - dueDate.getTime();\n\t  long diffDays = diff / (24 * 60 * 60 * 1000);\n\t  Fine.collectFine(memberId, diffDays);\n\t}\n  }\n\n  public void returnBookItem(BookItem bookItem) {\n\tthis.checkForFine(bookItem.getBarcode());\n\tBookReservation bookReservation = BookReservation.fetchReservationDetails(bookItem.getBarcode());\n\tif (bookReservation != null) {\n\t  // book item has a pending reservation\n\t  bookItem.updateBookItemStatus(BookStatus.RESERVED);\n\t  bookReservation.sendBookAvailableNotification();\n\t}\n\tbookItem.updateBookItemStatus(BookStatus.AVAILABLE);\n  }\n\n  public bool renewBookItem(BookItem bookItem) {\n\tthis.checkForFine(bookItem.getBarcode());\n\tBookReservation bookReservation = BookReservation.fetchReservationDetails(bookItem.getBarcode());\n\t// check if this book item has a pending reservation from another member\n\tif (bookReservation != null && bookReservation.getMemberId() != this.getMemberId()) {\n\t  ShowError(\"This book is reserved by another member\");\n\t  member.decrementTotalBooksCheckedout();\n\t  bookItem.updateBookItemState(BookStatus.RESERVED);\n\t  bookReservation.sendBookAvailableNotification();\n\t  return false;\n\t} else if (bookReservation != null) {\n\t  // book item has a pending reservation from this member\n\t  bookReservation.updateStatus(ReservationStatus.COMPLETED);\n\t}\n\tBookLending.lendBook(bookItem.getBarCode(), this.getMemberId());\n\tbookItem.updateDueDate(LocalDate.now().plusDays(Constants.MAX_LENDING_DAYS));\n\treturn true;\n  }\n}",
          "subPath": "accounts",
          "fileName": "solution.java"
        },
        "accounts_py": {
          "language": "py",
          "code": "# For simplicity, we are not defining getter and setter functions. The reader can\n# assume that all class attributes are private and accessed through their respective\n# public getter methods and modified only through their public methods function.\n\nfrom abc import ABC, abstractmethod\n\nclass Account(ABC):\n  def __init__(self, id, password, person, status=AccountStatus.Active):\n    self.__id = id\n    self.__password = password\n    self.__status = status\n    self.__person = person\n\n  def reset_password(self):\n    None\n\n\nclass Librarian(Account):\n  def __init__(self, id, password, person, status=AccountStatus.Active):\n    super().__init__(id, password, person, status)\n\n  def add_book_item(self, book_item):\n    None\n\n  def block_member(self, member):\n    None\n\n  def un_block_member(self, member):\n    None\n\n\nclass Member(Account):\n  def __init__(self, id, password, person, status=AccountStatus.Active):\n    super().__init__(id, password, person, status)\n    self.__date_of_membership = datetime.date.today()\n    self.__total_books_checkedout = 0\n\n  def get_total_books_checkedout(self):\n    return self.__total_books_checkedout\n\n  def reserve_book_item(self, book_item):\n    None\n\n  def increment_total_books_checkedout(self):\n    None\n\n  def renew_book_item(self, book_item):\n    None\n\n  def checkout_book_item(self, book_item):\n    if self.get_total_books_checked_out() >= Constants.MAX_BOOKS_ISSUED_TO_A_USER:\n      print(\"The user has already checked-out maximum number of books\")\n      return False\n    book_reservation = BookReservation.fetch_reservation_details(\n      book_item.get_barcode())\n    if book_reservation != None and book_reservation.get_member_id() != self.get_id():\n      # book item has a pending reservation from another user\n      print(\"self book is reserved by another member\")\n      return False\n    elif book_reservation != None:\n      # book item has a pending reservation from the give member, update it\n      book_reservation.update_status(ReservationStatus.COMPLETED)\n\n    if not book_item.checkout(self.get_id()):\n      return False\n\n    self.increment_total_books_checkedout()\n    return True\n\n  def check_for_fine(self, book_item_barcode):\n    book_lending = BookLending.fetch_lending_details(book_item_barcode)\n    due_date = book_lending.get_due_date()\n    today = datetime.date.today()\n    # check if the book has been returned within the due date\n    if today > due_date:\n      diff = today - due_date\n      diff_days = diff.days\n      Fine.collect_fine(self.get_member_id(), diff_days)\n\n  def return_book_item(self, book_item):\n    self.check_for_fine(book_item.get_barcode())\n    book_reservation = BookReservation.fetch_reservation_details(\n      book_item.get_barcode())\n    if book_reservation != None:\n      # book item has a pending reservation\n      book_item.update_book_item_status(BookStatus.RESERVED)\n      book_reservation.send_book_available_notification()\n    book_item.update_book_item_status(BookStatus.AVAILABLE)\n\n  def renew_book_item(self, book_item):\n    self.check_for_fine(book_item.get_barcode())\n    book_reservation = BookReservation.fetch_reservation_details(\n      book_item.get_barcode())\n    # check if self book item has a pending reservation from another member\n    if book_reservation != None and book_reservation.get_member_id() != self.get_member_id():\n      print(\"self book is reserved by another member\")\n      self.decrement_total_books_checkedout()\n      book_item.update_book_item_state(BookStatus.RESERVED)\n      book_reservation.send_book_available_notification()\n      return False\n    elif book_reservation != None:\n      # book item has a pending reservation from self member\n      book_reservation.update_status(ReservationStatus.COMPLETED)\n    BookLending.lend_book(book_item.get_bar_code(), self.get_member_id())\n    book_item.update_due_date(\n      datetime.datetime.now().AddDays(Constants.MAX_LENDING_DAYS))\n    return True",
          "subPath": "accounts",
          "fileName": "solution.py"
        },
        "books_java": {
          "language": "java",
          "code": "public abstract class Book {\n  private String ISBN;\n  private String title;\n  private String subject;\n  private String publisher;\n  private String language;\n  private int numberOfPages;\n  private List<Author> authors;\n}\n\npublic class BookItem extends Book {\n  private String barcode;\n  private boolean isReferenceOnly;\n  private Date borrowed;\n  private Date dueDate;\n  private double price;\n  private BookFormat format;\n  private BookStatus status;\n  private Date dateOfPurchase;\n  private Date publicationDate;\n  private Rack placedAt;\n\n  public boolean checkout(String memberId) {\n    if(bookItem.getIsReferenceOnly()) {\n      ShowError(\"This book is Reference only and can't be issued\");\n      return false;\n    }\n    if(!BookLending.lendBook(this.getBarCode(), memberId)){\n      return false;\n    }\n    this.updateBookItemStatus(BookStatus.LOANED);\n    return true;\n  }\n}\n\npublic class Rack {\n  private int number;\n  private String locationIdentifier;\n}",
          "subPath": "books",
          "fileName": "solution.java"
        },
        "books_py": {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Book(ABC):\n  def check_for_fine(self, ISBN, title, subject, publisher, language, number_of_pages):\n    self.__ISBN = ISBN\n    self.__title = title\n    self.__subject = subject\n    self.__publisher = publisher\n    self.__language = language\n    self.__number_of_pages = number_of_pages\n    self.__authors = []\n\n\nclass BookItem(Book):\n  def check_for_fine(self, barcode, is_reference_only, borrowed, due_date, price, book_format, status, date_of_purchase, publication_date, placed_at):\n    self.__barcode = barcode\n    self.__is_reference_only = is_reference_only\n    self.__borrowed = borrowed\n    self.__due_date = due_date\n    self.__price = price\n    self.__format = book_format\n    self.__status = status\n    self.__date_of_purchase = date_of_purchase\n    self.__publication_date = publication_date\n    self.__placed_at = placed_at\n\n  def checkout(self, member_id):\n    if self.get_is_reference_only():\n      print(\"self book is Reference only and can't be issued\")\n      return False\n    if not BookLending.lend_book(self.get_bar_code(), member_id):\n      return False\n    self.update_book_item_status(BookStatus.LOANED)\n    return True\n\n\nclass Rack:\n  def check_for_fine(self, number, location_identifier):\n    self.__number = number\n    self.__location_identifier = location_identifier",
          "subPath": "books",
          "fileName": "solution.py"
        },
        "enums_java": {
          "language": "java",
          "code": "public enum BookFormat {\n    HARDCOVER,\n    PAPERBACK,\n    AUDIO_BOOK,\n    EBOOK,\n    NEWSPAPER,\n    MAGAZINE,\n    JOURNAL\n}\n\npublic enum BookStatus {\n    AVAILABLE,\n    RESERVED,\n    LOANED,\n    LOST\n}\n\npublic enum ReservationStatus{\n    WAITING,\n    PENDING,\n    CANCELED,\n    NONE\n}\n\npublic enum AccountStatus{\n    ACTIVE,\n    CLOSED,\n    CANCELED,\n    BLACKLISTED,\n    NONE\n}\n\npublic class Address {\n    private String streetAddress;\n    private String city;\n    private String state;\n    private String zipCode;\n    private String country;\n}\n\npublic class Person {\n    private String name;\n    private Address address;\n    private String email;\n    private String phone;\n}\n\npublic class Constants {\n    public static final int MAX_BOOKS_ISSUED_TO_A_USER = 5;\n    public static final int MAX_LENDING_DAYS = 10;\n}",
          "subPath": "enums",
          "fileName": "solution.java"
        },
        "enums_py": {
          "language": "py",
          "code": "class BookFormat(Enum):\n  HARDCOVER, PAPERBACK, AUDIO_BOOK, EBOOK, NEWSPAPER, MAGAZINE, JOURNAL = 1, 2, 3, 4, 5, 6, 7\n\n\nclass BookStatus(Enum):\n  AVAILABLE, RESERVED, LOANED, LOST = 1, 2, 3, 4\n\n\nclass ReservationStatus(Enum):\n  WAITING, PENDING, CANCELED, NONE = 1, 2, 3, 4\n\n\nclass AccountStatus(Enum):\n  ACTIVE, CLOSED, CANCELED, BLACKLISTED, NONE = 1, 2, 3, 4, 5\n\n\nclass Address:\n  def __init__(self, street, city, state, zip_code, country):\n    self.__street_address = street\n    self.__city = city\n    self.__state = state\n    self.__zip_code = zip_code\n    self.__country = country\n\n\nclass Person(ABC):\n  def __init__(self, name, address, email, phone):\n    self.__name = name\n    self.__address = address\n    self.__email = email\n    self.__phone = phone\n\n\nclass Constants:\n  self.MAX_BOOKS_ISSUED_TO_A_USER = 5\n  self.MAX_LENDING_DAYS = 10",
          "subPath": "enums",
          "fileName": "solution.py"
        },
        "reservation_java": {
          "language": "java",
          "code": "public class BookReservation {\n  private Date creationDate;\n  private ReservationStatus status;\n  private String bookItemBarcode;\n  private String memberId;\n\n  public static BookReservation fetchReservationDetails(String barcode);\n}\n\npublic class BookLending {\n  private Date creationDate;\n  private Date dueDate;\n  private Date returnDate;\n  private String bookItemBarcode;\n  private String memberId;\n\n  public static void lendBook(String barcode, String memberId);\n  public static BookLending fetchLendingDetails(String barcode);\n}\n\npublic class Fine {\n  private Date creationDate;\n  private double bookItemBarcode;\n  private String memberId;\n\n  public static void collectFine(String memberId, long days) {}\n}",
          "subPath": "reservation",
          "fileName": "solution.java"
        },
        "reservation_py": {
          "language": "py",
          "code": "class BookReservation:\n  def check_for_fine(self, creation_date, status, book_item_barcode, member_id):\n    self.__creation_date = creation_date\n    self.__status = status\n    self.__book_item_barcode = book_item_barcode\n    self.__member_id = member_id\n\n  def fetch_reservation_details(self, barcode):\n    None\n\n\nclass BookLending:\n  def check_for_fine(self, creation_date, due_date, book_item_barcode, member_id):\n    self.__creation_date = creation_date\n    self.__due_date = due_date\n    self.__return_date = None\n    self.__book_item_barcode = book_item_barcode\n    self.__member_id = member_id\n\n  def lend_book(self, barcode, member_id):\n    None\n\n  def fetch_lending_details(self, barcode):\n    None\n\n\nclass Fine:\n  def check_for_fine(self, creation_date, book_item_barcode, member_id):\n    self.__creation_date = creation_date\n    self.__book_item_barcode = book_item_barcode\n    self.__member_id = member_id\n\n  def collect_fine(self, member_id, days):\n    None",
          "subPath": "reservation",
          "fileName": "solution.py"
        },
        "search_java": {
          "language": "java",
          "code": "public interface Search {\n  public List<Book> searchByTitle(String title);\n  public List<Book> searchByAuthor(String author);\n  public List<Book> searchBySubject(String subject);\n  public List<Book> searchByPubDate(Date publishDate);\n}\n\npublic class Catalog implements Search {\n  private HashMap<String, List<Book>> bookTitles;\n  private HashMap<String, List<Book>> bookAuthors;\n  private HashMap<String, List<Book>> bookSubjects;\n  private HashMap<String, List<Book>> bookPublicationDates;\n\n  public List<Book> searchByTitle(String query) {\n    // return all books containing the string query in their title.\n    return bookTitles.get(query);\n  }\n\n  public List<Book> searchByAuthor(String query) {\n    // return all books containing the string query in their author's name.\n    return bookAuthors.get(query);\n  }\n}",
          "subPath": "search",
          "fileName": "solution.java"
        },
        "search_py": {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Search(ABC):\n  def search_by_title(self, title):\n    None\n\n  def search_by_author(self, author):\n    None\n\n  def search_by_subject(self, subject):\n    None\n\n  def search_by_pub_date(self, publish_date):\n    None\n\n\nclass Catalog(Search):\n  def check_for_fine(self):\n    self.__book_titles = {}\n    self.__book_authors = {}\n    self.__book_subjects = {}\n    self.__book_publication_dates = {}\n\n  def search_by_title(self, query):\n    # return all books containing the string query in their title.\n    return self.__book_titles.get(query)\n\n  def search_by_author(self, query):\n    # return all books containing the string query in their author's name.\n    return self.__book_authors.get(query)",
          "subPath": "search",
          "fileName": "solution.py"
        }
      }
    },
    "movie-booking": {
      "id": "movie-booking",
      "title": "Design a Movie Ticket Booking System",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Design a Movie Ticket Booking System\"\nauthor: \"Rajat Srivastava\"\ncategories: system-designs\ntags: [system-design, hld, lld]\ndescription: \"System design concepts and patterns\"\n---\n\nAn online movie ticket booking system facilitates the purchasing of movie tickets to its customers. E-ticketing systems allow customers to browse through movies currently playing and book seats, anywhere and anytime.\n\n---\n## System Requirements\nOur ticket booking service should meet the following requirements:\n1. It should be able to list the cities where affiliate cinemas are located.\n2. Each cinema can have multiple halls and each hall can run one movie show at a time.\n3. Each Movie will have multiple shows.\n4. Customers should be able to search movies by their title, language, genre, release date, and city name.\n5. Once the customer selects a movie, the service should display the cinemas running that movie and its available shows.\n6. The customer should be able to select a show at a particular cinema and book their tickets.\n7. The service should show the customer the seating arrangement of the cinema hall. The customer should be able to select multiple seats according to their preference.\n8. The customer should be able to distinguish between available seats and booked ones.\n9. The system should send notifications whenever there is a new movie, as well as when a booking is made or canceled.\n10. Customers of our system should be able to pay with credit cards or cash.\n11. The system should ensure that no two customers can reserve the same seat.\n12. Customers should be able to add a discount coupon to their payment.\n\n---\n## Use Case Diagrams\nWe have five main Actors in our system:\n\n- **Admin:** Responsible for adding new movies and their shows, canceling any movie or show, blocking/unblocking customers, etc.\n- **FrontDeskOfficer:** Can book/cancel tickets.\n- **Customer:** Can view movie schedules, book, and cancel tickets.\n- **Guest:** All guests can search movies but to book seats they have to become a registered member.\n- **System:** Mainly responsible for sending notifications for new movies, bookings, cancellations, etc.\n\nHere are the top use cases of the Movie Ticket Booking System:\n\n- **Search movies:** To search movies by title, genre, language, release date, and city name.\n- **Create/Modify/View booking:** To book a movie show ticket, cancel it or view details about the show.\n- **Make payment for booking:** To pay for the booking.\n- **Add a coupon to the payment:** To add a discount coupon to the payment.\n- **Assign Seat:** Customers will be shown a seat map to let them select seats for their booking.\n- **Refund payment:** Upon cancellation, customers will be refunded the payment amount as long as the cancellation occurs within the allowed time frame.\n\n<MdxImage \n  src=\"design/movie-booking/use-case.svg\" \n  alt=\"Usecase Diagram for Movie Booking System\"\n/>\n\n---\n## Class Diagrams\nHere are the main classes of the Movie Ticket Booking System:\n\n- **Account:** Admin will be able to add/remove movies and shows, as well as block/unblock accounts. Customers can search for movies and make bookings for shows. FrontDeskOffice can book tickets for movie shows\n- **Guest:** Guests can search and view movies descriptions. To make a booking for a show they have to become a registered member.\n- **Cinema:** The main part of the organization for which this software has been designed. It has attributes like name to distinguish it from other cinemas.\n- **CinemaHall:** Each cinema will have multiple halls containing multiple seats.\n- **City:** Each city can have multiple cinemas.\n- **Movie:** The main entity of the system. Movies have attributes like title, description, language, genre, release date, city name, etc.\n- **Show:** Each movie can have many shows; each show will be played in a cinema hall.\n- **CinemaHallSeat:** Each cinema hall will have many seats.\n- **ShowSeat:** Each ShowSeat will correspond to a movie Show and a CinemaHallSeat. Customers will make a booking against a ShowSeat.\n- **Booking:** A booking is against a movie show and has attributes like a unique booking number, number of seats, and status.\n- **Payment:** Responsible for collecting payments from customers.\n- **Notification:** Will take care of sending notifications to customers.\n\n<MdxImage \n  src=\"design/movie-booking/class-diagram.png\" \n  alt=\"Class Diagram for Movie Booking System\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"Uml\"\n/>\n\n---\n## Activity Diagram\n**Make a booking:** Any customer can perform this activity. Here are the steps to book a ticket for a show:\n\n<MdxImage \n  src=\"design/movie-booking/activity-book.svg\" \n  alt=\"Activity Diagram for Movie Booking System\"\n/>\n\n**Cancel a booking:** Customer can cancel their bookings. Here are the steps to cancel a booking:\n\n<MdxImage \n  src=\"design/movie-booking/activity-cancel.svg\" \n  alt=\"Activity Diagram for Movie Booking System\"\n/>\n\n---\n## Code\nHere is the high-level definition for the classes described above.\n\n- **Enums and Constants:** Here are the required enums, data types, and constants:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/enums\"\n/>\n\n- **Account, Customer, Admin, FrontDeskOfficer, and Guest:** These classes represent the different people that interact with our system:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/accounts\"\n/>\n\n- **Show and Movie:**  A movie will have many shows:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/show\"\n/>\n\n- **Booking, ShowSeat, and Payment:** Customers will reserve seats with a booking and make a payment:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/booking\"\n/>\n\n- **City, Cinema, and CinemaHall:** Each city can have many cinemas and each cinema can have many cinema halls:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/cinema\"\n/>\n\n- **Search interface and Catalog:** Catalog will implement Search to facilitate searching of products.\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/search\"\n/>\n\n---\n## Concurrency\n**How to handle concurrency; such that no two users are able to book the same seat?**\nWe can use transactions in SQL databases to avoid any clashes. For example, if we are using SQL server we can utilize Transaction Isolation Levels to lock the rows before we update them. Note: within a transaction, if we read rows we get a write-lock on them so that they cant be updated by anyone else. Here is the sample code:\n\n<MdxCodeTabs\n  langs={[\"sql\"]}\n  path=\"system-design/code/movie-booking/concurrency\"\n/>\n\n\n'Serializable' is the highest isolation level and guarantees safety from <MdxLink href=\"https://en.wikipedia.org/wiki/Isolation_(database_systems)#Dirty_reads\">Dirty Reads</MdxLink>, <MdxLink href=\"https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads\">Nonrepeatable</MdxLink>, and <MdxLink href=\"https://en.wikipedia.org/wiki/Isolation_(database_systems)#Phantom_reads\">Phantoms reads</MdxLink>.\n\nOnce the above database transaction is successful, we can safely assume that the reservation has been marked successfully and no two customers will be able to reserve the same seat.\n\nHere is the sample Java code:\n\n<MdxCodeTabs\n  langs={[\"java\"]}\n  path=\"system-design/code/movie-booking/concurrency\"\n/>",
      "body": "An online movie ticket booking system facilitates the purchasing of movie tickets to its customers. E-ticketing systems allow customers to browse through movies currently playing and book seats, anywhere and anytime.\n\n---\n## System Requirements\nOur ticket booking service should meet the following requirements:\n1. It should be able to list the cities where affiliate cinemas are located.\n2. Each cinema can have multiple halls and each hall can run one movie show at a time.\n3. Each Movie will have multiple shows.\n4. Customers should be able to search movies by their title, language, genre, release date, and city name.\n5. Once the customer selects a movie, the service should display the cinemas running that movie and its available shows.\n6. The customer should be able to select a show at a particular cinema and book their tickets.\n7. The service should show the customer the seating arrangement of the cinema hall. The customer should be able to select multiple seats according to their preference.\n8. The customer should be able to distinguish between available seats and booked ones.\n9. The system should send notifications whenever there is a new movie, as well as when a booking is made or canceled.\n10. Customers of our system should be able to pay with credit cards or cash.\n11. The system should ensure that no two customers can reserve the same seat.\n12. Customers should be able to add a discount coupon to their payment.\n\n---\n## Use Case Diagrams\nWe have five main Actors in our system:\n\n- **Admin:** Responsible for adding new movies and their shows, canceling any movie or show, blocking/unblocking customers, etc.\n- **FrontDeskOfficer:** Can book/cancel tickets.\n- **Customer:** Can view movie schedules, book, and cancel tickets.\n- **Guest:** All guests can search movies but to book seats they have to become a registered member.\n- **System:** Mainly responsible for sending notifications for new movies, bookings, cancellations, etc.\n\nHere are the top use cases of the Movie Ticket Booking System:\n\n- **Search movies:** To search movies by title, genre, language, release date, and city name.\n- **Create/Modify/View booking:** To book a movie show ticket, cancel it or view details about the show.\n- **Make payment for booking:** To pay for the booking.\n- **Add a coupon to the payment:** To add a discount coupon to the payment.\n- **Assign Seat:** Customers will be shown a seat map to let them select seats for their booking.\n- **Refund payment:** Upon cancellation, customers will be refunded the payment amount as long as the cancellation occurs within the allowed time frame.\n\n<MdxImage \n  src=\"design/movie-booking/use-case.svg\" \n  alt=\"Usecase Diagram for Movie Booking System\"\n/>\n\n---\n## Class Diagrams\nHere are the main classes of the Movie Ticket Booking System:\n\n- **Account:** Admin will be able to add/remove movies and shows, as well as block/unblock accounts. Customers can search for movies and make bookings for shows. FrontDeskOffice can book tickets for movie shows\n- **Guest:** Guests can search and view movies descriptions. To make a booking for a show they have to become a registered member.\n- **Cinema:** The main part of the organization for which this software has been designed. It has attributes like name to distinguish it from other cinemas.\n- **CinemaHall:** Each cinema will have multiple halls containing multiple seats.\n- **City:** Each city can have multiple cinemas.\n- **Movie:** The main entity of the system. Movies have attributes like title, description, language, genre, release date, city name, etc.\n- **Show:** Each movie can have many shows; each show will be played in a cinema hall.\n- **CinemaHallSeat:** Each cinema hall will have many seats.\n- **ShowSeat:** Each ShowSeat will correspond to a movie Show and a CinemaHallSeat. Customers will make a booking against a ShowSeat.\n- **Booking:** A booking is against a movie show and has attributes like a unique booking number, number of seats, and status.\n- **Payment:** Responsible for collecting payments from customers.\n- **Notification:** Will take care of sending notifications to customers.\n\n<MdxImage \n  src=\"design/movie-booking/class-diagram.png\" \n  alt=\"Class Diagram for Movie Booking System\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"Uml\"\n/>\n\n---\n## Activity Diagram\n**Make a booking:** Any customer can perform this activity. Here are the steps to book a ticket for a show:\n\n<MdxImage \n  src=\"design/movie-booking/activity-book.svg\" \n  alt=\"Activity Diagram for Movie Booking System\"\n/>\n\n**Cancel a booking:** Customer can cancel their bookings. Here are the steps to cancel a booking:\n\n<MdxImage \n  src=\"design/movie-booking/activity-cancel.svg\" \n  alt=\"Activity Diagram for Movie Booking System\"\n/>\n\n---\n## Code\nHere is the high-level definition for the classes described above.\n\n- **Enums and Constants:** Here are the required enums, data types, and constants:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/enums\"\n/>\n\n- **Account, Customer, Admin, FrontDeskOfficer, and Guest:** These classes represent the different people that interact with our system:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/accounts\"\n/>\n\n- **Show and Movie:**  A movie will have many shows:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/show\"\n/>\n\n- **Booking, ShowSeat, and Payment:** Customers will reserve seats with a booking and make a payment:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/booking\"\n/>\n\n- **City, Cinema, and CinemaHall:** Each city can have many cinemas and each cinema can have many cinema halls:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/cinema\"\n/>\n\n- **Search interface and Catalog:** Catalog will implement Search to facilitate searching of products.\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/movie-booking/search\"\n/>\n\n---\n## Concurrency\n**How to handle concurrency; such that no two users are able to book the same seat?**\nWe can use transactions in SQL databases to avoid any clashes. For example, if we are using SQL server we can utilize Transaction Isolation Levels to lock the rows before we update them. Note: within a transaction, if we read rows we get a write-lock on them so that they cant be updated by anyone else. Here is the sample code:\n\n<MdxCodeTabs\n  langs={[\"sql\"]}\n  path=\"system-design/code/movie-booking/concurrency\"\n/>\n\n\n'Serializable' is the highest isolation level and guarantees safety from <MdxLink href=\"https://en.wikipedia.org/wiki/Isolation_(database_systems)#Dirty_reads\">Dirty Reads</MdxLink>, <MdxLink href=\"https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads\">Nonrepeatable</MdxLink>, and <MdxLink href=\"https://en.wikipedia.org/wiki/Isolation_(database_systems)#Phantom_reads\">Phantoms reads</MdxLink>.\n\nOnce the above database transaction is successful, we can safely assume that the reservation has been marked successfully and no two customers will be able to reserve the same seat.\n\nHere is the sample Java code:\n\n<MdxCodeTabs\n  langs={[\"java\"]}\n  path=\"system-design/code/movie-booking/concurrency\"\n/>",
      "solutions": {
        "accounts_java": {
          "language": "java",
          "code": "// For simplicity, we are not defining getter and setter functions. The reader can\n// assume that all class attributes are private and accessed through their respective\n// public getter method and modified only through their public setter method.\n\npublic class Account {\n  private String id;\n  private String password;\n  private AccountStatus status;\n\n  public boolean resetPassword();\n}\n\npublic abstract class Person {\n  private String name;\n  private Address address;\n  private String email;\n  private String phone;\n\n  private Account account;\n}\n\npublic class Customer extends Person {\n  public boolean makeBooking(Booking booking);\n  public List<Booking> getBookings();\n}\n\npublic class Admin extends Person {\n  public boolean addMovie(Movie movie);\n  public boolean addShow(Show show);\n  public boolean blockUser(Customer customer);\n}\n\npublic class FrontDeskOfficer extends Person {\n  public boolean createBooking(Booking booking);\n}\n\npublic class Guest {\n  public bool registerAccount();\n}",
          "subPath": "accounts",
          "fileName": "solution.java"
        },
        "accounts_py": {
          "language": "py",
          "code": "# For simplicity, we are not defining getter and setter functions. The reader can\n# assume that all class attributes are private and accessed through their respective\n# public getter methods and modified only through their public methods function.\n\n\nclass Account:\n  def __init__(self, id, password, status=AccountStatus.Active):\n    self.__id = id\n    self.__password = password\n    self.__status = status\n\n  def reset_password(self):\n    None\n\n\n# from abc import ABC, abstractmethod\nclass Person(ABC):\n  def __init__(self, name, address, email, phone, account):\n    self.__name = name\n    self.__address = address\n    self.__email = email\n    self.__phone = phone\n    self.__account = account\n\n\nclass Customer(Person):\n  def make_booking(self, booking):\n    None\n\n  def get_bookings(self):\n    None\n\n\nclass Admin(Person):\n  def add_movie(self, movie):\n    None\n\n  def add_show(self, show):\n    None\n\n  def block_user(self, customer):\n    None\n\n\nclass FrontDeskOfficer(Person):\n  def create_booking(self, booking):\n    None\n\n\nclass Guest:\n  def register_account(self):\n    None",
          "subPath": "accounts",
          "fileName": "solution.py"
        },
        "booking_java": {
          "language": "java",
          "code": "public class Booking {\n  private String bookingNumber;\n  private int numberOfSeats;\n  private Date createdOn;\n  private BookingStatus status;\n\n  private Show show;\n  private List<ShowSeat> seats;\n  private Payment payment;\n\n  public boolean makePayment(Payment payment);\n  public boolean cancel();\n  public boolean assignSeats(List<ShowSeat> seats);\n}\n\npublic class ShowSeat extends CinemaHallSeat{\n  private int showSeatId;\n  private boolean isReserved;\n  private double price;\n}\n\npublic class Payment {\n  private double amount;\n  private Date createdOn;\n  private int transactionId;\n  private PaymentStatus status;\n}",
          "subPath": "booking",
          "fileName": "solution.java"
        },
        "booking_py": {
          "language": "py",
          "code": "class Booking:\n  def __init__(self, booking_number, number_of_seats, status, show, show_seats, payment):\n    self.__booking_number = booking_number\n    self.__number_of_seats = number_of_seats\n    self.__created_on = datetime.date.today()\n    self.__status = status\n    self.__show = show\n    self.__seats = show_seats\n    self.__payment = payment\n\n  def make_payment(self, payment):\n    None\n\n  def cancel(self):\n    None\n\n  def assign_seats(self, seats):\n    None\n\n\nclass ShowSeat(CinemaHallSeat):\n  def __init__(self, id, is_reserved, price):\n    self.__show_seat_id = id\n    self.__is_reserved = is_reserved\n    self.__price = price\n\n\nclass Payment:\n  def __init__(self, amount, transaction_id, payment_status):\n    self.__amount = amount\n    self.__created_on = datetime.date.today()\n    self.__transaction_id = transaction_id\n    self.__status = payment_status",
          "subPath": "booking",
          "fileName": "solution.py"
        },
        "cinema_java": {
          "language": "java",
          "code": "public class City {\n  private String name;\n  private String state;\n  private String zipCode;\n}\n\npublic class Cinema {\n  private String name;\n  private int totalCinemaHalls;\n  private Address location;\n\n  private List<CinemaHall> halls;\n}\n\npublic class CinemaHall {\n  private String name;\n  private int totalSeats;\n\n  private List<CinemaHallSeat> seats;\n  private List<Show> shows;\n}",
          "subPath": "cinema",
          "fileName": "solution.java"
        },
        "cinema_py": {
          "language": "py",
          "code": "class City:\n  def __init__(self, name, state, zip_code):\n    self.__name = name\n    self.__state = state\n    self.__zip_code = zip_code\n\n\nclass Cinema:\n  def __init__(self, name, total_cinema_halls, address, halls):\n    self.__name = name\n    self.__total_cinema_halls = total_cinema_halls\n    self.__location = address\n\n    self.__halls = halls\n\n\nclass CinemaHall:\n  def __init__(self, name, total_seats, seats, shows):\n    self.__name = name\n    self.__total_seats = total_seats\n\n    self.__seats = seats\n    self.__shows = shows",
          "subPath": "cinema",
          "fileName": "solution.py"
        },
        "concurrency_java": {
          "language": "java",
          "code": "import java.sql.DriverManager;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.ResultSet;\n\npublic class Customer extends Person {\n\n  public boolean makeBooking(Booking booking) {\n    List<ShowSeat> seats = booking.getSeats();\n    Integer seatIds[] = new Integer[seats.size()];\n    int index = 0;\n    for(ShowSeat seat : seats) {\n      seatIds[index++] = seat.getShowSeatId();\n    }\n\n    Connection dbConnection = null;\n    try {\n      dbConnection = getDBConnection();\n      dbConnection.setAutoCommit(false);\n      // Serializable is the highest isolation level and guarantees safety from\n      // Dirty, Nonrepeatable, and Phantoms reads\n      dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n\n      Statement st = dbConnection.createStatement();\n      String selectSQL = \"Select * From ShowSeat where ShowID=? && ShowSeatID in (?) && isReserved=0\";\n      PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\n      preparedStatement.setInt(1, booking.getShow().getShowId());\n      Array array = dbConnection.createArrayOf(\"INTEGER\", seatIds);\n      preparedStatement.setArray(2, array);\n\n      ResultSet rs = preparedStatement.executeQuery();\n      // With TRANSACTION_SERIALIZABLE all the read rows will have the write lock, so we can\n      // safely assume that no one else is modifying them.\n      if (rs.next()) {\n        rs.last(); // move to the last row, to calculate the row count\n        int rowCount = rs.getRow();\n        // check if we have expected number of rows, if not, this means another process is\n        // trying to process at least one of the same row, if that is the case we\n        // should not process this booking.\n        if(rowCount == seats.size()) {\n          // update ShowSeat table...\n          // update Booking table ...\n          dbConnection.commit();\n          return true;\n        }\n      }\n    } catch (SQLException e) {\n      dbConnection.rollback();\n      System.out.println(e.getMessage());\n    }\n    return false;\n  }\n}",
          "subPath": "concurrency",
          "fileName": "solution.java"
        },
        "concurrency_sql": {
          "language": "sql",
          "code": "SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n \nBEGIN TRANSACTION;\n \n    -- Suppose we intend to reserve three seats (IDs: 54, 55, 56) for ShowID=99 \n    Select * From ShowSeat where ShowID=99 && ShowSeatID in (54, 55, 56) && isReserved=0 \n \n    -- if the number of rows returned by the above statement is NOT three, we can return failure to the user.\n    update ShowSeat table...\n    update Booking table ...\n \nCOMMIT TRANSACTION;",
          "subPath": "concurrency",
          "fileName": "solution.sql"
        },
        "enums_java": {
          "language": "java",
          "code": "public enum BookingStatus {\n    REQUESTED, PENDING, CONFIRMED, CHECKED_IN, CANCELED, ABANDONED\n}\n  \npublic enum SeatType {\n    REGULAR, PREMIUM, ACCESSIBLE, SHIPPED, EMERGENCY_EXIT, OTHER\n}\n\npublic enum AccountStatus {\n    ACTIVE, BLOCKED, BANNED, COMPROMISED, ARCHIVED, UNKNOWN\n}\n\npublic enum PaymentStatus {\n    UNPAID, PENDING, COMPLETED, FILLED, DECLINED, CANCELLED, ABANDONED, SETTLING, SETTLED, REFUNDED\n}\n\npublic class Address {\n    private String streetAddress;\n    private String city;\n    private String state;\n    private String zipCode;\n    private String country;\n}",
          "subPath": "enums",
          "fileName": "solution.java"
        },
        "enums_py": {
          "language": "py",
          "code": "class BookingStatus(Enum):\n  REQUESTED, PENDING, CONFIRMED, CHECKED_IN, CANCELED, ABANDONED = 1, 2, 3, 4, 5, 6\n\n\nclass SeatType(Enum):\n  REGULAR, PREMIUM, ACCESSIBLE, SHIPPED, EMERGENCY_EXIT, OTHER = 1, 2, 3, 4, 5, 6\n\n\nclass AccountStatus(Enum):\n  ACTIVE, BLOCKED, BANNED, COMPROMISED, ARCHIVED, UNKNOWN = 1, 2, 3, 4, 5, 6\n\n\nclass PaymentStatus(Enum):\n  UNPAID, PENDING, COMPLETED, FILLED, DECLINED, CANCELLED, ABANDONED, SETTLING, SETTLED, REFUNDED = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\n\nclass Address:\n  def __init__(self, street, city, state, zip_code, country):\n    self.__street_address = street\n    self.__city = city\n    self.__state = state\n    self.__zip_code = zip_code\n    self.__country = country",
          "subPath": "enums",
          "fileName": "solution.py"
        },
        "search_java": {
          "language": "java",
          "code": "public interface Search {\n  public List<Movie> searchByTitle(String title);\n  public List<Movie> searchByLanguage(String language);\n  public List<Movie> searchByGenre(String genre);\n  public List<Movie> searchByReleaseDate(Date relDate);\n  public List<Movie> searchByCity(String cityName);\n}\n\npublic class Catalog implements Search {\n   HashMap<String, List<Movie>> movieTitles;\n   HashMap<String, List<Movie>> movieLanguages;\n   HashMap<String, List<Movie>> movieGenres;\n   HashMap<Date, List<Movie>> movieReleaseDates;\n   HashMap<String, List<Movie>> movieCities;\n\n  public List<Movie> searchByTitle(String title) {\n    return movieTitles.get(title);\n  }\n\n  public List<Movie> searchByLanguage(String language) {\n    return movieLanguages.get(language);\n  }\n\n  //...\n\n  public List<Movie> searchByCity(String cityName) {\n    return movieCities.get(cityName);\n  }\n}",
          "subPath": "search",
          "fileName": "solution.java"
        },
        "search_py": {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Search(ABC):\n  def search_by_title(self, title):\n    None\n\n  def search_by_language(self, language):\n    None\n\n  def search_by_genre(self, genre):\n    None\n\n  def search_by_release_date(self, rel_date):\n    None\n\n  def search_by_city(self, city_name):\n    None\n\n\nclass Catalog(Search):\n  def __init__(self):\n    self.__movie_titles = {}\n    self.__movie_languages = {}\n    self.__movie_genres = {}\n    self.__movie_release_dates = {}\n    self.__movie_cities = {}\n\n    def search_by_title(self, title):\n      return self.__movie_titles.get(title)\n\n    def search_by_language(self, language):\n      return self.__movie_languages.get(language)\n\n    # ...\n\n    def search_by_city(self, city_name):\n      return self.__movie_cities.get(city_name)",
          "subPath": "search",
          "fileName": "solution.py"
        },
        "show_java": {
          "language": "java",
          "code": "public class Show {\n  private int showId;\n  private Date createdOn;\n  private Date startTime;\n  private Date endTime;\n  private CinemaHall playedAt;\n  private Movie movie;\n}\n\npublic class Movie {\n  private String title;\n  private String description;\n  private int durationInMins;\n  private String language;\n  private Date releaseDate;\n  private String country;\n  private String genre;\n  private Admin movieAddedBy;\n\n  private List<Show> shows;\n  public List<Show> getShows();\n}",
          "subPath": "show",
          "fileName": "solution.java"
        },
        "show_py": {
          "language": "py",
          "code": "class Show:\n  def __init__(self, id, played_at, movie, start_time, end_time):\n    self.__show_id = id\n    self.__created_on = datetime.date.today()\n    self.__start_time = start_time\n    self.__end_time = end_time\n    self.__played_at = played_at\n    self.__movie = movie\n\n\nclass Movie:\n  def __init__(self, title, description, duration_in_mins, language, release_date, country, genre, added_by):\n    self.__title = title\n    self.__description = description\n    self.__duration_in_mins = duration_in_mins\n    self.__language = language\n    self.__release_date = release_date\n    self.__country = country\n    self.__genre = genre\n    self.__movie_added_by = added_by\n\n    self.__shows = []\n\n  def get_shows(self):\n    None",
          "subPath": "show",
          "fileName": "solution.py"
        }
      }
    },
    "online-shopping": {
      "id": "online-shopping",
      "title": "Design Amazon - Online Shopping System",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Design Amazon - Online Shopping System\"\nauthor: \"Rajat Srivastava\"\ncategories: system-designs\ntags: [system-design, hld, lld]\ndescription: \"System design concepts and patterns\"\n---\n\n<MdxLink href=\"https://amazon.com\">Amazon</MdxLink> is the world's largest online retailer. The company was originally a bookseller but has expanded to sell a wide variety of consumer goods and digital media. For the sake of this problem, we will focus on their online retail business where users can sell/buy their products.\n\n---\n## System Requirements\nWe will be designing a system with the following requirements:\n1. Users should be able to add new products to sell.\n2. Users should be able to search for products by their name or category.\n3. Users can search and view all the products, but they will have to become a registered member to buy a product.\n4. Users should be able to add/remove/modify product items in their shopping cart.\n5. Users can check out and buy items in the shopping cart.\n6. Users can rate and add a review for a product.\n7. The user should be able to specify a shipping address where their order will be delivered.\n8. Users can cancel an order if it has not shipped.\n9. Users should get notifications whenever there is a change in the order or shipping status.\n10. Users should be able to pay through credit cards or electronic bank transfer.\n11. Users should be able to track their shipment to see the current state of their order.\n\n---\n## Use Case Diagrams\nWe have four main Actors in our system:\n\n- **Admin:** Mainly responsible for account management and adding or modifying new product categories.\n- **Guest:** All guests can search the catalog, add/remove items to the shopping cart, as well as become registered members.\n- **Member:** Members can perform all the activities that guests can, in addition to which, they can place orders and add new products to sell.\n- **System:** Mainly responsible for sending notifications for orders and shipping updates.\n\nHere are the top use cases of the Online Shopping System:\n1. Add/update products; whenever a product is added or modified, we will update the catalog.\n2. Search for products by their name or category.\n3. Add/remove product items in the shopping cart.\n4. Check-out to buy product items in the shopping cart.\n5. Make a payment to place an order.\n6. Add a new product category.\n7. Send notifications to members with shipment updates.\n\n<MdxImage \n  src=\"design/online-shopping/use-case.svg\" \n  alt=\"Usecase Diagram for Online Shopping\"\n/>\n\n---\n## Class Diagrams\nHere are the descriptions of the different classes of our Online Shopping System:\n\n- **Account:** There are two types of registered accounts in the system: one will be an Admin, who is responsible for adding new product categories and blocking/unblocking members; the other, a Member, who can buy/sell products.\n- **Guest:** Guests can search for and view products, and add them in the shopping cart. To place an order they have to become a registered member.\n- **Catalog:** Users of our system can search for products by their name or category. This class will keep an index of all products for faster search.\n- **ProductCategory:** This will encapsulate the different categories of products, such as books, electronics, etc.\n- **Product:** This class will encapsulate the entity that the users of our system will be buying and selling. Each Product will belong to a ProductCategory.\n- **ProductReview:** Any registered member can add a review about a product.\n- **ShoppingCart:** Users will add product items that they intend to buy to the shopping cart.\n- **Item:** This class will encapsulate a product item that the users will be buying or placing in the shopping cart. For example, a pen could be a product and if there are 10 pens in the inventory, each of these 10 pens will be considered a product item.\n- **Order:** This will encapsulate a buying order to buy everything in the shopping cart.\n- **OrderLog:** Will keep a track of the status of orders, such as unshipped, pending, complete, canceled, etc.\n- **ShipmentLog:** Will keep a track of the status of shipments, such as pending, shipped, delivered, etc.\n- **Notification:** This class will take care of sending notifications to customers.\n- **Payment:** This class will encapsulate the payment for an order. Members can pay through credit card or electronic bank transfer.\n\n<MdxImage \n  src=\"design/online-shopping/class-diagram.png\" \n  alt=\"Class Diagram for Online Shopping\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"Uml\"\n/>\n\n---\n## Activity Diagram\nFollowing is the activity diagram for a user performing online shopping:\n\n<MdxImage \n  src=\"design/online-shopping/activity.svg\" \n  alt=\"Activity Diagram for Online Shopping\"\n/>\n\n---\n## Sequence Diagram\n1. Here is the sequence diagram for searching from the catalog:\n\n<MdxImage \n  src=\"design/online-shopping/sequence-searching.svg\" \n  alt=\"Sequence Diagram for Online Shopping\"\n/>\n\n2. Here is the sequence diagram for adding an item to the shopping cart:\n\n<MdxImage \n  src=\"design/online-shopping/sequence-adding-items.svg\" \n  alt=\"Sequence Diagram for Online Shopping\"\n/>\n\n3. Here is the sequence diagram for checking out to place an order:\n\n<MdxImage \n  src=\"design/online-shopping/sequence-checkout.svg\" \n  alt=\"Sequence Diagram for Online Shopping\"\n/>\n\n---\n## Code\nHere is the high-level definition for the classes described above.\n\n- **Enums and Constants:** Here are the required enums, data types, and constants:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/enums\"\n/>\n\n- **Account, Customer, Admin, and Guest:** These classes represent different people that interact with our system:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/accounts\"\n/>\n\n- **ProductCategory, Product, and ProductReview:** Here are the classes related to a product:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/product\"\n/>\n\n- **ShoppingCart, Item, Order, and OrderLog:** Users will add items to the shopping cart and place an order to buy all the items in the cart.\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/cart\"\n/>\n\n- **Shipment, ShipmentLog, and Notification:** After successfully placing an order, a shipment record will be created:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/shipment\"\n/>\n\n- **Search interface and Catalog:** Catalog will implement Search to facilitate searching of products.\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/search\"\n/>",
      "body": "<MdxLink href=\"https://amazon.com\">Amazon</MdxLink> is the world's largest online retailer. The company was originally a bookseller but has expanded to sell a wide variety of consumer goods and digital media. For the sake of this problem, we will focus on their online retail business where users can sell/buy their products.\n\n---\n## System Requirements\nWe will be designing a system with the following requirements:\n1. Users should be able to add new products to sell.\n2. Users should be able to search for products by their name or category.\n3. Users can search and view all the products, but they will have to become a registered member to buy a product.\n4. Users should be able to add/remove/modify product items in their shopping cart.\n5. Users can check out and buy items in the shopping cart.\n6. Users can rate and add a review for a product.\n7. The user should be able to specify a shipping address where their order will be delivered.\n8. Users can cancel an order if it has not shipped.\n9. Users should get notifications whenever there is a change in the order or shipping status.\n10. Users should be able to pay through credit cards or electronic bank transfer.\n11. Users should be able to track their shipment to see the current state of their order.\n\n---\n## Use Case Diagrams\nWe have four main Actors in our system:\n\n- **Admin:** Mainly responsible for account management and adding or modifying new product categories.\n- **Guest:** All guests can search the catalog, add/remove items to the shopping cart, as well as become registered members.\n- **Member:** Members can perform all the activities that guests can, in addition to which, they can place orders and add new products to sell.\n- **System:** Mainly responsible for sending notifications for orders and shipping updates.\n\nHere are the top use cases of the Online Shopping System:\n1. Add/update products; whenever a product is added or modified, we will update the catalog.\n2. Search for products by their name or category.\n3. Add/remove product items in the shopping cart.\n4. Check-out to buy product items in the shopping cart.\n5. Make a payment to place an order.\n6. Add a new product category.\n7. Send notifications to members with shipment updates.\n\n<MdxImage \n  src=\"design/online-shopping/use-case.svg\" \n  alt=\"Usecase Diagram for Online Shopping\"\n/>\n\n---\n## Class Diagrams\nHere are the descriptions of the different classes of our Online Shopping System:\n\n- **Account:** There are two types of registered accounts in the system: one will be an Admin, who is responsible for adding new product categories and blocking/unblocking members; the other, a Member, who can buy/sell products.\n- **Guest:** Guests can search for and view products, and add them in the shopping cart. To place an order they have to become a registered member.\n- **Catalog:** Users of our system can search for products by their name or category. This class will keep an index of all products for faster search.\n- **ProductCategory:** This will encapsulate the different categories of products, such as books, electronics, etc.\n- **Product:** This class will encapsulate the entity that the users of our system will be buying and selling. Each Product will belong to a ProductCategory.\n- **ProductReview:** Any registered member can add a review about a product.\n- **ShoppingCart:** Users will add product items that they intend to buy to the shopping cart.\n- **Item:** This class will encapsulate a product item that the users will be buying or placing in the shopping cart. For example, a pen could be a product and if there are 10 pens in the inventory, each of these 10 pens will be considered a product item.\n- **Order:** This will encapsulate a buying order to buy everything in the shopping cart.\n- **OrderLog:** Will keep a track of the status of orders, such as unshipped, pending, complete, canceled, etc.\n- **ShipmentLog:** Will keep a track of the status of shipments, such as pending, shipped, delivered, etc.\n- **Notification:** This class will take care of sending notifications to customers.\n- **Payment:** This class will encapsulate the payment for an order. Members can pay through credit card or electronic bank transfer.\n\n<MdxImage \n  src=\"design/online-shopping/class-diagram.png\" \n  alt=\"Class Diagram for Online Shopping\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"Uml\"\n/>\n\n---\n## Activity Diagram\nFollowing is the activity diagram for a user performing online shopping:\n\n<MdxImage \n  src=\"design/online-shopping/activity.svg\" \n  alt=\"Activity Diagram for Online Shopping\"\n/>\n\n---\n## Sequence Diagram\n1. Here is the sequence diagram for searching from the catalog:\n\n<MdxImage \n  src=\"design/online-shopping/sequence-searching.svg\" \n  alt=\"Sequence Diagram for Online Shopping\"\n/>\n\n2. Here is the sequence diagram for adding an item to the shopping cart:\n\n<MdxImage \n  src=\"design/online-shopping/sequence-adding-items.svg\" \n  alt=\"Sequence Diagram for Online Shopping\"\n/>\n\n3. Here is the sequence diagram for checking out to place an order:\n\n<MdxImage \n  src=\"design/online-shopping/sequence-checkout.svg\" \n  alt=\"Sequence Diagram for Online Shopping\"\n/>\n\n---\n## Code\nHere is the high-level definition for the classes described above.\n\n- **Enums and Constants:** Here are the required enums, data types, and constants:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/enums\"\n/>\n\n- **Account, Customer, Admin, and Guest:** These classes represent different people that interact with our system:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/accounts\"\n/>\n\n- **ProductCategory, Product, and ProductReview:** Here are the classes related to a product:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/product\"\n/>\n\n- **ShoppingCart, Item, Order, and OrderLog:** Users will add items to the shopping cart and place an order to buy all the items in the cart.\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/cart\"\n/>\n\n- **Shipment, ShipmentLog, and Notification:** After successfully placing an order, a shipment record will be created:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/shipment\"\n/>\n\n- **Search interface and Catalog:** Catalog will implement Search to facilitate searching of products.\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/online-shopping/search\"\n/>",
      "solutions": {
        "accounts_java": {
          "language": "java",
          "code": "// For simplicity, we are not defining getter and setter functions. The reader can\n// assume that all class attributes are private and accessed through their respective\n// public getter methods and modified only through their public methods function.\n\npublic class Account {\n  private String userName;\n  private String password;\n  private AccountStatus status;\n  private String name;\n  private Address shippingAddress;\n  private String email;\n  private String phone;\n\n  private List<CreditCard> creditCards;\n  private List<ElectronicBankTransfer> bankAccounts;\n\n  public boolean addProduct(Product product);\n  public boolean addProductReview(ProductReview review);\n  public boolean resetPassword();\n}\n\npublic abstract class Customer {\n  private ShoppingCart cart;\n  private Order order;\n\n  public ShoppingCart getShoppingCart();\n  public bool addItemToCart(Item item);\n  public bool removeItemFromCart(Item item);\n}\n\npublic class Guest extends Customer {\n  public bool registerAccount();\n}\n\npublic class Member extends Customer {\n  private Account account;\n  public OrderStatus placeOrder(Order order);\n}",
          "subPath": "accounts",
          "fileName": "solution.java"
        },
        "accounts_py": {
          "language": "py",
          "code": "# For simplicity, we are not defining getter and setter functions. The reader can\n# assume that all class attributes are private and accessed through their respective\n# public getter methods and modified only through their public methods function.\n\n\nclass Account:\n  def __init__(self, user_name, password, name, email, phone, shipping_address, status=AccountStatus):\n    self.__user_name = user_name\n    self.__password = password\n    self.__name = name\n    self.__email = email\n    self.__phone = phone\n    self.__shipping_address = shipping_address\n    self.__status = status.ACTIVE\n    self.__credit_cards = []\n    self.__bank_accounts = []\n\n  def add_product(self, product):\n    None\n\n  def add_productReview(self, review):\n    None\n\n  def reset_password(self):\n    None\n\n\nfrom abc import ABC, abstractmethod\n\nclass Customer(ABC):\n  def __init__(self, cart, order):\n    self.__cart = cart\n    self.__order = order\n\n  def get_shopping_cart(self):\n    return self.__cart\n\n  def add_item_to_cart(self, item):\n    None\n\n  def remove_item_from_cart(self, item):\n    None\n\n\nclass Guest(Customer):\n  def register_account(self):\n    None\n\n\nclass Member(Customer):\n  def __init__(self, account):\n    self.__account = account\n\n  def place_order(self, order):\n    None",
          "subPath": "accounts",
          "fileName": "solution.py"
        },
        "cart_java": {
          "language": "java",
          "code": "public class Item {\n  private String productID;\n  private int quantity;\n  private double price;\n\n  public boolean updateQuantity(int quantity);\n}\n\npublic class ShoppingCart {\n  private List<Items> items;\n\n  public boolean addItem(Item item);\n  public boolean removeItem(Item item);\n  public boolean updateItemQuantity(Item item, int quantity);\n  public List<Item> getItems();\n  public boolean checkout();\n}\n\npublic class OrderLog {\n  private String orderNumber;\n  private Date creationDate;\n  private OrderStatus status;\n}\n\npublic class Order {\n  private String orderNumber;\n  private OrderStatus status;\n  private Date orderDate;\n  private List<OrderLog> orderLog;\n\n  public boolean sendForShipment();\n  public boolean makePayment(Payment payment);\n  public boolean addOrderLog(OrderLog orderLog);\n}",
          "subPath": "cart",
          "fileName": "solution.java"
        },
        "cart_py": {
          "language": "py",
          "code": "class Item:\n  def __init__(self, id, quantity, price):\n    self.__product_id = id\n    self.__quantity = quantity\n    self.__price = price\n\n  def update_quantity(self, quantity):\n    None\n\n\nclass ShoppingCart:\n  def __init__(self):\n    self.__items = []\n\n  def add_item(self, item):\n    None\n\n  def remove_item(self, item):\n    None\n\n  def update_item_quantity(self, item, quantity):\n    None\n\n  def get_items(self):\n    return self.__items\n\n  def checkout(self):\n    None\n\n\nclass OrderLog:\n  def __init__(self, order_number, status=OrderStatus.PENDING):\n    self.__order_number = order_number\n    self.__creation_date = datetime.date.today()\n    self.__status = status\n\n\nclass Order:\n  def __init__(self, order_number, status=OrderStatus.PENDING):\n    self.__order_number = 0\n    self.__status = status\n    self.__order_date = datetime.date.today()\n    self.__order_log = []\n\n  def send_for_shipment(self):\n    None\n\n  def make_payment(self, payment):\n    None\n\n  def add_order_log(self, order_log):\n    None",
          "subPath": "cart",
          "fileName": "solution.py"
        },
        "enums_java": {
          "language": "java",
          "code": "public class Address {\n  private String streetAddress;\n  private String city;\n  private String state;\n  private String zipCode;\n  private String country;\n}\n\npublic enum OrderStatus {\n  UNSHIPPED, PENDING, SHIPPED, COMPLETED, CANCELED, REFUND_APPLIED\n}\n\npublic enum AccountStatus {\n  ACTIVE, BLOCKED, BANNED, COMPROMISED, ARCHIVED, UNKNOWN\n}\n\npublic enum ShipmentStatus {\n  PENDING, SHIPPED, DELIVERED, ON_HOLD,\n}\n\npublic enum PaymentStatus {\n  UNPAID, PENDING, COMPLETED, FILLED, DECLINED, CANCELLED, ABANDONED, SETTLING, SETTLED, REFUNDED\n}",
          "subPath": "enums",
          "fileName": "solution.java"
        },
        "enums_py": {
          "language": "py",
          "code": "class Address:\n  def __init__(self, street, city, state, zip_code, country):\n    self.__street_address = street\n    self.__city = city\n    self.__state = state\n    self.__zip_code = zip_code\n    self.__country = country\n\n\nclass OrderStatus(Enum):\n  UNSHIPPED, PENDING, SHIPPED, COMPLETED, CANCELED, REFUND_APPLIED = 1, 2, 3, 4, 5, 6\n\n\nclass AccountStatus(Enum):\n  ACTIVE, BLOCKED, BANNED, COMPROMISED, ARCHIVED, UNKNOWN = 1, 2, 3, 4, 5, 6\n\n\nclass ShipmentStatus(Enum):\n  PENDING, SHIPPED, DELIVERED, ON_HOLD = 1, 2, 3, 4\n\n\nclass PaymentStatus(Enum):\n  UNPAID, PENDING, COMPLETED, FILLED, DECLINED, CANCELLED, ABANDONED, SETTLING, SETTLED, REFUNDED = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10",
          "subPath": "enums",
          "fileName": "solution.py"
        },
        "product_java": {
          "language": "java",
          "code": "public class ProductCategory {\n  private String name;\n  private String description;\n}\n\npublic class ProductReview {\n  private int rating;\n  private String review;\n\n  private Member reviewer;\n}\n\npublic class Product {\n  private String productID;\n  private String name;\n  private String description;\n  private double price;\n  private ProductCategory category;\n  private int availableItemCount;\n\n  private Account seller;\n\n  public int getAvailableCount();\n  public boolean updatePrice(double newPrice);\n}",
          "subPath": "product",
          "fileName": "solution.java"
        },
        "product_py": {
          "language": "py",
          "code": "class ProductCategory:\n  def __init__(self, name, description):\n    self.__name = name\n    self.__description = description\n\n\nclass ProductReview:\n  def __init__(self, rating, review, reviewer):\n    self.__rating = rating\n    self.__review = review\n    self.__reviewer = reviewer\n\n\nclass Product:\n  def __init__(self, id, name, description, price, category, seller_account):\n    self.__product_id = id\n    self.__name = name\n    self.__description = description\n    self.__price = price\n    self.__category = category\n    self.__available_item_count = 0\n\n    self.__seller = seller_account\n\n  def get_available_count(self):\n    return self.__available_item_count\n\n  def update_price(self, new_price):\n    None",
          "subPath": "product",
          "fileName": "solution.py"
        },
        "search_java": {
          "language": "java",
          "code": "public interface Search {\n  public List<Product> searchProductsByName(String name);\n  public List<Product> searchProductsByCategory(String category);\n}\n\npublic class Catalog implements Search {\n   HashMap<String, List<Product>> productNames;\n   HashMap<String, List<Product>> productCategories;\n\n  public List<Product> searchProductsByName(String name) {\n    return productNames.get(name);\n  }\n\n  public List<Product> searchProductsByCategory(String category) {\n    return productCategories.get(category);\n  }\n}",
          "subPath": "search",
          "fileName": "solution.java"
        },
        "search_py": {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Search(ABC):\n  def search_products_by_name(self, name):\n    None\n\n  def search_products_by_category(self, category):\n    None\n\n\nclass Catalog(Search):\n  def __init__(self):\n    self.__product_names = {}\n    self.__product_categories = {}\n\n  def search_products_by_name(self, name):\n    return self.product_names.get(name)\n\n  def search_products_by_category(self, category):\n    return self.product_categories.get(category)",
          "subPath": "search",
          "fileName": "solution.py"
        },
        "shipment_java": {
          "language": "java",
          "code": "public class ShipmentLog {\n  private String shipmentNumber;\n  private ShipmentStatus status;\n  private Date creationDate;\n}\n\npublic class Shipment {\n  private String shipmentNumber;\n  private Date shipmentDate;\n  private Date estimatedArrival;\n  private String shipmentMethod;\n  private List<ShipmentLog> shipmentLogs;\n\n  public boolean addShipmentLog(ShipmentLog shipmentLog);\n}\n\npublic abstract class Notification {\n  private int notificationId;\n  private Date createdOn;\n  private String content;\n\n  public boolean sendNotification(Account account);\n}",
          "subPath": "shipment",
          "fileName": "solution.java"
        },
        "shipment_py": {
          "language": "py",
          "code": "class ShipmentLog:\n  def __init__(self, shipment_number, status=ShipmentStatus.PENDING):\n    self.__shipment_number = shipment_number\n    self.__status = status\n    self.__creation_date = datetime.date.today()\n\n\nclass Shipment:\n  def __init__(self, shipment_numbe, shipment_methodr):\n    self.__shipment_number = shipment_number\n    self.__shipment_date = datetime.date.today()\n    self.__estimated_arrival = datetime.date.today()\n    self.__shipment_method = shipment_method\n    self.__shipmentLogs = []\n\n  def add_shipment_log(self, shipment_log):\n    None\n\n\n# from abc import ABC, abstractmethod\nclass Notification(ABC):\n  def __init__(self, id, content):\n    self.__notification_id = id\n    self.__created_on = datetime.date.today()\n    self.__content = content\n\n  def send_notification(self, account):\n    None",
          "subPath": "shipment",
          "fileName": "solution.py"
        }
      }
    },
    "parking-lot": {
      "id": "parking-lot",
      "title": "Design a Parking Lot",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Design a Parking Lot\"\nauthor: \"Rajat Srivastava\"\ncategories: system-designs\ntags: [system-design, hld, lld]\ndescription: \"System design concepts and patterns\"\n---\n\nA parking lot or car park is a dedicated cleared area that is intended for parking vehicles. In most countries where cars are a major mode of transportation, parking lots are a feature of every city and suburban area. Shopping malls, sports stadiums, megachurches, and similar venues often feature parking lots over large areas.\n\n---\n## System Requirements\nWe will focus on the following set of requirements while designing the parking lot:\n1. The parking lot should have multiple floors where customers can park their cars.\n2. The parking lot should have multiple entry and exit points.\n3. Customers can collect a parking ticket from the entry points and can pay the parking fee at the exit points on their way out.\n4. Customers can pay the tickets at the automated exit panel or to the parking attendant.\n5. Customers can pay via both cash and credit cards.\n6. Customers should also be able to pay the parking fee at the customers info portal on each floor. If the customer has paid at the info portal, they dont have to pay at the exit.\n7. The system should not allow more vehicles than the maximum capacity of the parking lot. If the parking is full, the system should be able to show a message at the entrance panel and on the parking display board on the ground floor.\n8. Each parking floor will have many parking spots. The system should support multiple types of parking spots such as Compact, Large, Handicapped, Motorcycle, etc.\n9. The Parking lot should have some parking spots specified for electric cars. These spots should have an electric panel through which customers can pay and charge their vehicles.\n10. The system should support parking for different types of vehicles like car, truck, van, motorcycle, etc.\n11. Each parking floor should have a display board showing any free parking spot for each spot type.\n12. The system should support a per-hour parking fee model. For example, customers have to pay $4 for the first hour, $3.5 for the second and third hours, and $2.5 for all the remaining hours.\n\n---\n## Use Case Diagrams\nHere are the main Actors in our system:\n\n- **Admin:** Mainly responsible for adding and modifying parking floors, parking spots, entrance, and exit panels, adding/removing parking attendants, etc.\n- **Customer:** All customers can get a parking ticket and pay for it.\n- **Parking attendant:** Parking attendants can do all the activities on the customers behalf, and can take cash for ticket payment.\n- **System:** To display messages on different info panels, as well as assigning and removing a vehicle from a parking spot.\n\nHere are the top use cases for Parking Lot:\n\n- **Add/Remove/Edit parking floor:** To add, remove or modify a parking floor from the system. Each floor can have its own display board to show free parking spots.\n- **Add/Remove/Edit parking spot:** To add, remove or modify a parking spot on a parking floor.\n- **Add/Remove a parking attendant:** To add or remove a parking attendant from the system.\n- **Take ticket:** To provide customers with a new parking ticket when entering the parking lot.\n- **Scan ticket:** To scan a ticket to find out the total charge.\n- **Credit card payment:** To pay the ticket fee with credit card.\n- **Cash payment:** To pay the parking ticket through cash.\n- **Add/Modify parking rate:** To allow admin to add or modify the hourly parking rate.\n\n<MdxImage \n  src=\"design/parking-lot/use-case.svg\" \n  alt=\"Usecase Diagram for Parking Lot\"\n/>\n\n---\n## Class Diagrams\nHere are the main classes of our Parking Lot System:\n\n- **ParkingLot:** The central part of the organization for which this software has been designed. It has attributes like Name to distinguish it from any other parking lots and Address to define its location.\n- **ParkingFloor:** The parking lot will have many parking floors.\n- **ParkingSpot:** Each parking floor will have many parking spots. Our system will support different parking spots 1) Handicapped, 2) Compact, 3) Large, 4) Motorcycle, and 5) Electric.\n- **Account:** We will have two types of accounts in the system: one for an Admin, and the other for a parking attendant.\n- **Parking ticket:** This class will encapsulate a parking ticket. Customers will take a ticket when they enter the parking lot.\n- **Vehicle:** Vehicles will be parked in the parking spots. Our system will support different types of vehicles 1) Car, 2) Truck, 3) Electric, 4) Van and 5) Motorcycle.\n- **EntrancePanel and ExitPanel:** EntrancePanel will print tickets, and ExitPanel will facilitate payment of the ticket fee.\n- **Payment:** This class will be responsible for making payments. The system will support credit card and cash transactions.\n- **ParkingRate:** This class will keep track of the hourly parking rates. It will specify a dollar amount for each hour. For example, for a two hour parking ticket, this class will define the cost for the first and the second hour.\n- **ParkingDisplayBoard:** Each parking floor will have a display board to show available parking spots for each spot type. This class will be responsible for displaying the latest availability of free parking spots to the customers.\n- **ParkingAttendantPortal:** This class will encapsulate all the operations that an attendant can perform, like scanning tickets and processing payments.\n- **CustomerInfoPortal:** This class will encapsulate the info portal that customers use to pay for the parking ticket. Once paid, the info portal will update the ticket to keep track of the payment.\n- **ElectricPanel:** Customers will use the electric panels to pay and charge their electric vehicles.\n\n<MdxImage \n  src=\"design/parking-lot/class-diagram.png\" \n  alt=\"Class Diagram for Parking Lot\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"Uml\"\n/>\n\n---\n## Activity diagrams\n\n- **Customer paying for parking ticket:** Any customer can perform this activity. Here are the set of steps:\n\n<MdxImage \n  src=\"design/parking-lot/activity-paying.svg\" \n  alt=\"Activity Diagram for Parking Lot\"\n/>\n\n---\n## Code\nFollowing is the skeleton code for our parking lot system:\n\n- **Enums and Constants:** Here are the required enums, data types, and constants:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/enums\"\n/>\n\n- **Account, Admin, and ParkingAttendant:** These classes represent various people that interact with our system:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/accounts\"\n/>\n\n- **ParkingSpot:** Here is the definition of ParkingSpot and all of its children classes:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/parkingSpot\"\n/>\n\n- **Vehicle:** Here is the definition for Vehicle and all of its child classes:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/vehicle\"\n/>\n\n- **ParkingFloor:** This class encapsulates a parking floor:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/parkingFloor\"\n/>\n\n- **ParkingDisplayBoard:** This class encapsulates a parking display board:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/parkingDisplay\"\n/>\n\n- **ParkingLot:** Our system will have only one object of this class. This can be enforced by using the <MdxLink href=\"https://en.wikipedia.org/wiki/Singleton_pattern\">Singleton</MdxLink> pattern. In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to only one object.\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/parkingLot\"\n/>",
      "body": "A parking lot or car park is a dedicated cleared area that is intended for parking vehicles. In most countries where cars are a major mode of transportation, parking lots are a feature of every city and suburban area. Shopping malls, sports stadiums, megachurches, and similar venues often feature parking lots over large areas.\n\n---\n## System Requirements\nWe will focus on the following set of requirements while designing the parking lot:\n1. The parking lot should have multiple floors where customers can park their cars.\n2. The parking lot should have multiple entry and exit points.\n3. Customers can collect a parking ticket from the entry points and can pay the parking fee at the exit points on their way out.\n4. Customers can pay the tickets at the automated exit panel or to the parking attendant.\n5. Customers can pay via both cash and credit cards.\n6. Customers should also be able to pay the parking fee at the customers info portal on each floor. If the customer has paid at the info portal, they dont have to pay at the exit.\n7. The system should not allow more vehicles than the maximum capacity of the parking lot. If the parking is full, the system should be able to show a message at the entrance panel and on the parking display board on the ground floor.\n8. Each parking floor will have many parking spots. The system should support multiple types of parking spots such as Compact, Large, Handicapped, Motorcycle, etc.\n9. The Parking lot should have some parking spots specified for electric cars. These spots should have an electric panel through which customers can pay and charge their vehicles.\n10. The system should support parking for different types of vehicles like car, truck, van, motorcycle, etc.\n11. Each parking floor should have a display board showing any free parking spot for each spot type.\n12. The system should support a per-hour parking fee model. For example, customers have to pay $4 for the first hour, $3.5 for the second and third hours, and $2.5 for all the remaining hours.\n\n---\n## Use Case Diagrams\nHere are the main Actors in our system:\n\n- **Admin:** Mainly responsible for adding and modifying parking floors, parking spots, entrance, and exit panels, adding/removing parking attendants, etc.\n- **Customer:** All customers can get a parking ticket and pay for it.\n- **Parking attendant:** Parking attendants can do all the activities on the customers behalf, and can take cash for ticket payment.\n- **System:** To display messages on different info panels, as well as assigning and removing a vehicle from a parking spot.\n\nHere are the top use cases for Parking Lot:\n\n- **Add/Remove/Edit parking floor:** To add, remove or modify a parking floor from the system. Each floor can have its own display board to show free parking spots.\n- **Add/Remove/Edit parking spot:** To add, remove or modify a parking spot on a parking floor.\n- **Add/Remove a parking attendant:** To add or remove a parking attendant from the system.\n- **Take ticket:** To provide customers with a new parking ticket when entering the parking lot.\n- **Scan ticket:** To scan a ticket to find out the total charge.\n- **Credit card payment:** To pay the ticket fee with credit card.\n- **Cash payment:** To pay the parking ticket through cash.\n- **Add/Modify parking rate:** To allow admin to add or modify the hourly parking rate.\n\n<MdxImage \n  src=\"design/parking-lot/use-case.svg\" \n  alt=\"Usecase Diagram for Parking Lot\"\n/>\n\n---\n## Class Diagrams\nHere are the main classes of our Parking Lot System:\n\n- **ParkingLot:** The central part of the organization for which this software has been designed. It has attributes like Name to distinguish it from any other parking lots and Address to define its location.\n- **ParkingFloor:** The parking lot will have many parking floors.\n- **ParkingSpot:** Each parking floor will have many parking spots. Our system will support different parking spots 1) Handicapped, 2) Compact, 3) Large, 4) Motorcycle, and 5) Electric.\n- **Account:** We will have two types of accounts in the system: one for an Admin, and the other for a parking attendant.\n- **Parking ticket:** This class will encapsulate a parking ticket. Customers will take a ticket when they enter the parking lot.\n- **Vehicle:** Vehicles will be parked in the parking spots. Our system will support different types of vehicles 1) Car, 2) Truck, 3) Electric, 4) Van and 5) Motorcycle.\n- **EntrancePanel and ExitPanel:** EntrancePanel will print tickets, and ExitPanel will facilitate payment of the ticket fee.\n- **Payment:** This class will be responsible for making payments. The system will support credit card and cash transactions.\n- **ParkingRate:** This class will keep track of the hourly parking rates. It will specify a dollar amount for each hour. For example, for a two hour parking ticket, this class will define the cost for the first and the second hour.\n- **ParkingDisplayBoard:** Each parking floor will have a display board to show available parking spots for each spot type. This class will be responsible for displaying the latest availability of free parking spots to the customers.\n- **ParkingAttendantPortal:** This class will encapsulate all the operations that an attendant can perform, like scanning tickets and processing payments.\n- **CustomerInfoPortal:** This class will encapsulate the info portal that customers use to pay for the parking ticket. Once paid, the info portal will update the ticket to keep track of the payment.\n- **ElectricPanel:** Customers will use the electric panels to pay and charge their electric vehicles.\n\n<MdxImage \n  src=\"design/parking-lot/class-diagram.png\" \n  alt=\"Class Diagram for Parking Lot\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"Uml\"\n/>\n\n---\n## Activity diagrams\n\n- **Customer paying for parking ticket:** Any customer can perform this activity. Here are the set of steps:\n\n<MdxImage \n  src=\"design/parking-lot/activity-paying.svg\" \n  alt=\"Activity Diagram for Parking Lot\"\n/>\n\n---\n## Code\nFollowing is the skeleton code for our parking lot system:\n\n- **Enums and Constants:** Here are the required enums, data types, and constants:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/enums\"\n/>\n\n- **Account, Admin, and ParkingAttendant:** These classes represent various people that interact with our system:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/accounts\"\n/>\n\n- **ParkingSpot:** Here is the definition of ParkingSpot and all of its children classes:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/parkingSpot\"\n/>\n\n- **Vehicle:** Here is the definition for Vehicle and all of its child classes:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/vehicle\"\n/>\n\n- **ParkingFloor:** This class encapsulates a parking floor:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/parkingFloor\"\n/>\n\n- **ParkingDisplayBoard:** This class encapsulates a parking display board:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/parkingDisplay\"\n/>\n\n- **ParkingLot:** Our system will have only one object of this class. This can be enforced by using the <MdxLink href=\"https://en.wikipedia.org/wiki/Singleton_pattern\">Singleton</MdxLink> pattern. In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to only one object.\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/parking-lot/parkingLot\"\n/>",
      "solutions": {
        "accounts_java": {
          "language": "java",
          "code": "// For simplicity, we are not defining getter and setter functions. The reader can\n// assume that all class attributes are private and accessed through their respective\n// public getter methods and modified only through their public methods function.\n\npublic abstract class Account {\n  private String userName;\n  private String password;\n  private AccountStatus status;\n  private Person person;\n\n  public boolean resetPassword();\n}\n\npublic class Admin extends Account {\n  public bool addParkingFloor(ParkingFloor floor);\n  public bool addParkingSpot(String floorName, ParkingSpot spot);\n  public bool addParkingDisplayBoard(String floorName, ParkingDisplayBoard displayBoard);\n  public bool addCustomerInfoPanel(String floorName, CustomerInfoPanel infoPanel);\n\n  public bool addEntrancePanel(EntrancePanel entrancePanel);\n  public bool addExitPanel(ExitPanel exitPanel);\n}\n\npublic class ParkingAttendant extends Account {\n  public bool processTicket(string TicketNumber);\n}",
          "subPath": "accounts",
          "fileName": "solution.java"
        },
        "accounts_py": {
          "language": "py",
          "code": "class Account:\n  def __init__(self, user_name, password, person, status=AccountStatus.Active):\n    self.__user_name = user_name\n    self.__password = password\n    self.__person = person\n    self.__status = status\n\n  def reset_password(self):\n    None\n\n\nclass Admin(Account):\n  def __init__(self, user_name, password, person, status=AccountStatus.Active):\n    super().__init__(user_name, password, person, status)\n\n  def add_parking_floor(self, floor):\n    None\n\n  def add_parking_spot(self, floor_name, spot):\n    None\n\n  def add_parking_display_board(self, floor_name, display_board):\n    None\n\n  def add_customer_info_panel(self, floor_name, info_panel):\n    None\n\n  def add_entrance_panel(self, entrance_panel):\n    None\n\n  def add_exit_panel(self, exit_panel):\n    None\n\n\nclass ParkingAttendant(Account):\n  def __init__(self, user_name, password, person, status=AccountStatus.Active):\n    super().__init__(user_name, password, person, status)\n\n  def process_ticket(self, ticket_number):\n    None",
          "subPath": "accounts",
          "fileName": "solution.py"
        },
        "enums_java": {
          "language": "java",
          "code": "public enum VehicleType {\n  CAR, TRUCK, ELECTRIC, VAN, MOTORBIKE\n}\n\npublic enum ParkingSpotType {\n  HANDICAPPED, COMPACT, LARGE, MOTORBIKE, ELECTRIC\n}\n\npublic enum AccountStatus {\n  ACTIVE, BLOCKED, BANNED, COMPROMISED, ARCHIVED, UNKNOWN\n}\n\npublic enum ParkingTicketStatus {\n  ACTIVE, PAID, LOST\n}\n\npublic class Address {\n  private String streetAddress;\n  private String city;\n  private String state;\n  private String zipCode;\n  private String country;\n}\n\npublic class Person {\n  private String name;\n  private Address address;\n  private String email;\n  private String phone;\n}",
          "subPath": "enums",
          "fileName": "solution.java"
        },
        "enums_py": {
          "language": "py",
          "code": "class VehicleType(Enum):\n  CAR, TRUCK, ELECTRIC, VAN, MOTORBIKE = 1, 2, 3, 4, 5\n\n\nclass ParkingSpotType(Enum):\n  HANDICAPPED, COMPACT, LARGE, MOTORBIKE, ELECTRIC = 1, 2, 3, 4, 5\n\n\nclass AccountStatus(Enum):\n  ACTIVE, BLOCKED, BANNED, COMPROMISED, ARCHIVED, UNKNOWN = 1, 2, 3, 4, 5, 6\n\n\nclass ParkingTicketStatus(Enum):\n  ACTIVE, PAID, LOST = 1, 2, 3\n\n\nclass Address:\n  def __init__(self, street, city, state, zip_code, country):\n    self.__street_address = street\n    self.__city = city\n    self.__state = state\n    self.__zip_code = zip_code\n    self.__country = country\n\n\nclass Person():\n  def __init__(self, name, address, email, phone):\n    self.__name = name\n    self.__address = address\n    self.__email = email\n    self.__phone = phone",
          "subPath": "enums",
          "fileName": "solution.py"
        },
        "parkingDisplay_java": {
          "language": "java",
          "code": "public class ParkingDisplayBoard {\n  private String id;\n  private HandicappedSpot handicappedFreeSpot;\n  private CompactSpot compactFreeSpot;\n  private LargeSpot largeFreeSpot;\n  private MotorbikeSpot motorbikeFreeSpot;\n  private ElectricSpot electricFreeSpot;\n\n  public void showEmptySpotNumber() {\n    String message = \"\";\n    if(handicappedFreeSpot.IsFree()){\n      message += \"Free Handicapped: \" + handicappedFreeSpot.getNumber();\n    } else {\n      message += \"Handicapped is full\";\n    }\n    message += System.lineSeparator();\n\n    if(compactFreeSpot.IsFree()){\n      message += \"Free Compact: \" + compactFreeSpot.getNumber();\n    } else {\n      message += \"Compact is full\";\n    }\n    message += System.lineSeparator();\n\n    if(largeFreeSpot.IsFree()){\n      message += \"Free Large: \" + largeFreeSpot.getNumber();\n    } else {\n      message += \"Large is full\";\n    }\n    message += System.lineSeparator();\n\n    if(motorbikeFreeSpot.IsFree()){\n      message += \"Free Motorbike: \" + motorbikeFreeSpot.getNumber();\n    } else {\n      message += \"Motorbike is full\";\n    }\n    message += System.lineSeparator();\n\n    if(electricFreeSpot.IsFree()){\n      message += \"Free Electric: \" + electricFreeSpot.getNumber();\n    } else {\n      message += \"Electric is full\";\n    }\n\n    Show(message);\n  }\n}",
          "subPath": "parkingDisplay",
          "fileName": "solution.java"
        },
        "parkingDisplay_py": {
          "language": "py",
          "code": "class ParkingDisplayBoard:\n  def __init__(self, id):\n    self.__id = id\n    self.__handicapped_free_spot = None\n    self.__compact_free_spot = None\n    self.__large_free_spot = None\n    self.__motorbike_free_spot = None\n    self.__electric_free_spot = None\n\n  def show_empty_spot_number(self):\n    message = \"\"\n    if self.__handicapped_free_spot.is_free():\n      message += \"Free Handicapped: \" + self.__handicapped_free_spot.get_number()\n    else:\n      message += \"Handicapped is full\"\n    message += \"\\n\"\n\n    if self.__compact_free_spot.is_free():\n      message += \"Free Compact: \" + self.__compact_free_spot.get_number()\n    else:\n      message += \"Compact is full\"\n    message += \"\\n\"\n\n    if self.__large_free_spot.is_free():\n      message += \"Free Large: \" + self.__large_free_spot.get_number()\n    else:\n      message += \"Large is full\"\n    message += \"\\n\"\n\n    if self.__motorbike_free_spot.is_free():\n      message += \"Free Motorbike: \" + self.__motorbike_free_spot.get_number()\n    else:\n      message += \"Motorbike is full\"\n    message += \"\\n\"\n\n    if self.__electric_free_spot.is_free():\n      message += \"Free Electric: \" + self.__electric_free_spot.get_number()\n    else:\n      message += \"Electric is full\"\n\n    print(message)",
          "subPath": "parkingDisplay",
          "fileName": "solution.py"
        },
        "parkingFloor_java": {
          "language": "java",
          "code": "public class ParkingFloor {\n  private String name;\n  private HashMap<String, HandicappedSpot> handicappedSpots;\n  private HashMap<String, CompactSpot> compactSpots;\n  private HashMap<String, LargeSpot> largeSpots;\n  private HashMap<String, MotorbikeSpot> motorbikeSpots;\n  private HashMap<String, ElectricSpot> electricSpots;\n  private HashMap<String, CustomerInfoPortal> infoPortals;\n  private ParkingDisplayBoard displayBoard;\n\n  public ParkingFloor(String name) {\n    this.name = name;\n  }\n\n  public void addParkingSpot(ParkingSpot spot) {\n    switch (spot.getType()) {\n    case ParkingSpotType.HANDICAPPED:\n      handicappedSpots.put(spot.getNumber(), spot);\n      break;\n    case ParkingSpotType.COMPACT:\n      compactSpots.put(spot.getNumber(), spot);\n      break;\n    case ParkingSpotType.LARGE:\n      largeSpots.put(spot.getNumber(), spot);\n      break;\n    case ParkingSpotType.MOTORBIKE:\n      motorbikeSpots.put(spot.getNumber(), spot);\n      break;\n    case ParkingSpotType.ELECTRIC:\n      electricSpots.put(spot.getNumber(), spot);\n      break;\n    default:\n      print(\"Wrong parking spot type!\");\n    }\n  }\n\n  public void assignVehicleToSpot(Vehicle vehicle, ParkingSpot spot) {\n    spot.assignVehicle(vehicle);\n    switch (spot.getType()) {\n    case ParkingSpotType.HANDICAPPED:\n      updateDisplayBoardForHandicapped(spot);\n      break;\n    case ParkingSpotType.COMPACT:\n      updateDisplayBoardForCompact(spot);\n      break;\n    case ParkingSpotType.LARGE:\n      updateDisplayBoardForLarge(spot);\n      break;\n    case ParkingSpotType.MOTORBIKE:\n      updateDisplayBoardForMotorbike(spot);\n      break;\n    case ParkingSpotType.ELECTRIC:\n      updateDisplayBoardForElectric(spot);\n      break;\n    default:\n      print(\"Wrong parking spot type!\");\n    }\n  }\n\n  private void updateDisplayBoardForHandicapped(ParkingSpot spot) {\n    if (this.displayBoard.getHandicappedFreeSpot().getNumber() == spot.getNumber()) {\n      // find another free handicapped parking and assign to displayBoard\n      for (String key : handicappedSpots.keySet()) {\n        if (handicappedSpots.get(key).isFree()) {\n          this.displayBoard.setHandicappedFreeSpot(handicappedSpots.get(key));\n        }\n      }\n      this.displayBoard.showEmptySpotNumber();\n    }\n  }\n\n  private void updateDisplayBoardForCompact(ParkingSpot spot) {\n    if (this.displayBoard.getCompactFreeSpot().getNumber() == spot.getNumber()) {\n      // find another free compact parking and assign to displayBoard\n      for (String key : compactSpots.keySet()) {\n        if (compactSpots.get(key).isFree()) {\n          this.displayBoard.setCompactFreeSpot(compactSpots.get(key));\n        }\n      }\n      this.displayBoard.showEmptySpotNumber();\n    }\n  }\n\n  public void freeSpot(ParkingSpot spot) {\n    spot.removeVehicle();\n    switch (spot.getType()) {\n    case ParkingSpotType.HANDICAPPED:\n      freeHandicappedSpotCount++;\n      break;\n    case ParkingSpotType.COMPACT:\n      freeCompactSpotCount++;\n      break;\n    case ParkingSpotType.LARGE:\n      freeLargeSpotCount++;\n      break;\n    case ParkingSpotType.MOTORBIKE:\n      freeMotorbikeSpotCount++;\n      break;\n    case ParkingSpotType.ELECTRIC:\n      freeElectricSpotCount++;\n      break;\n    default:\n      print(\"Wrong parking spot type!\");\n    }\n  }\n}",
          "subPath": "parkingFloor",
          "fileName": "solution.java"
        },
        "parkingFloor_py": {
          "language": "py",
          "code": "class ParkingFloor:\n  def __init__(self, name):\n    self.__name = name\n    self.__handicapped_spots = {}\n    self.__compact_spots = {}\n    self.__large_spots = {}\n    self.__motorbike_spots = {}\n    self.__electric_spots = {}\n    self.__info_portals = {}\n    self.__display_board = ParkingDisplayBoard()\n\n  def add_parking_spot(self, spot):\n    switcher = {\n      ParkingSpotType.HANDICAPPED: self.__handicapped_spots.put(spot.get_number(), spot),\n      ParkingSpotType.COMPACT: __compact_spots.put(spot.get_number(), spot),\n      ParkingSpotType.LARGE: __large_spots.put(spot.get_number(), spot),\n      ParkingSpotType.MOTORBIKE: __motorbike_spots.put(spot.get_number(), spot),\n      ParkingSpotType.ELECTRIC: __electric_spots.put(spot.get_number(), spot),\n    }\n    switcher.get(spot.get_type(), 'Wrong parking spot type')\n\n  def assign_vehicleToSpot(self, vehicle, spot):\n    spot.assign_vehicle(vehicle)\n    switcher = {\n      ParkingSpotType.HANDICAPPED: self.update_display_board_for_handicapped(spot),\n      ParkingSpotType.COMPACT: self.update_display_board_for_compact(spot),\n      ParkingSpotType.LARGE: self.update_display_board_for_large(spot),\n      ParkingSpotType.MOTORBIKE: self.update_display_board_for_motorbike(spot),\n      ParkingSpotType.ELECTRIC: self.update_display_board_for_electric(spot),\n    }\n    switcher(spot.get_type(), 'Wrong parking spot type!')\n\n  def update_display_board_for_handicapped(self, spot):\n    if self.__display_board.get_handicapped_free_spot().get_number() == spot.get_number():\n      # find another free handicapped parking and assign to display_board\n      for key in self.__handicapped_spots:\n        if self.__handicapped_spots.get(key).is_free():\n          self.__display_board.set_handicapped_free_spot(\n            self.__handicapped_spots.get(key))\n\n      self.__display_board.show_empty_spot_number()\n\n  def update_display_board_for_compact(self, spot):\n    if self.__display_board.get_compact_free_spot().get_number() == spot.get_number():\n      # find another free compact parking and assign to display_board\n      for key in self.__compact_spots.key_set():\n        if self.__compact_spots.get(key).is_free():\n          self.__display_board.set_compact_free_spot(\n            self.__compact_spots.get(key))\n\n      self.__display_board.show_empty_spot_number()\n\n  def free_spot(self, spot):\n    spot.remove_vehicle()\n    switcher = {\n      ParkingSpotType.HANDICAPPED: self.__free_handicapped_spot_count += 1,\n      ParkingSpotType.COMPACT: self.__free_compact_spot_count += 1,\n      ParkingSpotType.LARGE: self.__free_large_spot_count += 1,\n      ParkingSpotType.MOTORBIKE: self.__free_motorbike_spot_count += 1,\n      ParkingSpotType.ELECTRIC: self.__free_electric_spot_count += 1,\n    }\n\n    switcher(spot.get_type(), 'Wrong parking spot type!')",
          "subPath": "parkingFloor",
          "fileName": "solution.py"
        },
        "parkingLot_java": {
          "language": "java",
          "code": "public class ParkingLot {\n  private String name;\n  private Location address;\n  private ParkingRate parkingRate;\n\n  private int compactSpotCount;\n  private int largeSpotCount;\n  private int motorbikeSpotCount;\n  private int electricSpotCount;\n  private final int maxCompactCount;\n  private final int maxLargeCount;\n  private final int maxMotorbikeCount;\n  private final int maxElectricCount;\n\n  private HashMap<String, EntrancePanel> entrancePanels;\n  private HashMap<String, ExitPanel> exitPanels;\n  private HashMap<String, ParkingFloor> parkingFloors;\n\n  // all active parking tickets, identified by their ticketNumber\n  private HashMap<String, ParkingTicket> activeTickets;\n\n  // singleton ParkingLot to ensure only one object of ParkingLot in the system,\n  // all entrance panels will use this object to create new parking ticket: getNewParkingTicket(),\n  // similarly exit panels will also use this object to close parking tickets\n  private static ParkingLot parkingLot = null;\n\n  // private constructor to restrict for singleton\n  private ParkingLot() {\n    // 1. initialize variables: read name, address and parkingRate from database\n    // 2. initialize parking floors: read the parking floor map from database,\n    //  this map should tell how many parking spots are there on each floor. This\n    //  should also initialize max spot counts too.\n    // 3. initialize parking spot counts by reading all active tickets from database\n    // 4. initialize entrance and exit panels: read from database\n  }\n\n  // static method to get the singleton instance of StockExchange\n  public static ParkingLot getInstance() {\n    if (parkingLot == null) {\n      parkingLot = new ParkingLot();\n    }\n    return parkingLot;\n  }\n\n  // note that the following method is 'synchronized' to allow multiple entrances\n  // panels to issue a new parking ticket without interfering with each other\n  public synchronized ParkingTicket getNewParkingTicket(Vehicle vehicle) throws ParkingFullException {\n    if (this.isFull(vehicle.getType())) {\n      throw new ParkingFullException();\n    }\n    ParkingTicket ticket = new ParkingTicket();\n    vehicle.assignTicket(ticket);\n    ticket.saveInDB();\n    // if the ticket is successfully saved in the database, we can increment the parking spot count\n    this.incrementSpotCount(vehicle.getType());\n    this.activeTickets.put(ticket.getTicketNumber(), ticket);\n    return ticket;\n  }\n\n  public boolean isFull(VehicleType type) {\n    // trucks and vans can only be parked in LargeSpot\n    if (type == VehicleType.Truck || type == VehicleType.Van) {\n      return largeSpotCount >= maxLargeCount;\n    }\n\n    // motorbikes can only be parked at motorbike spots\n    if (type == VehicleType.Motorbike) {\n      return motorbikeSpotCount >= maxMotorbikeCount;\n    }\n\n    // cars can be parked at compact or large spots\n    if (type == VehicleType.Car) {\n      return (compactSpotCount + largeSpotCount) >= (maxCompactCount + maxLargeCount);\n    }\n\n    // electric car can be parked at compact, large or electric spots\n    return (compactSpotCount + largeSpotCount + electricSpotCount) >= (maxCompactCount + maxLargeCount\n        + maxElectricCount);\n  }\n\n  // increment the parking spot count based on the vehicle type\n  private boolean incrementSpotCount(VehicleType type) {\n    if (type == VehicleType.Truck || type == VehicleType.Van) {\n      largeSpotCount++;\n    } else if (type == VehicleType.Motorbike) {\n      motorbikeSpotCount++;\n    } else if (type == VehicleType.Car) {\n      if (compactSpotCount < maxCompactCount) {\n        compactSpotCount++;\n      } else {\n        largeSpotCount++;\n      }\n    } else { // electric car\n      if (electricSpotCount < maxElectricCount) {\n        electricSpotCount++;\n      } else if (compactSpotCount < maxCompactCount) {\n        compactSpotCount++;\n      } else {\n        largeSpotCount++;\n      }\n    }\n  }\n\n  public boolean isFull() {\n    for (String key : parkingFloors.keySet()) {\n      if (!parkingFloors.get(key).isFull()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public void addParkingFloor(ParkingFloor floor) {\n    /* store in database */ }\n\n  public void addEntrancePanel(EntrancePanel entrancePanel) {\n    /* store in database */ }\n\n  public void addExitPanel(ExitPanel exitPanel) {\n    /* store in database */ }\n}",
          "subPath": "parkingLot",
          "fileName": "solution.java"
        },
        "parkingLot_py": {
          "language": "py",
          "code": "import threading\n\nclass ParkingLot:\n  # singleton ParkingLot to ensure only one object of ParkingLot in the system,\n  # all entrance panels will use this object to create new parking ticket: get_new_parking_ticket(),\n  # similarly exit panels will also use this object to close parking tickets\n  instance = None\n\n  class __OnlyOne:\n    def __init__(self, name, address):\n      # 1. initialize variables: read name, address and parking_rate from database\n      # 2. initialize parking floors: read the parking floor map from database,\n      #    this map should tell how many parking spots are there on each floor. This\n      #    should also initialize max spot counts too.\n      # 3. initialize parking spot counts by reading all active tickets from database\n      # 4. initialize entrance and exit panels: read from database\n\n      self.__name = name\n      self.__address = address\n      self.__parking_rate = ParkingRate()\n\n      self.__compact_spot_count = 0\n      self.__large_spot_count = 0\n      self.__motorbike_spot_count = 0\n      self.__electric_spot_count = 0\n      self.__max_compact_count = 0\n      self.__max_large_count = 0\n      self.__max_motorbike_count = 0\n      self.__max_electric_count = 0\n\n      self.__entrance_panels = {}\n      self.__exit_panels = {}\n      self.__parking_floors = {}\n\n      # all active parking tickets, identified by their ticket_number\n      self.__active_tickets = {}\n\n      self.__lock = threading.Lock()\n\n  def __init__(self, name, address):\n    if not ParkingLot.instance:\n      ParkingLot.instance = ParkingLot.__OnlyOne(name, address)\n    else:\n      ParkingLot.instance.__name = name\n      ParkingLot.instance.__address = address\n\n  def __getattr__(self, name):\n    return getattr(self.instance, name)\n\n  def get_new_parking_ticket(self, vehicle):\n    if self.is_full(vehicle.get_type()):\n      raise Exception('Parking full!')\n    # synchronizing to allow multiple entrances panels to issue a new\n    # parking ticket without interfering with each other\n    self.__lock.acquire()\n    ticket = ParkingTicket()\n    vehicle.assign_ticket(ticket)\n    ticket.save_in_DB()\n    # if the ticket is successfully saved in the database, we can increment the parking spot count\n    self.__increment_spot_count(vehicle.get_type())\n    self.__active_tickets.put(ticket.get_ticket_number(), ticket)\n    self.__lock.release()\n    return ticket\n\n  def is_full(self, type):\n    # trucks and vans can only be parked in LargeSpot\n    if type == VehicleType.Truck or type == VehicleType.Van:\n      return self.__large_spot_count >= self.__max_large_count\n\n    # motorbikes can only be parked at motorbike spots\n    if type == VehicleType.Motorbike:\n      return self.__motorbike_spot_count >= self.__max_motorbike_count\n\n    # cars can be parked at compact or large spots\n    if type == VehicleType.Car:\n      return (self.__compact_spot_count + self.__large_spot_count) >= (self.__max_compact_count + self.__max_large_count)\n\n    # electric car can be parked at compact, large or electric spots\n    return (self.__compact_spot_count + self.__large_spot_count + self.__electric_spot_count) >= (self.__max_compact_count + self.__max_large_count + self.__max_electric_count)\n\n  # increment the parking spot count based on the vehicle type\n  def increment_spot_count(self, type):\n    if type == VehicleType.Truck or type == VehicleType.Van:\n      large_spot_count += 1\n    elif type == VehicleType.Motorbike:\n      motorbike_spot_count += 1\n    elif type == VehicleType.Car:\n      if self.__compact_spot_count < self.__max_compact_count:\n        compact_spot_count += 1\n      else:\n        large_spot_count += 1\n    else:  # electric car\n      if self.__electric_spot_count < self.__max_electric_count:\n        electric_spot_count += 1\n      elif self.__compact_spot_count < self.__max_compact_count:\n        compact_spot_count += 1\n      else:\n        large_spot_count += 1\n\n  def is_full(self):\n    for key in self.__parking_floors:\n      if not self.__parking_floors.get(key).is_full():\n        return False\n    return True\n\n  def add_parking_floor(self, floor):\n    # store in database\n    None\n\n  def add_entrance_panel(self, entrance_panel):\n    # store in database\n    None\n\n  def add_exit_panel(self,  exit_panel):\n    # store in database\n    None",
          "subPath": "parkingLot",
          "fileName": "solution.py"
        },
        "parkingSpot_java": {
          "language": "java",
          "code": "public abstract class ParkingSpot {\n  private String number;\n  private boolean free;\n  private Vehicle vehicle;\n  private final ParkingSpotType type;\n\n  public boolean IsFree();\n\n  public ParkingSpot(ParkingSpotType type) {\n    this.type = type;\n  }\n\n  public boolean assignVehicle(Vehicle vehicle) {\n    this.vehicle = vehicle;\n    free = false;\n  }\n\n  public boolean removeVehicle() {\n    this.vehicle = null;\n    free = true;\n  }\n}\n\npublic class HandicappedSpot extends ParkingSpot {\n  public HandicappedSpot() {\n    super(ParkingSpotType.HANDICAPPED);\n  }\n}\n\npublic class CompactSpot extends ParkingSpot {\n  public CompactSpot() {\n    super(ParkingSpotType.COMPACT);\n  }\n}\n\npublic class LargeSpot extends ParkingSpot {\n  public LargeSpot() {\n    super(ParkingSpotType.LARGE);\n  }\n}\n\npublic class MotorbikeSpot extends ParkingSpot {\n  public MotorbikeSpot() {\n    super(ParkingSpotType.MOTORBIKE);\n  }\n}\n\npublic class ElectricSpot extends ParkingSpot {\n  public ElectricSpot() {\n    super(ParkingSpotType.ELECTRIC);\n  }\n}",
          "subPath": "parkingSpot",
          "fileName": "solution.java"
        },
        "parkingSpot_py": {
          "language": "py",
          "code": "class ParkingSpot(ABC):\n  def __init__(self, number, parking_spot_type):\n    self.__number = number\n    self.__free = True\n    self.__vehicle = None\n    self.__parking_spot_type = parking_spot_type\n\n  def is_free(self):\n    return self.__free\n\n  def assign_vehicle(self, vehicle):\n    self.__vehicle = vehicle\n    free = False\n\n  def remove_vehicle(self):\n    self.__vehicle = None\n    free = True\n\n\nclass HandicappedSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.HANDICAPPED)\n\n\nclass CompactSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.COMPACT)\n\n\nclass LargeSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.LARGE)\n\n\nclass MotorbikeSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.MOTORBIKE)\n\n\nclass ElectricSpot(ParkingSpot):\n  def __init__(self, number):\n    super().__init__(number, ParkingSpotType.ELECTRIC)",
          "subPath": "parkingSpot",
          "fileName": "solution.py"
        },
        "vehicle_java": {
          "language": "java",
          "code": "public abstract class Vehicle {\n  private String licenseNumber;\n  private final VehicleType type;\n  private ParkingTicket ticket;\n\n  public Vehicle(VehicleType type) {\n    this.type = type;\n  }\n\n  public void assignTicket(ParkingTicket ticket) {\n    this.ticket = ticket;\n  }\n}\n\npublic class Car extends Vehicle {\n  public Car() {\n    super(VehicleType.CAR);\n  }\n}\n\npublic class Van extends Vehicle {\n  public Van() {\n    super(VehicleType.VAN);\n  }\n}\n\npublic class Truck extends Vehicle {\n  public Truck() {\n    super(VehicleType.TRUCK);\n  }\n}\n\n// Similarly we can define classes for Motorcycle and Electric vehicles",
          "subPath": "vehicle",
          "fileName": "solution.java"
        },
        "vehicle_py": {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Vehicle(ABC):\n  def __init__(self, license_number, vehicle_type, ticket=None):\n    self.__license_number = license_number\n    self.__type = vehicle_type\n    self.__ticket = ticket\n\n  def assign_ticket(self, ticket):\n    self.__ticket = ticket\n\n\nclass Car(Vehicle):\n  def __init__(self, license_number, ticket=None):\n    super().__init__(license_number, VehicleType.CAR, ticket)\n\n\nclass Van(Vehicle):\n  def __init__(self, license_number, ticket=None):\n    super().__init__(license_number, VehicleType.VAN, ticket)\n\n\nclass Truck(Vehicle):\n  def __init__(self, license_number, ticket=None):\n    super().__init__(license_number, VehicleType.TRUCK, ticket)\n\n# Similarly we can define classes for Motorcycle and Electric vehicles",
          "subPath": "vehicle",
          "fileName": "solution.py"
        }
      }
    },
    "stack-overflow": {
      "id": "stack-overflow",
      "title": "Design Stack Overflow",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Design Stack Overflow\"\nauthor: \"Rajat Srivastava\"\ncategories: system-designs\ntags: [system-design, hld, lld]\ndescription: \"System design concepts and patterns\"\n---\n\nStack Overflow is one of the largest online communities for developers to learn and share their knowledge. The website provides a platform for its users to ask and answer questions, and through membership and active participation, to vote questions and answers up or down. Users can edit questions and answers in a fashion similar to a <MdxLink href=\"https://en.wikipedia.org/wiki/Wiki\">wiki</MdxLink>.\n\nUsers of Stack Overflow can earn reputation points and badges. For example, a person is awarded ten reputation points for receiving an up vote on an answer and five points for the up vote of a question. The can also receive badges for their valued contributions. A higher reputation lets users unlock new privileges like the ability to vote, comment on, and even edit other peoples posts.\n\n---\n## System Requirements\nWe will be designing a system with the following requirements:\n1. Any non-member (guest) can search and view questions. However, to add or upvote a question, they have to become a member.\n2. Members should be able to post new questions.\n3. Members should be able to add an answer to an open question.\n4. Members can add comments to any question or answer.\n5. A member can upvote a question, answer or comment.\n6. Members can flag a question, answer or comment, for serious problems or moderator attention.\n7. Any member can add a bounty to their question to draw attention.\n8. Members will earn badges for being helpful.\n9. Members can vote to close a question; Moderators can close or reopen any question.\n10. Members can add tags to their questions. A tag is a word or phrase that describes the topic of the question.\n11. Members can vote to delete extremely off-topic or very low-quality questions.\n12. Moderators can close a question or undelete an already deleted question.\n13. The system should also be able to identify most frequently used tags in the questions.\n\n---\n## Use Case Diagrams\nWe have five main actors in our system:\n\n- **Admin:** Mainly responsible for blocking or unblocking members.\n- **Guest:** All guests can search and view questions.\n- **Member:** Members can perform all activities that guests can, in addition to which they can add/remove questions, answers, and comments. Members can delete and un-delete their questions, answers or comments.\n- **Moderator:** In addition to all the activities that members can perform, moderators can close/delete/undelete any question.\n- **System:** Mainly responsible for sending notifications and assigning badges to members.\n\nHere are the top use cases for Stack Overflow:\n\n1. Search questions.\n2. Create a new question with bounty and tags.\n3. Add/modify answers to questions.\n4. Add comments to questions or answers.\n5. Moderators can close, delete, and un-delete any question.\n\n<MdxImage \n  src=\"design/stack-overflow/use-case.svg\" \n  alt=\"Usecase Diagram for Stack Overflow\"\n/>\n\n---\n## Class Diagrams\nHere are the main classes of Stack Overflow System:\n\n- **Question:** This class is the central part of our system. It has attributes like Title and Description to define the question. In addition to this, we will track the number of times a question has been viewed or voted on. We should also track the status of a question, as well as closing remarks if the question is closed.\n- **Answer:** The most important attributes of any answer will be the text and the view count. In addition to that, we will also track the number of times an answer is voted on or flagged. We should also track if the question owner has accepted an answer.\n- **Comment:** Similar to answer, comments will have text, and view, vote, and flag counts. Members can add comments to questions and answers.\n- **Tag:** Tags will be identified by their names and will have a field for a description to define them. We will also track daily and weekly frequencies at which tags are associated with questions.\n- **Badge:** Similar to tags, badges will have a name and description.\n- **Photo:** Questions or answers can have photos.\n- **Bounty:** Each member, while asking a question, can place a bounty to draw attention. Bounties will have a total reputation and an expiry date.\n- **Account:** We will have four types of accounts in the system, guest, member, admin, and moderator. Guests can search and view questions. Members can ask questions and earn reputation by answering questions and from bounties.\n- **Notification:** This class will be responsible for sending notifications to members and assigning badges to members based on their reputations.\n\n<MdxImage \n  src=\"design/stack-overflow/class-diagram.svg\" \n  alt=\"Class Diagram for Stack Overflow\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"Uml\"\n/>\n\n---\n## Activity Diagram\n**Post a new question:** Any member or moderator can perform this activity. Here are the steps to post a question:\n\n<MdxImage \n  src=\"design/stack-overflow/activity-post.svg\" \n  alt=\"Activity Diagram for Stack Overflow\"\n/>\n\n---\n## Sequence Diagram\nFollowing is the sequence diagram for creating a new question:\n\n<MdxImage \n  src=\"design/stack-overflow/sequence-create-question.svg\" \n  alt=\"Sequence Diagram for Stack Overflow\"\n/>\n\n---\n## Code\nHere is the high-level definition for the classes described above.\n\n- **Enums and Constants:** Here are the required enums, data types, and constants:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/enums\"\n/>\n\n- **Account, Member, Admin, and Moderator:** These classes represent different people that interact with our system:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/accounts\"\n/>\n\n- **Badge, Tag, and Notification:** Members have badges, questions have tags and notifications:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/tag\"\n/>\n\n- **Photo and Bounty:** Members can put bounties on questions. Answers and Questions can have multiple photos:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/photo-bounty\"\n/>\n\n- **Question, Comment and Answer:** Members can ask questions, as well as add an answer to any question. All members can add comments to all open questions or answers:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/question\"\n/>",
      "body": "Stack Overflow is one of the largest online communities for developers to learn and share their knowledge. The website provides a platform for its users to ask and answer questions, and through membership and active participation, to vote questions and answers up or down. Users can edit questions and answers in a fashion similar to a <MdxLink href=\"https://en.wikipedia.org/wiki/Wiki\">wiki</MdxLink>.\n\nUsers of Stack Overflow can earn reputation points and badges. For example, a person is awarded ten reputation points for receiving an up vote on an answer and five points for the up vote of a question. The can also receive badges for their valued contributions. A higher reputation lets users unlock new privileges like the ability to vote, comment on, and even edit other peoples posts.\n\n---\n## System Requirements\nWe will be designing a system with the following requirements:\n1. Any non-member (guest) can search and view questions. However, to add or upvote a question, they have to become a member.\n2. Members should be able to post new questions.\n3. Members should be able to add an answer to an open question.\n4. Members can add comments to any question or answer.\n5. A member can upvote a question, answer or comment.\n6. Members can flag a question, answer or comment, for serious problems or moderator attention.\n7. Any member can add a bounty to their question to draw attention.\n8. Members will earn badges for being helpful.\n9. Members can vote to close a question; Moderators can close or reopen any question.\n10. Members can add tags to their questions. A tag is a word or phrase that describes the topic of the question.\n11. Members can vote to delete extremely off-topic or very low-quality questions.\n12. Moderators can close a question or undelete an already deleted question.\n13. The system should also be able to identify most frequently used tags in the questions.\n\n---\n## Use Case Diagrams\nWe have five main actors in our system:\n\n- **Admin:** Mainly responsible for blocking or unblocking members.\n- **Guest:** All guests can search and view questions.\n- **Member:** Members can perform all activities that guests can, in addition to which they can add/remove questions, answers, and comments. Members can delete and un-delete their questions, answers or comments.\n- **Moderator:** In addition to all the activities that members can perform, moderators can close/delete/undelete any question.\n- **System:** Mainly responsible for sending notifications and assigning badges to members.\n\nHere are the top use cases for Stack Overflow:\n\n1. Search questions.\n2. Create a new question with bounty and tags.\n3. Add/modify answers to questions.\n4. Add comments to questions or answers.\n5. Moderators can close, delete, and un-delete any question.\n\n<MdxImage \n  src=\"design/stack-overflow/use-case.svg\" \n  alt=\"Usecase Diagram for Stack Overflow\"\n/>\n\n---\n## Class Diagrams\nHere are the main classes of Stack Overflow System:\n\n- **Question:** This class is the central part of our system. It has attributes like Title and Description to define the question. In addition to this, we will track the number of times a question has been viewed or voted on. We should also track the status of a question, as well as closing remarks if the question is closed.\n- **Answer:** The most important attributes of any answer will be the text and the view count. In addition to that, we will also track the number of times an answer is voted on or flagged. We should also track if the question owner has accepted an answer.\n- **Comment:** Similar to answer, comments will have text, and view, vote, and flag counts. Members can add comments to questions and answers.\n- **Tag:** Tags will be identified by their names and will have a field for a description to define them. We will also track daily and weekly frequencies at which tags are associated with questions.\n- **Badge:** Similar to tags, badges will have a name and description.\n- **Photo:** Questions or answers can have photos.\n- **Bounty:** Each member, while asking a question, can place a bounty to draw attention. Bounties will have a total reputation and an expiry date.\n- **Account:** We will have four types of accounts in the system, guest, member, admin, and moderator. Guests can search and view questions. Members can ask questions and earn reputation by answering questions and from bounties.\n- **Notification:** This class will be responsible for sending notifications to members and assigning badges to members based on their reputations.\n\n<MdxImage \n  src=\"design/stack-overflow/class-diagram.svg\" \n  alt=\"Class Diagram for Stack Overflow\"\n/>\n\n<MdxImage \n  src=\"design/concepts/uml.svg\" \n  alt=\"Uml\"\n/>\n\n---\n## Activity Diagram\n**Post a new question:** Any member or moderator can perform this activity. Here are the steps to post a question:\n\n<MdxImage \n  src=\"design/stack-overflow/activity-post.svg\" \n  alt=\"Activity Diagram for Stack Overflow\"\n/>\n\n---\n## Sequence Diagram\nFollowing is the sequence diagram for creating a new question:\n\n<MdxImage \n  src=\"design/stack-overflow/sequence-create-question.svg\" \n  alt=\"Sequence Diagram for Stack Overflow\"\n/>\n\n---\n## Code\nHere is the high-level definition for the classes described above.\n\n- **Enums and Constants:** Here are the required enums, data types, and constants:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/enums\"\n/>\n\n- **Account, Member, Admin, and Moderator:** These classes represent different people that interact with our system:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/accounts\"\n/>\n\n- **Badge, Tag, and Notification:** Members have badges, questions have tags and notifications:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/tag\"\n/>\n\n- **Photo and Bounty:** Members can put bounties on questions. Answers and Questions can have multiple photos:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/photo-bounty\"\n/>\n\n- **Question, Comment and Answer:** Members can ask questions, as well as add an answer to any question. All members can add comments to all open questions or answers:\n\n<MdxCodeTabs\n  langs={[\"java\", \"py\"]}\n  path=\"system-design/code/stack-overflow/question\"\n/>",
      "solutions": {
        "accounts_java": {
          "language": "java",
          "code": "// For simplicity, we are not defining getter and setter functions. The reader can\n// assume that all class attributes are private and accessed through their respective\n// public getter methods and modified only through their public methods function.\n\npublic class Account {\n  private String id;\n  private String password;\n  private AccountStatus status;\n  private String name;\n  private Address address;\n  private String email;\n  private String phone;\n  private int reputation;\n\n  public boolean resetPassword();\n}\n\npublic class Member {\n  private Account account;\n  private List<Badge> badges;\n\n  public int getReputation();\n  public String getEmail();\n  public boolean createQuestion(Question question);\n  public boolean createTag(Tag tag);\n}\n\npublic class Admin extends Member {\n  public boolean blockMember(Member member);\n  public boolean unblockMember(Member member);\n}\n\npublic class Moderator extends Member {\n  public boolean closeQuestion(Question question);\n  public boolean undeleteQuestion(Question question);\n}",
          "subPath": "accounts",
          "fileName": "solution.java"
        },
        "accounts_py": {
          "language": "py",
          "code": "# For simplicity, we are not defining getter and setter functions. The reader can\n# assume that all class attributes are private and accessed through their respective\n# public getter methods and modified only through their public methods function.\n\n\nclass Account:\n  def __init__(self, id, password, name, address, email, phone, status=AccountStatus.Active):\n    self.__id = id\n    self.__password = password\n    self.__name = name\n    self.__address = address\n    self.__email = email\n    self.__phone = phone\n    self.__status = status\n    self.__reputation = 0\n\n  def reset_password(self):\n    None\n\n\nclass Member:\n  def __init__(self, account):\n    self.__account = account\n    self.__badges = []\n\n  def get_reputation(self):\n    return self.__account.get_reputation()\n\n  def get_email(self):\n    return self.__account.get_email()\n\n  def create_question(self, question):\n    None\n\n  def create_tag(self, tag):\n    None\n\n\nclass Admin(Member):\n  def block_member(self, member):\n    None\n\n  def unblock_member(self, member):\n    None\n\n\nclass Moderator(Member):\n  def close_question(self, question):\n    None\n\n  def undelete_question(self, question):\n    None",
          "subPath": "accounts",
          "fileName": "solution.py"
        },
        "enums_java": {
          "language": "java",
          "code": "public enum QuestionStatus{\n  OPEN,\n  CLOSED,\n  ON_HOLD,\n  DELETED\n}\n\npublic enum QuestionClosingRemark{\n  DUPLICATE,\n  OFF_TOPIC,\n  TOO_BROAD,\n  NOT_CONSTRUCTIVE,\n  NOT_A_REAL_QUESTION,\n  PRIMARILY_OPINION_BASED\n}\n\npublic enum AccountStatus{\n  ACTIVE,\n  CLOSED,\n  CANCELED,\n  BLACKLISTED,\n  BLOCKED\n}",
          "subPath": "enums",
          "fileName": "solution.java"
        },
        "enums_py": {
          "language": "py",
          "code": "class QuestionStatus(Enum):\n  OPEN, CLOSED, ON_HOLD, DELETED = 1, 2, 3, 4\n\n\nclass QuestionClosingRemark(Enum):\n  DUPLICATE, OFF_TOPIC, TOO_BROAD, NOT_CONSTRUCTIVE, NOT_A_REAL_QUESTION, PRIMARILY_OPINION_BASED = 1, 2, 3, 4, 5, 6\n\n\nclass AccountStatus(Enum):\n  ACTIVE, CLOSED, CANCELED, BLACKLISTED, BLOCKED = 1, 2, 3, 4, 5",
          "subPath": "enums",
          "fileName": "solution.py"
        },
        "photo-bounty_java": {
          "language": "java",
          "code": "public class Photo {\n  private int photoId;\n  private String photoPath;\n  private Date creationDate;\n\n  private Member creatingMember;\n\n  public boolean delete();\n}\n\npublic class Bounty {\n  private int reputation;\n  private Date expiry;\n\n  public boolean modifyReputation(int reputation);\n}",
          "subPath": "photo-bounty",
          "fileName": "solution.java"
        },
        "photo-bounty_py": {
          "language": "py",
          "code": "import datetime\n\nclass Photo:\n  def __init__(self, id, path, member):\n    self.__photo_id = id\n    self.__photo_path = path\n    self.__creation_date = datetime.datetime.now()\n    self.__creating_member = member\n\n  def delete(self):\n    None\n\n# import datetime\n\n\nclass Bounty:\n  def __init__(self, reputation, expiry):\n    self.__reputation = reputation\n    self.__expiry = expiry\n\n  def modify_reputation(self, reputation):\n    None",
          "subPath": "photo-bounty",
          "fileName": "solution.py"
        },
        "question_java": {
          "language": "java",
          "code": "public interface Search {\n  public static List<Question> search(String query);\n}\n\npublic class Question implements Search {\n  private String title;\n  private String description;\n  private int viewCount;\n  private int voteCount;\n  private Date creationTime;\n  private Date updateTime;\n  private QuestionStatus status;\n  private QuestionClosingRemark closingRemark;\n\n  private Member askingMember;\n  private Bounty bounty;\n  private List<Photo> photos;\n  private List<Comment> comments;\n  private List<Answer> answers;\n\n  public boolean close();\n  public boolean undelete();\n  public boolean addComment(Comment comment);\n  public boolean addBounty(Bounty bounty);\n\n  public static List<Question> search(String query) {\n    // return all questions containing the string query in their title or description.\n  }\n}\n\npublic class Comment {\n  private String text;\n  private Date creationTime;\n  private int flagCount;\n  private int voteCount;\n\n  private Member askingMember;\n\n  public boolean incrementVoteCount();\n}\n\npublic class Answer {\n  private String answerText;\n  private boolean accepted;\n  private int voteCount;\n  private int flagCount;\n  private Date creationTime;\n\n  private Member creatingMember;\n  private List<Photo> photos;\n\n  public boolean incrementVoteCount();\n}",
          "subPath": "question",
          "fileName": "solution.java"
        },
        "question_py": {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Search(ABC):\n  def search(self, query):\n    None\n\nimport datetime\n\nclass Question(Search):\n  def __init__(self, title, description, bounty, asking_member):\n    self.__title = title\n    self.__description = description\n    self.__view_count = 0\n    self.__vote_count = 0\n    self.__creation_time = datetime.datetime.now()\n    self.__update_time = datetime.datetime.now()\n    self.__status = QuestionStatus.OPEN\n    self.__closing_remark = QuestionClosingRemark.DUPLICATE\n\n    self.__bounty = bounty\n    self.__asking_member = asking_member\n    self.__photos = []\n    self.__comments = []\n    self.__answers = []\n\n  def close(self):\n    None\n\n  def undelete(self):\n    None\n\n  def add_comment(self, comment):\n    None\n\n  def add_bounty(self, bounty):\n    None\n\n  def search(self, query):\n    # return all questions containing the string query in their title or description.\n    None\n\n\nclass Comment:\n  def __init__(self, text, member):\n    self.__text = text\n    self.__creation_time = datetime.datetime.now()\n    self.__flag_count = 0\n    self.__vote_count = 0\n    self.__asking_member = member\n\n  def increment_vote_count(self):\n    None\n\n\nclass Answer:\n  def __init__(self, text, member):\n    self.__answer_text = text\n    self.__accepted = False\n    self.__vote_count = 0\n    self.__flag_count = 0\n    self.__creation_time = datetime.datetime.now()\n    self.__creating_member = member\n    self.__photos = []\n\n  def increment_vote_count(self):\n    None",
          "subPath": "question",
          "fileName": "solution.py"
        },
        "tag_java": {
          "language": "java",
          "code": "public class Badge {\n  private String name;\n  private String description;\n}\n\npublic class Tag {\n  private String name;\n  private String description;\n  private long dailyAskedFrequency;\n  private long weeklyAskedFrequency;\n}\n\npublic class Notification {\n  private int notificationId;\n  private Date createdOn;\n  private String content;\n\n  public boolean sendNotification();\n}",
          "subPath": "tag",
          "fileName": "solution.java"
        },
        "tag_py": {
          "language": "py",
          "code": "class Badge:\n  def __init__(self, name, description):\n    self.__name = name\n    self.__description = description\n\n\nclass Tag:\n  def __init__(self, name, description):\n    self.__name = name\n    self.__description = description\n    self.__daily_asked_frequency = 0\n    self.__weekly_asked_frequency = 0\n\n# import datetime\n\n\nclass Notification:\n  def __init__(self, id, content):\n    self.__notification_id = id\n    self.__created_on = datetime.datetime.now()\n    self.__content = content\n\n  def send_notification(self):\n    None",
          "subPath": "tag",
          "fileName": "solution.py"
        }
      }
    }
  },
  "ood": {
    "activity-diagram": {
      "id": "activity-diagram",
      "title": "Activity Diagrams",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Activity Diagrams\"\nauthor: \"Rajat Srivastava\"\ncategories: design-concepts\ntags: [design]\ndescription: \"System design concepts and patterns\"\n---\n\nWe use Activity Diagrams to illustrate the flow of control in a system. An activity diagram shows the flow of control for a system functionality; it emphasizes the condition of flow and the sequence in which it happens. We can also use an activity diagram to refer to the steps involved in the execution of a use case.\n\nActivity diagrams illustrate the dynamic nature of a system by modeling the flow of control from activity to activity. An activity represents an operation on some class in the system that results in a change in the state of the system. Typically, activity diagrams are used to model workflow or business processes and internal operations.\n\nFollowing is an activity diagram for a user performing online shopping:\n\n<MdxImage src=\"design/concepts/activity-diagram.svg\" />\n\n**What is the difference between Activity diagram and Sequence diagram?**\n\n**Activity diagram:** captures the process flow. It is used for functional modeling. A functional model represents the flow of values from external inputs, through operations and internal data stores, to external outputs.\n**Sequence diagram:** tracks the interaction between the objects. It is used for dynamic modeling, which is represented by tracking states, transitions between states, and the events that trigger these transitions.",
      "body": "We use Activity Diagrams to illustrate the flow of control in a system. An activity diagram shows the flow of control for a system functionality; it emphasizes the condition of flow and the sequence in which it happens. We can also use an activity diagram to refer to the steps involved in the execution of a use case.\n\nActivity diagrams illustrate the dynamic nature of a system by modeling the flow of control from activity to activity. An activity represents an operation on some class in the system that results in a change in the state of the system. Typically, activity diagrams are used to model workflow or business processes and internal operations.\n\nFollowing is an activity diagram for a user performing online shopping:\n\n<MdxImage src=\"design/concepts/activity-diagram.svg\" />\n\n**What is the difference between Activity diagram and Sequence diagram?**\n\n**Activity diagram:** captures the process flow. It is used for functional modeling. A functional model represents the flow of values from external inputs, through operations and internal data stores, to external outputs.\n**Sequence diagram:** tracks the interaction between the objects. It is used for dynamic modeling, which is represented by tracking states, transitions between states, and the events that trigger these transitions.",
      "solutions": {}
    },
    "class-diagram": {
      "id": "class-diagram",
      "title": "Class Diagram",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Class Diagram\"\nauthor: \"Rajat Srivastava\"\ncategories: design-concepts\ntags: [design]\ndescription: \"System design concepts and patterns\"\n---\n\nClass diagram is the backbone of object-oriented modeling - it shows how different entities (people, things, and data) relate to each other. In other words, it shows the static structures of the system.\n\nA class diagram describes the attributes and operations of a class and also the constraints imposed on the system. Class diagrams are widely used in the modeling of object-oriented systems because they are the only UML diagrams that can be mapped directly to object-oriented languages.\n\nThe purpose of the class diagram can be summarized as:\n1. Analysis and design of the static view of an application;\n2. To describe the responsibilities of a system;\n3. To provide a base for component and deployment diagrams; and,\n4. Forward and reverse engineering.\n\nA class is depicted in the class diagram as a rectangle with three horizontal sections, as shown in the figure below. The upper section shows the classs name (Flight), the middle section contains the properties of the class, and the lower section contains the classs operations (or methods).\n\n<MdxImage src=\"design/concepts/class-flight-basic.svg\" />\n\nThese are the different types of relationships between classes:\n\n**Association:** If two classes in a model need to communicate with each other, there must be a link between them. This link can be represented by an association. Associations can be represented in a class diagram by a line between these classes with an arrow indicating the navigation direction.\n- By default, associations are always assumed to be bi-directional; this means that both classes are aware of each other and their relationship. In the diagram below, the association between Pilot and FlightInstance is bi-directional, as both classes know each other.\n- By contrast, in a uni-directional association, two classes are related - but only one class knows that the relationship exists. In the below example, only Flight class knows about Aircraft; hence it is a uni-directional association\n\n**Multiplicity:** Multiplicity indicates how many instances of a class participate in the relationship. It is a constraint that specifies the range of permitted cardinalities between two classes. For example, in the diagram below, one FlightInstance will have two Pilots, while a Pilot can have many FlightInstances. A ranged multiplicity can be expressed as 0* which means zero to many\" or as 24 which means two to four.\n\nWe can indicate the multiplicity of an association by adding multiplicity adornments to the line denoting the association. \n\nThe below diagram, demonstrates that **a FlightInstance has exactly two Pilots but a Pilot can have many FlightInstances.**\n\n<MdxImage src=\"design/concepts/class-flight-complete.png\" />\n\n**Aggregation:** Aggregation is a special type of association used to model a whole to its parts relationship. In a basic aggregation relationship, the lifecycle of a PART class is independent of the WHOLE classs lifecycle. In other words, aggregation implies a relationship where the child can exist independently of the parent. In the above diagram, Aircraft can exist without Airline.\n\n**Composition:** The composition aggregation relationship is just another form of the aggregation relationship, but the child classs instance lifecycle is dependent on the parent classs instance lifecycle. In other words, Composition implies a relationship where the child cannot exist independent of the parent. In the above example, WeeklySchedule is composed in Flight which means when Flight lifecycle ends, WeeklySchedule automatically gets destroyed.\n\n**Generalization:** Generalization is the mechanism for combining similar classes of objects into a single, more general class. Generalization identifies commonalities among a set of entities. In the above diagram, Crew, Pilot, and Admin, all are Person.\n\n**Dependency:** A dependency relationship is a relationship in which one class, the client, uses or depends on another class, the supplier. In the above diagram, FlightReservation depends on Payment.\n\n**Abstract class:** An abstract class is identified by specifying its name in italics. In the above diagram, both Person and Account classes are abstract classes.\n\n*UML Conventions*",
      "body": "Class diagram is the backbone of object-oriented modeling - it shows how different entities (people, things, and data) relate to each other. In other words, it shows the static structures of the system.\n\nA class diagram describes the attributes and operations of a class and also the constraints imposed on the system. Class diagrams are widely used in the modeling of object-oriented systems because they are the only UML diagrams that can be mapped directly to object-oriented languages.\n\nThe purpose of the class diagram can be summarized as:\n1. Analysis and design of the static view of an application;\n2. To describe the responsibilities of a system;\n3. To provide a base for component and deployment diagrams; and,\n4. Forward and reverse engineering.\n\nA class is depicted in the class diagram as a rectangle with three horizontal sections, as shown in the figure below. The upper section shows the classs name (Flight), the middle section contains the properties of the class, and the lower section contains the classs operations (or methods).\n\n<MdxImage src=\"design/concepts/class-flight-basic.svg\" />\n\nThese are the different types of relationships between classes:\n\n**Association:** If two classes in a model need to communicate with each other, there must be a link between them. This link can be represented by an association. Associations can be represented in a class diagram by a line between these classes with an arrow indicating the navigation direction.\n- By default, associations are always assumed to be bi-directional; this means that both classes are aware of each other and their relationship. In the diagram below, the association between Pilot and FlightInstance is bi-directional, as both classes know each other.\n- By contrast, in a uni-directional association, two classes are related - but only one class knows that the relationship exists. In the below example, only Flight class knows about Aircraft; hence it is a uni-directional association\n\n**Multiplicity:** Multiplicity indicates how many instances of a class participate in the relationship. It is a constraint that specifies the range of permitted cardinalities between two classes. For example, in the diagram below, one FlightInstance will have two Pilots, while a Pilot can have many FlightInstances. A ranged multiplicity can be expressed as 0* which means zero to many\" or as 24 which means two to four.\n\nWe can indicate the multiplicity of an association by adding multiplicity adornments to the line denoting the association. \n\nThe below diagram, demonstrates that **a FlightInstance has exactly two Pilots but a Pilot can have many FlightInstances.**\n\n<MdxImage src=\"design/concepts/class-flight-complete.png\" />\n\n**Aggregation:** Aggregation is a special type of association used to model a whole to its parts relationship. In a basic aggregation relationship, the lifecycle of a PART class is independent of the WHOLE classs lifecycle. In other words, aggregation implies a relationship where the child can exist independently of the parent. In the above diagram, Aircraft can exist without Airline.\n\n**Composition:** The composition aggregation relationship is just another form of the aggregation relationship, but the child classs instance lifecycle is dependent on the parent classs instance lifecycle. In other words, Composition implies a relationship where the child cannot exist independent of the parent. In the above example, WeeklySchedule is composed in Flight which means when Flight lifecycle ends, WeeklySchedule automatically gets destroyed.\n\n**Generalization:** Generalization is the mechanism for combining similar classes of objects into a single, more general class. Generalization identifies commonalities among a set of entities. In the above diagram, Crew, Pilot, and Admin, all are Person.\n\n**Dependency:** A dependency relationship is a relationship in which one class, the client, uses or depends on another class, the supplier. In the above diagram, FlightReservation depends on Payment.\n\n**Abstract class:** An abstract class is identified by specifying its name in italics. In the above diagram, both Person and Account classes are abstract classes.\n\n*UML Conventions*",
      "solutions": {}
    },
    "oo-analysis-design": {
      "id": "oo-analysis-design",
      "title": "Object Oriented Analysis and Design",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Object Oriented Analysis and Design\"\nauthor: \"Rajat Srivastava\"\ncategories: design-concepts\ntags: [design]\ndescription: \"System design concepts and patterns\"\n---\n\nObject Oriented Analysis and Design is a structured method for analyzing and designing a system by applying object-oriented concepts. This design process consists of an investigation into the objects constituting the system. It starts by first identifying the objects of the system and then figuring out the interactions between various objects.\n\nThe process of OO analysis and design can be described as:\n\n- Identifying the objects in a system;\n- Defining relationships between objects;\n- Establishing the interface of each object; and,\n- Making a design, which can be converted to executables using OO languages.\n\nWe need a standard method/tool to document all this information; for this purpose we use UML. UML can be considered as the successor of object-oriented (OO) analysis and design. UML is powerful enough to represent all the concepts that exist in object-oriented analysis and design. UML diagrams are a representation of object-oriented concepts only. Thus, before learning UML, it is essential to understand OO concepts.",
      "body": "Object Oriented Analysis and Design is a structured method for analyzing and designing a system by applying object-oriented concepts. This design process consists of an investigation into the objects constituting the system. It starts by first identifying the objects of the system and then figuring out the interactions between various objects.\n\nThe process of OO analysis and design can be described as:\n\n- Identifying the objects in a system;\n- Defining relationships between objects;\n- Establishing the interface of each object; and,\n- Making a design, which can be converted to executables using OO languages.\n\nWe need a standard method/tool to document all this information; for this purpose we use UML. UML can be considered as the successor of object-oriented (OO) analysis and design. UML is powerful enough to represent all the concepts that exist in object-oriented analysis and design. UML diagrams are a representation of object-oriented concepts only. Thus, before learning UML, it is essential to understand OO concepts.",
      "solutions": {}
    },
    "oops": {
      "id": "oops",
      "title": "Object-Oriented Basics",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Object-Oriented Basics\"\nauthor: \"Rajat Srivastava\"\ncategories: design-concepts\ntags: [concept, design, oop, object-oriented, programming]\ndescription: \"Learn the fundamental concepts of Object-Oriented Programming including encapsulation, abstraction, inheritance, and polymorphism.\"\n---\n\nObject-oriented programming (OOP) is a style of programming that focuses on using objects to design and build applications. Contrary to procedure-oriented programming where programs are designed as blocks of statements to manipulate data, OOP organizes the program to combine data and functionality and wrap it inside something called an Object.\n\nIf you have never used an object-oriented programming language before, you will need to learn a few basic concepts before you can begin writing any code. This chapter will introduce some basic concepts of OOP:\n\n**Objects:** Objects represent a real-world entity and the basic building block of OOP. For example, an Online Shopping System will have objects such as shopping cart, customer, product item, etc.\n\n**Class:** Class is the prototype or blueprint of an object. It is a template definition of the attributes and methods of an object. For example, in the Online Shopping System, the Customer object will have attributes like shipping address, credit card, etc., and methods for placing an order, canceling an order, etc.\n\n<MdxImage src=\"design/concepts/basics.svg\" />\n\nThe four principles of object-oriented programming are encapsulation, abstraction, inheritance, and polymorphism.\n\n**Encapsulation:** Encapsulation is the mechanism of binding the data together and hiding it from the outside world. Encapsulation is achieved when each object keeps its state private so that other objects dont have direct access to its state. Instead, they can access this state only through a set of public functions.\n\n**Abstraction:** Abstraction can be thought of as the natural extension of encapsulation. It means hiding all but the relevant data about an object in order to reduce the complexity of the system. In a large system, objects talk to each other, which makes it difficult to maintain a large code base; abstraction helps by hiding internal implementation details of objects and only revealing operations that are relevant to other objects.\n\n**Inheritance:** Inheritance is the mechanism of creating new classes from existing ones.\n\n**Polymorphism:** Polymorphism (from Greek, meaning many forms) is the ability of an object to take different forms and thus, depending upon the context, to respond to the same message in different ways. Take the example of a chess game; a chess piece can take many forms, like bishop, castle, or knight and all these pieces will respond differently to the move message.",
      "body": "Object-oriented programming (OOP) is a style of programming that focuses on using objects to design and build applications. Contrary to procedure-oriented programming where programs are designed as blocks of statements to manipulate data, OOP organizes the program to combine data and functionality and wrap it inside something called an Object.\n\nIf you have never used an object-oriented programming language before, you will need to learn a few basic concepts before you can begin writing any code. This chapter will introduce some basic concepts of OOP:\n\n**Objects:** Objects represent a real-world entity and the basic building block of OOP. For example, an Online Shopping System will have objects such as shopping cart, customer, product item, etc.\n\n**Class:** Class is the prototype or blueprint of an object. It is a template definition of the attributes and methods of an object. For example, in the Online Shopping System, the Customer object will have attributes like shipping address, credit card, etc., and methods for placing an order, canceling an order, etc.\n\n<MdxImage src=\"design/concepts/basics.svg\" />\n\nThe four principles of object-oriented programming are encapsulation, abstraction, inheritance, and polymorphism.\n\n**Encapsulation:** Encapsulation is the mechanism of binding the data together and hiding it from the outside world. Encapsulation is achieved when each object keeps its state private so that other objects dont have direct access to its state. Instead, they can access this state only through a set of public functions.\n\n**Abstraction:** Abstraction can be thought of as the natural extension of encapsulation. It means hiding all but the relevant data about an object in order to reduce the complexity of the system. In a large system, objects talk to each other, which makes it difficult to maintain a large code base; abstraction helps by hiding internal implementation details of objects and only revealing operations that are relevant to other objects.\n\n**Inheritance:** Inheritance is the mechanism of creating new classes from existing ones.\n\n**Polymorphism:** Polymorphism (from Greek, meaning many forms) is the ability of an object to take different forms and thus, depending upon the context, to respond to the same message in different ways. Take the example of a chess game; a chess piece can take many forms, like bishop, castle, or knight and all these pieces will respond differently to the move message.",
      "solutions": {}
    },
    "sequence-diagram": {
      "id": "sequence-diagram",
      "title": "Sequence diagram",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Sequence diagram\"\nauthor: \"Rajat Srivastava\"\ncategories: design-concepts\ntags: [design]\ndescription: \"System design concepts and patterns\"\n---\n\nSequence diagrams describe interactions among classes in terms of an exchange of messages over time and are used to explore the logic of complex operations, functions or procedures. In this diagram, the sequence of interactions between the objects is represented in a step-by-step manner.\n\nSequence diagrams show a detailed flow for a specific use case or even just part of a particular use case. They are almost self-explanatory; they show the calls between the different objects in their sequence and can explain, at a detailed level, different calls to various objects.\n\nA sequence diagram has two dimensions: The vertical dimension shows the sequence of messages in the chronological order that they occur; the horizontal dimension shows the object instances to which the messages are sent.\n\n<MdxImage src=\"design/concepts/sequence-diagram.svg\" />\n\nA sequence diagram is straightforward to draw. Across the top of your diagram, identify the class instances (objects) by putting each class instance inside a box (see above figure). If a class instance sends a message to another class instance, draw a line with an open arrowhead pointing to the receiving class instance and place the name of the message above the line. Optionally, for important messages, you can draw a dotted line with an arrowhead pointing back to the originating class instance; label the returned value above the dotted line.",
      "body": "Sequence diagrams describe interactions among classes in terms of an exchange of messages over time and are used to explore the logic of complex operations, functions or procedures. In this diagram, the sequence of interactions between the objects is represented in a step-by-step manner.\n\nSequence diagrams show a detailed flow for a specific use case or even just part of a particular use case. They are almost self-explanatory; they show the calls between the different objects in their sequence and can explain, at a detailed level, different calls to various objects.\n\nA sequence diagram has two dimensions: The vertical dimension shows the sequence of messages in the chronological order that they occur; the horizontal dimension shows the object instances to which the messages are sent.\n\n<MdxImage src=\"design/concepts/sequence-diagram.svg\" />\n\nA sequence diagram is straightforward to draw. Across the top of your diagram, identify the class instances (objects) by putting each class instance inside a box (see above figure). If a class instance sends a message to another class instance, draw a line with an open arrowhead pointing to the receiving class instance and place the name of the message above the line. Optionally, for important messages, you can draw a dotted line with an arrowhead pointing back to the originating class instance; label the returned value above the dotted line.",
      "solutions": {}
    },
    "uml": {
      "id": "uml",
      "title": "What is UML?",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"What is UML?\"\nauthor: \"Rajat Srivastava\"\ncategories: design-concepts\ntags: [design]\ndescription: \"System design concepts and patterns\"\n---\n\nUML stands for Unified Modeling Language and is used to model the Object-Oriented Analysis of a software system. UML is a way of visualizing and documenting a software system by using a collection of diagrams, which helps engineers, businesspeople, and system architects understand the behavior and structure of the system being designed.\n\nBenefits of using UML:\n\n1. Helps develop a quick understanding of a software system.\n2. UML modeling helps in breaking a complex system into discrete pieces that can be easily understood.\n3. UMLs graphical notations can be used to communicate design decisions.\n4. Since UML is independent of any specific platform or language or technology, it is easier to abstract out concepts.\n5. It becomes easier to hand the system over to a new team.\n\n<MdxImage src=\"design/concepts/uml.svg\" />\n\n**Types of UML Diagrams:** The current UML standards call for 14 different kinds of diagrams. These diagrams are organized into two distinct groups: structural diagrams and behavioral or interaction diagrams. As the names suggest, some UML diagrams analyze and depict the structure of a system or process, whereas others describe the behavior of the system, its actors, and its building components. The different types are broken down as follows:\n\n**Structural UML diagrams**\n- Class diagram\n- Object diagram\n- Package diagram\n- Component diagram\n- Composite structure diagram\n- Deployment diagram\n- Profile diagram\n\n**Behavioral UML diagrams**\n- Use case diagram\n- Activity diagram\n- Sequence diagram\n- State diagram\n- Communication diagram\n- Interaction overview diagram\n- Timing diagram\n\nIn this course, we will be focusing on the following UML diagrams:\n\n- **Use Case Diagram:** Used to describe a set of user scenarios, this diagram, illustrates the functionality provided by the system.\n\n- **Class Diagram:** Used to describe structure and behavior in the use cases, this diagram provides a conceptual model of the system in terms of entities and their relationships.\n\n- **Activity Diagram:** Used to model the functional flow-of-control between two or more class objects.\n\n- **Sequence Diagram:** Used to describe interactions among classes in terms of an exchange of messages over time.",
      "body": "UML stands for Unified Modeling Language and is used to model the Object-Oriented Analysis of a software system. UML is a way of visualizing and documenting a software system by using a collection of diagrams, which helps engineers, businesspeople, and system architects understand the behavior and structure of the system being designed.\n\nBenefits of using UML:\n\n1. Helps develop a quick understanding of a software system.\n2. UML modeling helps in breaking a complex system into discrete pieces that can be easily understood.\n3. UMLs graphical notations can be used to communicate design decisions.\n4. Since UML is independent of any specific platform or language or technology, it is easier to abstract out concepts.\n5. It becomes easier to hand the system over to a new team.\n\n<MdxImage src=\"design/concepts/uml.svg\" />\n\n**Types of UML Diagrams:** The current UML standards call for 14 different kinds of diagrams. These diagrams are organized into two distinct groups: structural diagrams and behavioral or interaction diagrams. As the names suggest, some UML diagrams analyze and depict the structure of a system or process, whereas others describe the behavior of the system, its actors, and its building components. The different types are broken down as follows:\n\n**Structural UML diagrams**\n- Class diagram\n- Object diagram\n- Package diagram\n- Component diagram\n- Composite structure diagram\n- Deployment diagram\n- Profile diagram\n\n**Behavioral UML diagrams**\n- Use case diagram\n- Activity diagram\n- Sequence diagram\n- State diagram\n- Communication diagram\n- Interaction overview diagram\n- Timing diagram\n\nIn this course, we will be focusing on the following UML diagrams:\n\n- **Use Case Diagram:** Used to describe a set of user scenarios, this diagram, illustrates the functionality provided by the system.\n\n- **Class Diagram:** Used to describe structure and behavior in the use cases, this diagram provides a conceptual model of the system in terms of entities and their relationships.\n\n- **Activity Diagram:** Used to model the functional flow-of-control between two or more class objects.\n\n- **Sequence Diagram:** Used to describe interactions among classes in terms of an exchange of messages over time.",
      "solutions": {}
    },
    "use-case": {
      "id": "use-case",
      "title": "Use Case Diagrams",
      "difficulty": "medium",
      "companies": [],
      "topics": [],
      "langs": [],
      "content": "---\ntitle: \"Use Case Diagrams\"\nauthor: \"Rajat Srivastava\"\ncategories: design-concepts\ntags: [design]\ndescription: \"System design concepts and patterns\"\n---\n\nUse case diagrams describe a set of actions (called use cases) that a system should or can perform in collaboration with one or more external users of the system (called actors). Each use case should provide some observable and valuable result to the actors.\n\n1. Use Case Diagrams describe the high-level functional behavior of the system.\n2. It answers what system does from the user point of view.\n3. Use case answers What will the system do? and at the same time tells us What will the system NOT do?.\n\nA use case illustrates a unit of functionality provided by the system. The primary purpose of the use case diagram is to help development teams visualize the functional requirements of a system, including the relationship of actors to the essential processes, as well as the relationships among different use cases.\n\nTo illustrate a use case on a use case diagram, we draw an oval in the middle of the diagram and put the name of the use case in the center of the oval. To show an actor (indicating a system user) on a use-case diagram, we draw a stick figure to the left or right of the diagram.\n\n<MdxImage src=\"design/concepts/use-case.svg\" />\n\nThe different components of the use case diagram are:\n- **System boundary:** A system boundary defines the scope and limits of the system. It is shown as a rectangle that spans all use cases of the system.\n- **Actors:** An actor is an entity who performs specific actions. These roles are the actual business roles of the users in a given system. An actor interacts with a use case of the system. For example, in a banking system, the customer is one of the actors.\n- **Use Case:** Every business functionality is a potential use case. The use case should list the discrete business functionality specified in the problem statement.\n- **Include:** Include relationship represents an invocation of one use case by another use case. From a coding perspective, it is like one function being called by another function.\n- **Extend:** This relationship signifies that the extended use case will work exactly like the base use case, except that some new steps will be inserted in the extended use case.",
      "body": "Use case diagrams describe a set of actions (called use cases) that a system should or can perform in collaboration with one or more external users of the system (called actors). Each use case should provide some observable and valuable result to the actors.\n\n1. Use Case Diagrams describe the high-level functional behavior of the system.\n2. It answers what system does from the user point of view.\n3. Use case answers What will the system do? and at the same time tells us What will the system NOT do?.\n\nA use case illustrates a unit of functionality provided by the system. The primary purpose of the use case diagram is to help development teams visualize the functional requirements of a system, including the relationship of actors to the essential processes, as well as the relationships among different use cases.\n\nTo illustrate a use case on a use case diagram, we draw an oval in the middle of the diagram and put the name of the use case in the center of the oval. To show an actor (indicating a system user) on a use-case diagram, we draw a stick figure to the left or right of the diagram.\n\n<MdxImage src=\"design/concepts/use-case.svg\" />\n\nThe different components of the use case diagram are:\n- **System boundary:** A system boundary defines the scope and limits of the system. It is shown as a rectangle that spans all use cases of the system.\n- **Actors:** An actor is an entity who performs specific actions. These roles are the actual business roles of the users in a given system. An actor interacts with a use case of the system. For example, in a banking system, the customer is one of the actors.\n- **Use Case:** Every business functionality is a potential use case. The use case should list the discrete business functionality specified in the problem statement.\n- **Include:** Include relationship represents an invocation of one use case by another use case. From a coding perspective, it is like one function being called by another function.\n- **Extend:** This relationship signifies that the extended use case will work exactly like the base use case, except that some new steps will be inserted in the extended use case.",
      "solutions": {}
    }
  },
  "behavioral": {
    "amazon-leadership-principles": {
      "id": "amazon-leadership-principles",
      "title": "Amazon Leadership Principles",
      "difficulty": "medium",
      "companies": [
        "amazon"
      ],
      "topics": [
        "leadership",
        "culture",
        "principles",
        "behavioral"
      ],
      "langs": [],
      "content": "---\nlayout: post\ntitle: Amazon Leadership Principles\ndescription: Amazon's Leadership Principles are the foundation of their culture and guide how Amazonians make decisions, solve problems, and interact with customers and colleagues.\ntopics: [leadership, culture, principles, behavioral]\ncompanies: [amazon]\ndifficulty: medium\ntags: [Amazon, Leadership, Principles, Culture, Interview, Behavioral]\n---\n\n# Amazon Leadership Principles\n\nAmazon's Leadership Principles are the foundation of their culture and guide how Amazonians make decisions, solve problems, and interact with customers and colleagues.\n\n---\n\n## 1. Customer Obsession\n\nLeaders start with the customer and work backwards. They work vigorously to earn and keep customer trust. Although leaders pay attention to competitors, they obsess over customers.\n\n**Key Points:**\n- Start with customer needs\n- Work backwards from customer experience\n- Earn and maintain customer trust\n- Focus on customers over competitors\n\n*Tags: #CustomerObsession #CustomerFirst #Trust*\n\n---\n\n## 2. Ownership\n\nLeaders are owners. They think long term and don't sacrifice long-term value for short-term results. They act on behalf of the entire company, beyond just their own team. They never say \"that's not my job.\"\n\n**Key Points:**\n- Think long-term\n- Act for the entire company\n- Take responsibility beyond your role\n- Avoid short-term thinking\n\n*Tags: #Ownership #LongTerm #Responsibility #Accountability*\n\n---\n\n## 3. Invent and Simplify\n\nLeaders expect and require innovation and invention from their teams and always find ways to simplify. They are externally aware, look for new ideas from everywhere, and are not limited by \"not invented here.\" As we do new things, we accept that we may be misunderstood for long periods of time.\n\n**Key Points:**\n- Drive innovation and invention\n- Simplify complex problems\n- Be externally aware\n- Accept being misunderstood\n\n*Tags: #Innovation #Simplification #Invention #ExternalAwareness*\n\n---\n\n## 4. Are Right, A Lot\n\nLeaders are right a lot. They have strong judgment and good instincts. They seek diverse perspectives and work to disconfirm their beliefs.\n\n**Key Points:**\n- Demonstrate strong judgment\n- Develop good instincts\n- Seek diverse perspectives\n- Challenge your own beliefs\n\n*Tags: #Judgment #DecisionMaking #DiversePerspectives #SelfChallenge*\n\n---\n\n## 5. Learn and Be Curious\n\nLeaders are never done learning and always seek to improve themselves. They are curious about new possibilities and act to explore them.\n\n**Key Points:**\n- Continuous learning mindset\n- Self-improvement focus\n- Curiosity about possibilities\n- Take action to explore\n\n*Tags: #ContinuousLearning #Curiosity #SelfImprovement #Growth*\n\n---\n\n## 6. Hire and Develop the Best\n\nLeaders raise the performance bar with every hire and promotion. They recognize exceptional talent and willingly move them throughout the organization. Leaders develop leaders and take seriously their role in coaching others.\n\n**Key Points:**\n- Raise the performance bar\n- Recognize exceptional talent\n- Develop future leaders\n- Take coaching seriously\n\n*Tags: #TalentDevelopment #Hiring #Coaching #Leadership*\n\n---\n\n## 7. Insist on the Highest Standards\n\nLeaders have relentlessly high standards  many people may think these standards are unreasonably high. Leaders are continually raising the bar and drive their teams to deliver high-quality products, services, and processes.\n\n**Key Points:**\n- Maintain relentlessly high standards\n- Continuously raise the bar\n- Drive quality in everything\n- Don't compromise on excellence\n\n*Tags: #HighStandards #Excellence #Quality #RaisingTheBar*\n\n---\n\n## 8. Think Big\n\nThinking small is a self-fulfilling prophecy. Leaders create and communicate a bold direction that inspires results. They think differently and look around corners for ways to serve customers.\n\n**Key Points:**\n- Avoid thinking small\n- Create bold direction\n- Inspire through vision\n- Think differently\n\n*Tags: #BigThinking #Vision #Bold #Innovation*\n\n---\n\n## 9. Bias for Action\n\nSpeed matters in business. Many decisions and actions are reversible and do not need extensive study. We value calculated risk-taking.\n\n**Key Points:**\n- Speed matters\n- Many decisions are reversible\n- Avoid analysis paralysis\n- Take calculated risks\n\n*Tags: #BiasForAction #Speed #RiskTaking #Execution*\n\n---\n\n## 10. Frugality\n\nAccomplish more with less. Constraints breed resourcefulness, self-sufficiency, and invention. There are no extra points for growing headcount, budget size, or fixed expense.\n\n**Key Points:**\n- Do more with less\n- Embrace constraints\n- Be resourceful and self-sufficient\n- Focus on results, not resources\n\n*Tags: #Frugality #Resourcefulness #Efficiency #Constraints*\n\n---\n\n## 11. Earn Trust\n\nLeaders listen attentively, speak candidly, and treat others respectfully. They are vocally self-critical, even when doing so is awkward or embarrassing.\n\n**Key Points:**\n- Listen attentively\n- Speak candidly\n- Treat others respectfully\n- Be self-critical\n\n*Tags: #Trust #Respect #SelfCritical #Candor*\n\n---\n\n## 12. Dive Deep\n\nLeaders operate at all levels, stay connected to the details, audit frequently, and are skeptical when metrics and anecdotes differ. No task is beneath them.\n\n**Key Points:**\n- Stay connected to details\n- Operate at all levels\n- Audit frequently\n- Be skeptical of inconsistencies\n\n*Tags: #DiveDeep #Details #Skeptical #HandsOn*\n\n---\n\n## 13. Have Backbone; Disagree and Commit\n\nLeaders are obligated to respectfully challenge decisions when they disagree, even when doing so is uncomfortable or exhausting. Once a decision is determined, they commit wholly.\n\n**Key Points:**\n- Challenge decisions respectfully\n- Speak up when you disagree\n- Commit fully once decided\n- Show courage in disagreement\n\n*Tags: #Backbone #DisagreeAndCommit #Courage #Commitment*\n\n---\n\n## 14. Deliver Results\n\nLeaders focus on the key inputs for their business and deliver them with the right quality and in a timely fashion. Despite setbacks, they rise to the occasion and never settle.\n\n**Key Points:**\n- Focus on key inputs\n- Deliver with quality and timeliness\n- Rise to the occasion\n- Never settle\n\n*Tags: #DeliverResults #Quality #Timeliness #Resilience*\n\n---\n\n## 15. Strive to be Earth's Best Employer\n\nLeaders work every day to create a safer, more productive, higher performing, more diverse, and more just work environment. They lead with empathy, have fun at work, and make it easy for others to have fun.\n\n**Key Points:**\n- Create safe and productive environment\n- Foster diversity and inclusion\n- Lead with empathy\n- Make work enjoyable\n\n*Tags: #BestEmployer #Empathy #Diversity #WorkEnvironment*\n\n---\n\n## 16. Success and Scale Bring Broad Responsibility\n\nWe started in a garage, but we're not there anymore. We are big, we impact the world, and we are far from perfect. We must be humble and thoughtful about even the secondary effects of our actions.\n\n**Key Points:**\n- Acknowledge scale and impact\n- Consider secondary effects\n- Stay humble\n- Think about broader responsibility\n\n*Tags: #Responsibility #Scale #Humility #Impact*\n\n---\n\n## Interview Tips\n\nWhen preparing for Amazon interviews, remember:\n\n1. **Use the STAR method** (Situation, Task, Action, Result) for behavioral questions\n2. **Be specific** with examples that demonstrate these principles\n3. **Show ownership** in your stories\n4. **Demonstrate customer focus** in your examples\n5. **Highlight learning and growth** from failures\n6. **Quantify results** whenever possible\n\n*Tags: #InterviewTips #STAR #Behavioral #Preparation*\n",
      "body": "# Amazon Leadership Principles\n\nAmazon's Leadership Principles are the foundation of their culture and guide how Amazonians make decisions, solve problems, and interact with customers and colleagues.\n\n---\n\n## 1. Customer Obsession\n\nLeaders start with the customer and work backwards. They work vigorously to earn and keep customer trust. Although leaders pay attention to competitors, they obsess over customers.\n\n**Key Points:**\n- Start with customer needs\n- Work backwards from customer experience\n- Earn and maintain customer trust\n- Focus on customers over competitors\n\n*Tags: #CustomerObsession #CustomerFirst #Trust*\n\n---\n\n## 2. Ownership\n\nLeaders are owners. They think long term and don't sacrifice long-term value for short-term results. They act on behalf of the entire company, beyond just their own team. They never say \"that's not my job.\"\n\n**Key Points:**\n- Think long-term\n- Act for the entire company\n- Take responsibility beyond your role\n- Avoid short-term thinking\n\n*Tags: #Ownership #LongTerm #Responsibility #Accountability*\n\n---\n\n## 3. Invent and Simplify\n\nLeaders expect and require innovation and invention from their teams and always find ways to simplify. They are externally aware, look for new ideas from everywhere, and are not limited by \"not invented here.\" As we do new things, we accept that we may be misunderstood for long periods of time.\n\n**Key Points:**\n- Drive innovation and invention\n- Simplify complex problems\n- Be externally aware\n- Accept being misunderstood\n\n*Tags: #Innovation #Simplification #Invention #ExternalAwareness*\n\n---\n\n## 4. Are Right, A Lot\n\nLeaders are right a lot. They have strong judgment and good instincts. They seek diverse perspectives and work to disconfirm their beliefs.\n\n**Key Points:**\n- Demonstrate strong judgment\n- Develop good instincts\n- Seek diverse perspectives\n- Challenge your own beliefs\n\n*Tags: #Judgment #DecisionMaking #DiversePerspectives #SelfChallenge*\n\n---\n\n## 5. Learn and Be Curious\n\nLeaders are never done learning and always seek to improve themselves. They are curious about new possibilities and act to explore them.\n\n**Key Points:**\n- Continuous learning mindset\n- Self-improvement focus\n- Curiosity about possibilities\n- Take action to explore\n\n*Tags: #ContinuousLearning #Curiosity #SelfImprovement #Growth*\n\n---\n\n## 6. Hire and Develop the Best\n\nLeaders raise the performance bar with every hire and promotion. They recognize exceptional talent and willingly move them throughout the organization. Leaders develop leaders and take seriously their role in coaching others.\n\n**Key Points:**\n- Raise the performance bar\n- Recognize exceptional talent\n- Develop future leaders\n- Take coaching seriously\n\n*Tags: #TalentDevelopment #Hiring #Coaching #Leadership*\n\n---\n\n## 7. Insist on the Highest Standards\n\nLeaders have relentlessly high standards  many people may think these standards are unreasonably high. Leaders are continually raising the bar and drive their teams to deliver high-quality products, services, and processes.\n\n**Key Points:**\n- Maintain relentlessly high standards\n- Continuously raise the bar\n- Drive quality in everything\n- Don't compromise on excellence\n\n*Tags: #HighStandards #Excellence #Quality #RaisingTheBar*\n\n---\n\n## 8. Think Big\n\nThinking small is a self-fulfilling prophecy. Leaders create and communicate a bold direction that inspires results. They think differently and look around corners for ways to serve customers.\n\n**Key Points:**\n- Avoid thinking small\n- Create bold direction\n- Inspire through vision\n- Think differently\n\n*Tags: #BigThinking #Vision #Bold #Innovation*\n\n---\n\n## 9. Bias for Action\n\nSpeed matters in business. Many decisions and actions are reversible and do not need extensive study. We value calculated risk-taking.\n\n**Key Points:**\n- Speed matters\n- Many decisions are reversible\n- Avoid analysis paralysis\n- Take calculated risks\n\n*Tags: #BiasForAction #Speed #RiskTaking #Execution*\n\n---\n\n## 10. Frugality\n\nAccomplish more with less. Constraints breed resourcefulness, self-sufficiency, and invention. There are no extra points for growing headcount, budget size, or fixed expense.\n\n**Key Points:**\n- Do more with less\n- Embrace constraints\n- Be resourceful and self-sufficient\n- Focus on results, not resources\n\n*Tags: #Frugality #Resourcefulness #Efficiency #Constraints*\n\n---\n\n## 11. Earn Trust\n\nLeaders listen attentively, speak candidly, and treat others respectfully. They are vocally self-critical, even when doing so is awkward or embarrassing.\n\n**Key Points:**\n- Listen attentively\n- Speak candidly\n- Treat others respectfully\n- Be self-critical\n\n*Tags: #Trust #Respect #SelfCritical #Candor*\n\n---\n\n## 12. Dive Deep\n\nLeaders operate at all levels, stay connected to the details, audit frequently, and are skeptical when metrics and anecdotes differ. No task is beneath them.\n\n**Key Points:**\n- Stay connected to details\n- Operate at all levels\n- Audit frequently\n- Be skeptical of inconsistencies\n\n*Tags: #DiveDeep #Details #Skeptical #HandsOn*\n\n---\n\n## 13. Have Backbone; Disagree and Commit\n\nLeaders are obligated to respectfully challenge decisions when they disagree, even when doing so is uncomfortable or exhausting. Once a decision is determined, they commit wholly.\n\n**Key Points:**\n- Challenge decisions respectfully\n- Speak up when you disagree\n- Commit fully once decided\n- Show courage in disagreement\n\n*Tags: #Backbone #DisagreeAndCommit #Courage #Commitment*\n\n---\n\n## 14. Deliver Results\n\nLeaders focus on the key inputs for their business and deliver them with the right quality and in a timely fashion. Despite setbacks, they rise to the occasion and never settle.\n\n**Key Points:**\n- Focus on key inputs\n- Deliver with quality and timeliness\n- Rise to the occasion\n- Never settle\n\n*Tags: #DeliverResults #Quality #Timeliness #Resilience*\n\n---\n\n## 15. Strive to be Earth's Best Employer\n\nLeaders work every day to create a safer, more productive, higher performing, more diverse, and more just work environment. They lead with empathy, have fun at work, and make it easy for others to have fun.\n\n**Key Points:**\n- Create safe and productive environment\n- Foster diversity and inclusion\n- Lead with empathy\n- Make work enjoyable\n\n*Tags: #BestEmployer #Empathy #Diversity #WorkEnvironment*\n\n---\n\n## 16. Success and Scale Bring Broad Responsibility\n\nWe started in a garage, but we're not there anymore. We are big, we impact the world, and we are far from perfect. We must be humble and thoughtful about even the secondary effects of our actions.\n\n**Key Points:**\n- Acknowledge scale and impact\n- Consider secondary effects\n- Stay humble\n- Think about broader responsibility\n\n*Tags: #Responsibility #Scale #Humility #Impact*\n\n---\n\n## Interview Tips\n\nWhen preparing for Amazon interviews, remember:\n\n1. **Use the STAR method** (Situation, Task, Action, Result) for behavioral questions\n2. **Be specific** with examples that demonstrate these principles\n3. **Show ownership** in your stories\n4. **Demonstrate customer focus** in your examples\n5. **Highlight learning and growth** from failures\n6. **Quantify results** whenever possible\n\n*Tags: #InterviewTips #STAR #Behavioral #Preparation*\n",
      "solutions": {}
    },
    "atlassian-values": {
      "id": "atlassian-values",
      "title": "Atlassian Values",
      "difficulty": "medium",
      "companies": [
        "atlassian"
      ],
      "topics": [
        "values",
        "culture",
        "teamwork",
        "behavioral"
      ],
      "langs": [],
      "content": "---\nlayout: post\ntitle: Atlassian Values\ndescription: Atlassian's core values define who they are as a company and guide how they work together, make decisions, and treat customers and each other.\ntopics: [values, culture, teamwork, behavioral]\ncompanies: [atlassian]\ndifficulty: medium\ntags: [Atlassian, Values, Culture, Interview, Behavioral, TeamWork]\n---\n\n# Atlassian Values\n\nAtlassian's core values define who they are as a company and guide how they work together, make decisions, and treat customers and each other.\n\n---\n\n## 1. Open Company, No Bullshit\n\nOpenness is root level for us. Information is open internally by default and sharing is a first principle. We understand that speaking your mind requires equal parts brains, thoughtfulness, and caring.\n\n**What this means:**\n- Default to transparency\n- Share information openly\n- Speak your mind thoughtfully\n- Be honest and direct\n- No hidden agendas\n\n**In practice:**\n- Share knowledge freely across teams\n- Give honest feedback\n- Admit when you don't know something\n- Challenge ideas constructively\n- Be transparent about mistakes\n\n*Tags: #Openness #Transparency #Honesty #DirectCommunication #Sharing*\n\n---\n\n## 2. Build with Heart and Balance\n\nPassion and urgency infuse everything we do, alongside the wisdom to consider options fully and with care. Then we make the cut, and we get to work.\n\n**What this means:**\n- Bring passion to your work\n- Balance urgency with thoughtfulness\n- Consider all options carefully\n- Make decisive cuts when needed\n- Execute with commitment\n\n**In practice:**\n- Show enthusiasm for your projects\n- Think through decisions thoroughly\n- Don't let perfectionism paralyze action\n- Prioritize ruthlessly\n- Commit fully once decisions are made\n\n*Tags: #Passion #Balance #Thoughtfulness #DecisionMaking #Execution*\n\n---\n\n## 3. Don't #@!% the Customer\n\nCustomers are our lifeblood. Without happy customers, we're doomed. So considering the customer perspectivecollectively, not just a handfulcomes first.\n\n**What this means:**\n- Put customers first in all decisions\n- Consider the broader customer base\n- Understand customer pain points\n- Deliver value to customers\n- Build trust through reliability\n\n**In practice:**\n- Ask \"How does this help our customers?\"\n- Listen to customer feedback\n- Test solutions with real users\n- Fix customer issues quickly\n- Build products customers love\n\n*Tags: #CustomerFirst #CustomerFocus #Value #Trust #UserExperience*\n\n---\n\n## 4. Play, as a Team\n\nWe spend a huge amount of our time at work. So the more that time doesn't feel like \"work,\" the better. We can be serious, without taking ourselves too seriously. We strive to put what's right for the team first.\n\n**What this means:**\n- Make work enjoyable\n- Don't take yourself too seriously\n- Prioritize team success over individual glory\n- Support your teammates\n- Create a positive work environment\n\n**In practice:**\n- Help teammates when they're struggling\n- Celebrate team wins together\n- Share credit generously\n- Have fun while working hard\n- Build strong relationships\n\n*Tags: #TeamWork #Collaboration #Fun #Support #TeamFirst*\n\n---\n\n## 5. Be the Change You Seek\n\nAll Atlassians should have the courage and resourcefulness to spark changeto make better our products, our people, our place. Continuous improvement is a shared responsibility. Action is an independent one.\n\n**What this means:**\n- Take initiative to drive change\n- Don't wait for permission to improve things\n- Be resourceful in finding solutions\n- Own continuous improvement\n- Act independently when needed\n\n**In practice:**\n- Identify problems and propose solutions\n- Experiment with new approaches\n- Learn from failures and iterate\n- Take ownership of improvements\n- Lead by example\n\n*Tags: #Initiative #Change #ContinuousImprovement #Ownership #Leadership*\n\n---\n\n## How Atlassian Values Show Up in Interviews\n\n### Common Behavioral Questions\n\n1. **Open Company, No Bullshit**\n   - \"Tell me about a time you had to give difficult feedback\"\n   - \"Describe a situation where transparency was important\"\n\n2. **Build with Heart and Balance**\n   - \"How do you balance speed and quality?\"\n   - \"Tell me about a time you were passionate about a project\"\n\n3. **Don't #@!% the Customer**\n   - \"Describe a time you advocated for a customer\"\n   - \"How do you prioritize customer needs?\"\n\n4. **Play, as a Team**\n   - \"Tell me about a time you put team success before personal recognition\"\n   - \"How do you handle conflict within a team?\"\n\n5. **Be the Change You Seek**\n   - \"Describe a time you initiated a significant change\"\n   - \"Tell me about a process you improved\"\n\n### Interview Tips\n\n**Preparation:**\n- Research Atlassian's products and mission\n- Prepare STAR method examples for each value\n- Think about times you've lived these values\n- Consider examples from different contexts (work, school, personal)\n\n**During the Interview:**\n- Be authentic and genuine\n- Show enthusiasm for collaboration\n- Demonstrate customer empathy\n- Highlight your growth mindset\n- Ask thoughtful questions about team culture\n\n**What Atlassian Looks For:**\n- Collaborative mindset\n- Customer empathy\n- Growth orientation\n- Transparency and honesty\n- Initiative and ownership\n\n*Tags: #InterviewTips #Behavioral #STAR #Preparation #Culture*\n\n---\n\n## Living the Values Daily\n\n### For Individual Contributors\n- Share knowledge proactively\n- Seek feedback regularly\n- Put customer needs first\n- Collaborate effectively\n- Drive improvements\n\n### For Leaders\n- Model transparency\n- Make thoughtful decisions\n- Champion customer voice\n- Build strong teams\n- Enable change\n\n### For Teams\n- Create psychological safety\n- Focus on customer outcomes\n- Balance individual and team goals\n- Embrace experimentation\n- Celebrate learning from failures\n\n*Tags: #DailyPractice #Leadership #Teams #Growth #Culture*\n\n---\n\n## Key Differentiators\n\nAtlassian's values emphasize:\n\n1. **Transparency over Politics** - Open communication and information sharing\n2. **Team Success over Individual Glory** - Collective achievement matters most\n3. **Customer Obsession** - Similar to Amazon but with Atlassian's unique flavor\n4. **Fun and Balance** - Work should be enjoyable, not just productive\n5. **Proactive Change** - Don't wait for permission to make things better\n\n*Tags: #Differentiators #Culture #Philosophy #WorkStyle #Values*\n",
      "body": "# Atlassian Values\n\nAtlassian's core values define who they are as a company and guide how they work together, make decisions, and treat customers and each other.\n\n---\n\n## 1. Open Company, No Bullshit\n\nOpenness is root level for us. Information is open internally by default and sharing is a first principle. We understand that speaking your mind requires equal parts brains, thoughtfulness, and caring.\n\n**What this means:**\n- Default to transparency\n- Share information openly\n- Speak your mind thoughtfully\n- Be honest and direct\n- No hidden agendas\n\n**In practice:**\n- Share knowledge freely across teams\n- Give honest feedback\n- Admit when you don't know something\n- Challenge ideas constructively\n- Be transparent about mistakes\n\n*Tags: #Openness #Transparency #Honesty #DirectCommunication #Sharing*\n\n---\n\n## 2. Build with Heart and Balance\n\nPassion and urgency infuse everything we do, alongside the wisdom to consider options fully and with care. Then we make the cut, and we get to work.\n\n**What this means:**\n- Bring passion to your work\n- Balance urgency with thoughtfulness\n- Consider all options carefully\n- Make decisive cuts when needed\n- Execute with commitment\n\n**In practice:**\n- Show enthusiasm for your projects\n- Think through decisions thoroughly\n- Don't let perfectionism paralyze action\n- Prioritize ruthlessly\n- Commit fully once decisions are made\n\n*Tags: #Passion #Balance #Thoughtfulness #DecisionMaking #Execution*\n\n---\n\n## 3. Don't #@!% the Customer\n\nCustomers are our lifeblood. Without happy customers, we're doomed. So considering the customer perspectivecollectively, not just a handfulcomes first.\n\n**What this means:**\n- Put customers first in all decisions\n- Consider the broader customer base\n- Understand customer pain points\n- Deliver value to customers\n- Build trust through reliability\n\n**In practice:**\n- Ask \"How does this help our customers?\"\n- Listen to customer feedback\n- Test solutions with real users\n- Fix customer issues quickly\n- Build products customers love\n\n*Tags: #CustomerFirst #CustomerFocus #Value #Trust #UserExperience*\n\n---\n\n## 4. Play, as a Team\n\nWe spend a huge amount of our time at work. So the more that time doesn't feel like \"work,\" the better. We can be serious, without taking ourselves too seriously. We strive to put what's right for the team first.\n\n**What this means:**\n- Make work enjoyable\n- Don't take yourself too seriously\n- Prioritize team success over individual glory\n- Support your teammates\n- Create a positive work environment\n\n**In practice:**\n- Help teammates when they're struggling\n- Celebrate team wins together\n- Share credit generously\n- Have fun while working hard\n- Build strong relationships\n\n*Tags: #TeamWork #Collaboration #Fun #Support #TeamFirst*\n\n---\n\n## 5. Be the Change You Seek\n\nAll Atlassians should have the courage and resourcefulness to spark changeto make better our products, our people, our place. Continuous improvement is a shared responsibility. Action is an independent one.\n\n**What this means:**\n- Take initiative to drive change\n- Don't wait for permission to improve things\n- Be resourceful in finding solutions\n- Own continuous improvement\n- Act independently when needed\n\n**In practice:**\n- Identify problems and propose solutions\n- Experiment with new approaches\n- Learn from failures and iterate\n- Take ownership of improvements\n- Lead by example\n\n*Tags: #Initiative #Change #ContinuousImprovement #Ownership #Leadership*\n\n---\n\n## How Atlassian Values Show Up in Interviews\n\n### Common Behavioral Questions\n\n1. **Open Company, No Bullshit**\n   - \"Tell me about a time you had to give difficult feedback\"\n   - \"Describe a situation where transparency was important\"\n\n2. **Build with Heart and Balance**\n   - \"How do you balance speed and quality?\"\n   - \"Tell me about a time you were passionate about a project\"\n\n3. **Don't #@!% the Customer**\n   - \"Describe a time you advocated for a customer\"\n   - \"How do you prioritize customer needs?\"\n\n4. **Play, as a Team**\n   - \"Tell me about a time you put team success before personal recognition\"\n   - \"How do you handle conflict within a team?\"\n\n5. **Be the Change You Seek**\n   - \"Describe a time you initiated a significant change\"\n   - \"Tell me about a process you improved\"\n\n### Interview Tips\n\n**Preparation:**\n- Research Atlassian's products and mission\n- Prepare STAR method examples for each value\n- Think about times you've lived these values\n- Consider examples from different contexts (work, school, personal)\n\n**During the Interview:**\n- Be authentic and genuine\n- Show enthusiasm for collaboration\n- Demonstrate customer empathy\n- Highlight your growth mindset\n- Ask thoughtful questions about team culture\n\n**What Atlassian Looks For:**\n- Collaborative mindset\n- Customer empathy\n- Growth orientation\n- Transparency and honesty\n- Initiative and ownership\n\n*Tags: #InterviewTips #Behavioral #STAR #Preparation #Culture*\n\n---\n\n## Living the Values Daily\n\n### For Individual Contributors\n- Share knowledge proactively\n- Seek feedback regularly\n- Put customer needs first\n- Collaborate effectively\n- Drive improvements\n\n### For Leaders\n- Model transparency\n- Make thoughtful decisions\n- Champion customer voice\n- Build strong teams\n- Enable change\n\n### For Teams\n- Create psychological safety\n- Focus on customer outcomes\n- Balance individual and team goals\n- Embrace experimentation\n- Celebrate learning from failures\n\n*Tags: #DailyPractice #Leadership #Teams #Growth #Culture*\n\n---\n\n## Key Differentiators\n\nAtlassian's values emphasize:\n\n1. **Transparency over Politics** - Open communication and information sharing\n2. **Team Success over Individual Glory** - Collective achievement matters most\n3. **Customer Obsession** - Similar to Amazon but with Atlassian's unique flavor\n4. **Fun and Balance** - Work should be enjoyable, not just productive\n5. **Proactive Change** - Don't wait for permission to make things better\n\n*Tags: #Differentiators #Culture #Philosophy #WorkStyle #Values*\n",
      "solutions": {}
    }
  }
}