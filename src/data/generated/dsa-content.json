{
  "alien-dictionary": {
    "id": "alien-dictionary",
    "title": "Alien Dictionary",
    "difficulty": "hard",
    "companies": [
      "airbnb",
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "google",
      "microsoft",
      "oracle",
      "pinterest",
      "snapchat",
      "twitter",
      "uber",
      "vmware"
    ],
    "topics": [
      "string",
      "topological-sort",
      "graph"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "alien-dictionary",
    "gfg": "given-sorted-dictionary-find-precedence-characters",
    "leetid": 269,
    "content": "---\nlayout: post\ntitle: Alien Dictionary\ntopics: [string, topological-sort, graph]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(1)\nleetid: 269\ncompanies: [airbnb, amazon, apple, bloomberg, facebook, google, microsoft, oracle, pinterest, snapchat, twitter, uber, vmware]\ninterviewbit:\ndifficulty: hard\ngfg: given-sorted-dictionary-find-precedence-characters\nhackerrank: \nleetcode: alien-dictionary\n---\n\nThere is a new alien language which uses the latin alphabet. \nHowever, the order among letters are unknown to you. \nYou receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. \nDerive the order of letters in this language.\n\nNote:\n1. You may assume all letters are in lowercase.\n2. You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\n3. If the order is invalid, return an empty string.\n4. There may be multiple valid order of letters, return any one of them is fine.\n\n---\n## Test Cases\n**Examples 1:**\n```\nInput:\n[\n  \"wrt\",\n  \"wrf\",\n  \"er\",\n  \"ett\",\n  \"rftt\"\n]\n\nOutput: \"wertf\"\n```\n\n**Examples 2:**\n```\nInput:\n[\n  \"z\",\n  \"x\"\n]\nOutput: \"zx\"\n```\n\n**Examples 3:**\n```\nInput:\n[\n  \"z\",\n  \"x\",\n  \"z\"\n]\nOutput: \"\"\nExplanation: The order is invalid, so return \"\".\n```\n\n**Constraints:**\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 100`\n* `words[i] consists of only lowercase English letters.`",
    "body": "There is a new alien language which uses the latin alphabet. \nHowever, the order among letters are unknown to you. \nYou receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. \nDerive the order of letters in this language.\n\nNote:\n1. You may assume all letters are in lowercase.\n2. You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\n3. If the order is invalid, return an empty string.\n4. There may be multiple valid order of letters, return any one of them is fine.\n\n---\n## Test Cases\n**Examples 1:**\n```\nInput:\n[\n  \"wrt\",\n  \"wrf\",\n  \"er\",\n  \"ett\",\n  \"rftt\"\n]\n\nOutput: \"wertf\"\n```\n\n**Examples 2:**\n```\nInput:\n[\n  \"z\",\n  \"x\"\n]\nOutput: \"zx\"\n```\n\n**Examples 3:**\n```\nInput:\n[\n  \"z\",\n  \"x\",\n  \"z\"\n]\nOutput: \"\"\nExplanation: The order is invalid, so return \"\".\n```\n\n**Constraints:**\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 100`\n* `words[i] consists of only lowercase English letters.`",
    "solutions": {}
  },
  "basic-calculator-ii": {
    "id": "basic-calculator-ii",
    "title": "Basic Calculator II",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "math",
      "string",
      "stack"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "basic-calculator-ii",
    "gfg": null,
    "leetid": 227,
    "content": "---\nlayout: post\ntitle: Basic Calculator II\ntopics: [math, string, stack]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 227\ncompanies: [facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: basic-calculator-ii\n---\nGiven a string `s` which represents an expression, *evaluate this expression and return its value*. \nThe integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-2<sup>31</sup>, 2<sup>31</sup> - 1]`.\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"3+2*2\"\nOutput: 7\n```\n**Example 2:**\n```\nInput: s = \" 3/2 \"\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: s = \" 3+5 / 2 \"\nOutput: 5\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 3 * 10<sup>5</sup>`\n* `s` consists of integers and operators `('+', '-', '*', '/')` separated by some number of spaces.\n* `s` represents **a valid expression**.\n* All the integers in the expression are non-negative integers in the range `[0, 2<sup>31</sup> - 1]`.\n* The answer is **guaranteed** to fit in a **32-bit integer**.\n\n        ",
    "body": "Given a string `s` which represents an expression, *evaluate this expression and return its value*. \nThe integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-2<sup>31</sup>, 2<sup>31</sup> - 1]`.\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"3+2*2\"\nOutput: 7\n```\n**Example 2:**\n```\nInput: s = \" 3/2 \"\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: s = \" 3+5 / 2 \"\nOutput: 5\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 3 * 10<sup>5</sup>`\n* `s` consists of integers and operators `('+', '-', '*', '/')` separated by some number of spaces.\n* `s` represents **a valid expression**.\n* All the integers in the expression are non-negative integers in the range `[0, 2<sup>31</sup> - 1]`.\n* The answer is **guaranteed** to fit in a **32-bit integer**.\n\n        ",
    "solutions": {}
  },
  "basic-calculator": {
    "id": "basic-calculator",
    "title": "Basic Calculator",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "math",
      "string",
      "stack",
      "recursion"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "basic-calculator",
    "gfg": null,
    "leetid": 224,
    "content": "---\nlayout: post\ntitle: Basic Calculator\ntopics: [math, string, stack, recursion]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(n)\nleetid: 224\ncompanies: \ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: basic-calculator\n---\nGiven a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return *the result of the evaluation*.\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"1 + 1\"\nOutput: 2\n```\n**Example 2:**\n```\nInput: s = \" 2-1 + 2 \"\nOutput: 3\n```\n**Example 3:**\n```\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 3 * 10<sup>5</sup>`\n\t\n* `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.\n\t\n* `s` represents a valid expression.\n\t\n* `'+'` is **not** used as a unary operation (i.e., `\"+1\"` and `\"+(2 + 3)\"` is invalid).\n\t\n* `'-'` could be used as a unary operation (i.e., `\"-1\"` and `\"-(2 + 3)\"` is valid).\n\t\n* There will be no two consecutive operators in the input.\n\t\n* Every number and running calculation will fit in a signed 32-bit integer.\n\n        ",
    "body": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return *the result of the evaluation*.\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"1 + 1\"\nOutput: 2\n```\n**Example 2:**\n```\nInput: s = \" 2-1 + 2 \"\nOutput: 3\n```\n**Example 3:**\n```\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 3 * 10<sup>5</sup>`\n\t\n* `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.\n\t\n* `s` represents a valid expression.\n\t\n* `'+'` is **not** used as a unary operation (i.e., `\"+1\"` and `\"+(2 + 3)\"` is invalid).\n\t\n* `'-'` could be used as a unary operation (i.e., `\"-1\"` and `\"-(2 + 3)\"` is valid).\n\t\n* There will be no two consecutive operators in the input.\n\t\n* Every number and running calculation will fit in a signed 32-bit integer.\n\n        ",
    "solutions": {}
  },
  "best-time-to-buy-and-sell-stock-ii": {
    "id": "best-time-to-buy-and-sell-stock-ii",
    "title": "Best Time to Buy and Sell Stock II",
    "difficulty": "medium",
    "companies": [
      "facebook",
      "amazon"
    ],
    "topics": [
      "array",
      "dynamic-programming",
      "greedy"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "best-time-to-buy-and-sell-stock-ii",
    "gfg": null,
    "leetid": 122,
    "content": "---\nlayout: post\ntitle: Best Time to Buy and Sell Stock II\ntopics: [array, dynamic-programming, greedy]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\nleetid: 122\ncompanies: [facebook, amazon]\ninterviewbit: best-time-to-buy-and-sell-stocks-ii\ndifficulty: medium\ngfg: \nhackerrank: \nleetcode: best-time-to-buy-and-sell-stock-ii\n---\nYou are given an integer array `prices` where `prices[i]` is the price of a given stock on the `i<sup>th</sup>` day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\nFind and return *the **maximum** profit you can achieve*.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n```\n**Example 2:**\n```\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n```\n\n**Example 3:**\n\n```\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n```\n\n**Constraints:**\n\n* `1 <= prices.length <= 3 * 10<sup>4</sup>`\n\n* `0 <= prices[i] <= 10<sup>4</sup>`\n",
    "body": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `i<sup>th</sup>` day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\nFind and return *the **maximum** profit you can achieve*.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n```\n**Example 2:**\n```\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n```\n\n**Example 3:**\n\n```\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n```\n\n**Constraints:**\n\n* `1 <= prices.length <= 3 * 10<sup>4</sup>`\n\n* `0 <= prices[i] <= 10<sup>4</sup>`\n",
    "solutions": {}
  },
  "best-time-to-buy-and-sell-stock-iii": {
    "id": "best-time-to-buy-and-sell-stock-iii",
    "title": "Best Time to Buy and Sell Stock III",
    "difficulty": "hard",
    "companies": [
      "facebook",
      "amazon"
    ],
    "topics": [
      "array",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "cpp",
      "py",
      "c"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "best-time-to-buy-and-sell-stock-iii",
    "gfg": null,
    "leetid": 123,
    "content": "---\nlayout: post\ntitle: Best Time to Buy and Sell Stock III\ntopics: [array, dynamic-programming]\nlangs: [java, cpp, py, c]\ntc: O(n)\nsc: O(1)\nleetid: 123\ncompanies: [facebook, amazon]\ninterviewbit: best-time-to-buy-and-sell-stocks-iii\ndifficulty: hard\ngfg: \nhackerrank: \nleetcode: best-time-to-buy-and-sell-stock-iii\n---\n\nYou are given an array prices where `prices[i]` is the price of a given stock on the i<sup>th</sup> day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously \n(i.e., you must sell the stock before you buy again).\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) prices = [3,3,5,0,0,3,1,4]\n```\n\n**Output:**\n```\n(int) 6\n```\n\n**Explanation:**\n```\nBuy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n```\n\n---\n\n**Input:**\n```\n(int[]) prices = [1,2,3,4,5]\n```\n\n**Output:**\n```\n(int) 4\n```\n\n**Explanation:**\n```\nBuy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, \nas you are engaging multiple transactions at the same time. You must sell before buying again.\n```\n\n---\n\n**Input:**\n```\n(int[]) prices = [7,6,4,3,1]\n```\n\n**Output:**\n```\n(int) 0\n```\n\n**Explanation:**\n```\nIn this case, no transaction is done, i.e. max profit = 0.\n```",
    "body": "You are given an array prices where `prices[i]` is the price of a given stock on the i<sup>th</sup> day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously \n(i.e., you must sell the stock before you buy again).\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) prices = [3,3,5,0,0,3,1,4]\n```\n\n**Output:**\n```\n(int) 6\n```\n\n**Explanation:**\n```\nBuy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n```\n\n---\n\n**Input:**\n```\n(int[]) prices = [1,2,3,4,5]\n```\n\n**Output:**\n```\n(int) 4\n```\n\n**Explanation:**\n```\nBuy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, \nas you are engaging multiple transactions at the same time. You must sell before buying again.\n```\n\n---\n\n**Input:**\n```\n(int[]) prices = [7,6,4,3,1]\n```\n\n**Output:**\n```\n(int) 0\n```\n\n**Explanation:**\n```\nIn this case, no transaction is done, i.e. max profit = 0.\n```",
    "solutions": {}
  },
  "binary-search-tree-iterator": {
    "id": "binary-search-tree-iterator",
    "title": "Binary Search Tree Iterator",
    "difficulty": "medium",
    "companies": [
      "facebook",
      "google",
      "linkedin",
      "apple",
      "amazon"
    ],
    "topics": [
      "stack",
      "tree",
      "design",
      "binary-search-tree",
      "binary-tree",
      "iterator"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "binary-search-tree-iterator",
    "gfg": null,
    "leetid": 173,
    "content": "---\nlayout: post\ntitle: Binary Search Tree Iterator\ndifficulty: medium\ntopics: [stack, tree, design, binary-search-tree, binary-tree, iterator]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(n)\ncompanies: [facebook, google, linkedin, apple, amazon]\nleetid: 173\nleetcode: binary-search-tree-iterator\ngfg: \ninterviewbit: bst-iterator\nhackerrank: \n---\nImplement the `BSTIterator` class that represents an iterator over the **<a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a>** of a binary search tree (BST):\n\t\n* `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n\t\n* `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.\n\t\n* `int next()` Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.\nYou may assume that `next()` calls will always be valid. That is, there will be at least a next number in the in-order traversal when `next()` is called.\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style={{width: '189px', height: '178px'}} />\n```\n**Input**\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n**Output**\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n**Explanation**\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[1, 10<sup>5</sup>]`.\n\t\n* `0 <= Node.val <= 10<sup>6</sup>`\n\t\n* At most `10<sup>5</sup>` calls will be made to `hasNext`, and `next`.\n \n**Follow up:**\n\t\n* Could you implement `next()` and `hasNext()` to run in average `O(1)` time and use `O(h)` memory, where `h` is the height of the tree?\n\n",
    "body": "Implement the `BSTIterator` class that represents an iterator over the **<a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a>** of a binary search tree (BST):\n\t\n* `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n\t\n* `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.\n\t\n* `int next()` Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.\nYou may assume that `next()` calls will always be valid. That is, there will be at least a next number in the in-order traversal when `next()` is called.\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style={{width: '189px', height: '178px'}} />\n```\n**Input**\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n**Output**\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n**Explanation**\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[1, 10<sup>5</sup>]`.\n\t\n* `0 <= Node.val <= 10<sup>6</sup>`\n\t\n* At most `10<sup>5</sup>` calls will be made to `hasNext`, and `next`.\n \n**Follow up:**\n\t\n* Could you implement `next()` and `hasNext()` to run in average `O(1)` time and use `O(h)` memory, where `h` is the height of the tree?\n\n",
    "solutions": {}
  },
  "binary-tree-maximum-path-sum": {
    "id": "binary-tree-maximum-path-sum",
    "title": "Binary Tree Maximum Path Sum",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "binary-tree",
      "depth-first-search",
      "dynamic-programming",
      "tree"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "ts"
    ],
    "tc": "O(h)",
    "sc": "O(1)",
    "leetcode": "binary-tree-maximum-path-sum",
    "gfg": null,
    "leetid": 124,
    "content": "---\nlayout: post\ntitle: Binary Tree Maximum Path Sum\ntopics: [binary-tree, depth-first-search, dynamic-programming, tree]\nlangs: [java, py, cpp, ts]\ntc: O(h)\nsc: O(1)\nleetid: 124\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: binary-tree-maximum-path-sum\n---\n\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the root of a binary tree, return the maximum path sum of any **non-empty** path.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n  -10\n /   \\\n9     20\n     /  \\\n    15   7\n```\n\n**Example 2:** \n```\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n  1\n / \\ \n2   3\n```",
    "body": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the root of a binary tree, return the maximum path sum of any **non-empty** path.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n  -10\n /   \\\n9     20\n     /  \\\n    15   7\n```\n\n**Example 2:** \n```\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n  1\n / \\ \n2   3\n```",
    "solutions": {}
  },
  "binary-tree-zigzag-level-order-traversal": {
    "id": "binary-tree-zigzag-level-order-traversal",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "binary-tree",
      "breadth-first-search",
      "tree"
    ],
    "langs": [
      "java",
      "js",
      "py",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "binary-tree-zigzag-level-order-traversal",
    "gfg": null,
    "leetid": 103,
    "content": "---\nlayout: post\ntitle: Binary Tree Zigzag Level Order Traversal\ntopics: [binary-tree, breadth-first-search, tree]\nlangs: [java, js, py, cpp]\ntc: O(n)\nsc: O(n)\nleetid: 103\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: binary-tree-zigzag-level-order-traversal\n---\n\nGiven the `root` of a binary tree, \nreturn the zigzag level order traversal of its nodes' values. \n(i.e., from left to right, then right to left for the next level and alternate between).\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(TreeNode) root = [3,9,20,null,null,15,7]\n```\n\n**Output:** \n```\n(int[]) [[3],[20,9],[15,7]]\n```\n\n**Explanation:**\n```\n    3\n   / \\\n  9   20\n     /  \\\n    15   7\n```",
    "body": "Given the `root` of a binary tree, \nreturn the zigzag level order traversal of its nodes' values. \n(i.e., from left to right, then right to left for the next level and alternate between).\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(TreeNode) root = [3,9,20,null,null,15,7]\n```\n\n**Output:** \n```\n(int[]) [[3],[20,9],[15,7]]\n```\n\n**Explanation:**\n```\n    3\n   / \\\n  9   20\n     /  \\\n    15   7\n```",
    "solutions": {}
  },
  "burning-tree": {
    "id": "burning-tree",
    "title": "Burning Tree",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "binary-tree",
      "breadth-first-search",
      "queue",
      "tree"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(2<sup>h</sup>)",
    "leetcode": null,
    "gfg": null,
    "content": "---\nlayout: post\ntitle: Burning Tree\ntopics: [binary-tree, breadth-first-search, queue, tree]\nlangs: [java]\ntc: O(n)\nsc: O(2<sup>h</sup>)\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven a binary tree and target node. By giving the fire to the target node and fire starts to spread in a complete tree. \nThe task is to print the total time to burn every node of the binary tree\n\nRules for burning the nodes :\n1. Fire will spread constantly to the connected nodes only.\n2. Every node takes the same time to burn.\n3. A node burns only once.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/binarytree.jpeg\" />\n\n**Input:**\n\n```\n(TreeNode)  root = [5,3,6,2,4,null,null,1]\n(int)       target = 4\n```\n\n**Output:**\n```\n(int) 4\n```\n\n**Explanation**\n```\nStep 1: burn 4\nStep 2: burn 3\nStep 3: burn 2, 5\nStep 4: burn 1, 6\n```\n\n---\n\n**Input:**\n\n```\n(TreeNode)  root = [5,3,6,2,4,null,null,1]\n(int)       target = 3\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation**\n```\nStep 1: burn 3\nStep 2: burn 2,4,5\nStep 3: burn 1, 6\n```",
    "body": "Given a binary tree and target node. By giving the fire to the target node and fire starts to spread in a complete tree. \nThe task is to print the total time to burn every node of the binary tree\n\nRules for burning the nodes :\n1. Fire will spread constantly to the connected nodes only.\n2. Every node takes the same time to burn.\n3. A node burns only once.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/binarytree.jpeg\" />\n\n**Input:**\n\n```\n(TreeNode)  root = [5,3,6,2,4,null,null,1]\n(int)       target = 4\n```\n\n**Output:**\n```\n(int) 4\n```\n\n**Explanation**\n```\nStep 1: burn 4\nStep 2: burn 3\nStep 3: burn 2, 5\nStep 4: burn 1, 6\n```\n\n---\n\n**Input:**\n\n```\n(TreeNode)  root = [5,3,6,2,4,null,null,1]\n(int)       target = 3\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation**\n```\nStep 1: burn 3\nStep 2: burn 2,4,5\nStep 3: burn 1, 6\n```",
    "solutions": {}
  },
  "cheapest-flights-within-k-stops": {
    "id": "cheapest-flights-within-k-stops",
    "title": "Cheapest Flights Within K Stops",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "breadth-first-search",
      "depth-first-search",
      "dynamic-programming",
      "graph"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n<sup>k</sup>)",
    "sc": "O(n<sup>2</sup>k)",
    "leetcode": "cheapest-flights-within-k-stops",
    "gfg": null,
    "leetid": 787,
    "content": "---\nlayout: post\ntitle: Cheapest Flights Within K Stops\ntopics: [breadth-first-search, depth-first-search, dynamic-programming, graph]\nlangs: [java, cpp]\ntc: O(n<sup>k</sup>)\nsc: O(n<sup>2</sup>k)\nleetid: 787\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: cheapest-flights-within-k-stops\n---\n\nThere are `n` cities connected by some number of flights. \nYou are given an array flights where `flights[i] = [from, to, price]` \nindicates that there is a flight from city from<sub>i</sub> to city to<sub>i</sub> with cost price<sub>i</sub>.\n\nYou are also given three integers `src`, `dst`, and `k`, \nreturn the cheapest price from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<MdxImage src=\"code/995.png\" />\n```\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation: The graph is shown.\nThe cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.\n```\n\n**Example 2:**\n\n<MdxImage src=\"code/995.png\" />\n\n```\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation: The graph is shown.\nThe cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.\n```",
    "body": "There are `n` cities connected by some number of flights. \nYou are given an array flights where `flights[i] = [from, to, price]` \nindicates that there is a flight from city from<sub>i</sub> to city to<sub>i</sub> with cost price<sub>i</sub>.\n\nYou are also given three integers `src`, `dst`, and `k`, \nreturn the cheapest price from `src` to `dst` with at most `k` stops. If there is no such route, return `-1`.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<MdxImage src=\"code/995.png\" />\n```\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation: The graph is shown.\nThe cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.\n```\n\n**Example 2:**\n\n<MdxImage src=\"code/995.png\" />\n\n```\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation: The graph is shown.\nThe cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.\n```",
    "solutions": {}
  },
  "cherry-pickup-ii": {
    "id": "cherry-pickup-ii",
    "title": "Cherry Pickup II",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming",
      "matrix"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(mn<sup>2</sup>)",
    "sc": "O(mn<sup>2</sup>)",
    "leetcode": "cherry-pickup-ii",
    "gfg": null,
    "leetid": 1559,
    "content": "---\nlayout: post\ntitle: Cherry Pickup II\ntopics: [array, dynamic-programming, matrix]\nlangs: [java]\ntc: O(mn<sup>2</sup>)\nsc: O(mn<sup>2</sup>)\nleetid: 1559\ncompanies: \ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: cherry-pickup-ii\n---\nYou are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.\nYou have two robots that can collect cherries for you:\n\t\n* **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n\t\n* **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\nReturn *the maximum number of cherries collection using both robots by following the rules below*:\n\t\n* From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.\n\t\n* When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n\t\n* When both robots stay in the same cell, only one takes the cherries.\n\t\n* Both robots cannot move outside of the grid at any moment.\n\t\n* Both robots should reach the bottom row in `grid`.\n \n---\n## Test Cases\n**Example 1:**\n\n<img src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png\" />\n\n```\nInput: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\nOutput: 24\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n```\n\n**Example 2:**\n\n<img src=\"https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png\" />\n\n```\nInput: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\nOutput: 28\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n```\n \n**Constraints:**\n\t\n* `rows == grid.length`\n\t\n* `cols == grid[i].length`\n\t\n* `2 <= rows, cols <= 70`\n\t\n* `0 <= grid[i][j] <= 100`\n\n        ",
    "body": "You are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.\nYou have two robots that can collect cherries for you:\n\t\n* **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n\t\n* **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\nReturn *the maximum number of cherries collection using both robots by following the rules below*:\n\t\n* From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.\n\t\n* When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n\t\n* When both robots stay in the same cell, only one takes the cherries.\n\t\n* Both robots cannot move outside of the grid at any moment.\n\t\n* Both robots should reach the bottom row in `grid`.\n \n---\n## Test Cases\n**Example 1:**\n\n<img src=\"https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png\" />\n\n```\nInput: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\nOutput: 24\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n```\n\n**Example 2:**\n\n<img src=\"https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png\" />\n\n```\nInput: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\nOutput: 28\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n```\n \n**Constraints:**\n\t\n* `rows == grid.length`\n\t\n* `cols == grid[i].length`\n\t\n* `2 <= rows, cols <= 70`\n\t\n* `0 <= grid[i][j] <= 100`\n\n        ",
    "solutions": {}
  },
  "clone-graph": {
    "id": "clone-graph",
    "title": "Clone Graph",
    "difficulty": "medium",
    "companies": [
      "google",
      "facebook",
      "amazon"
    ],
    "topics": [
      "depth-first-search",
      "graph",
      "hash-table"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "clone-graph",
    "gfg": null,
    "leetid": 133,
    "content": "---\nlayout: post\ntitle: Clone Graph\ntopics: [depth-first-search, graph, hash-table]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(n)\nleetid: 133\ndifficulty: medium\ncompanies: [google, facebook, amazon]\ngfg: \nhackerrank: \ninterviewbit: clone-graph\nleetcode: clone-graph\n---\n\nGiven a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (`List[Node]`) of its neighbors.\n```\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n```\n\nTest case format:\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). \nFor example, the first node with `val == 1`, the second node with `val == 2`, and so on. \nThe graph is represented in the test case using an adjacency list.\n\nAn adjacency list is a collection of unordered lists used to represent a finite graph. \nEach list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the copy of the given node as a reference to the cloned graph.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(Node) adjList = [[2,4],[1,3],[2,4],[1,3]]\n```\n\n**Output:**\n```\n(Node) [[2,4],[1,3],[2,4],[1,3]]\n```\n\n---\n\n**Input:**\n```\n(Node) adjList = [[]]\n```\n\n**Output:**\n```\n(Node) [[]]\n```\n\n---\n\n**Input:**\n```\n(Node) adjList = []\n```\n\n**Output:**\n```\n(Node) []\n```",
    "body": "Given a reference of a node in a connected undirected graph.\n\nReturn a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (`List[Node]`) of its neighbors.\n```\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n```\n\nTest case format:\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). \nFor example, the first node with `val == 1`, the second node with `val == 2`, and so on. \nThe graph is represented in the test case using an adjacency list.\n\nAn adjacency list is a collection of unordered lists used to represent a finite graph. \nEach list describes the set of neighbors of a node in the graph.\n\nThe given node will always be the first node with `val = 1`. You must return the copy of the given node as a reference to the cloned graph.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(Node) adjList = [[2,4],[1,3],[2,4],[1,3]]\n```\n\n**Output:**\n```\n(Node) [[2,4],[1,3],[2,4],[1,3]]\n```\n\n---\n\n**Input:**\n```\n(Node) adjList = [[]]\n```\n\n**Output:**\n```\n(Node) [[]]\n```\n\n---\n\n**Input:**\n```\n(Node) adjList = []\n```\n\n**Output:**\n```\n(Node) []\n```",
    "solutions": {}
  },
  "coin-change": {
    "id": "coin-change",
    "title": "Coin Change",
    "difficulty": "medium",
    "companies": [
      "amazon",
      "apple",
      "google",
      "microsoft",
      "adobe"
    ],
    "topics": [
      "array",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "c"
    ],
    "tc": "O(n*amount)",
    "sc": "O(amount)",
    "leetcode": "coin-change",
    "gfg": null,
    "leetid": 322,
    "content": "---\nlayout: post\ntitle: Coin Change\ntopics: [array, dynamic-programming]\nlangs: [java, py, cpp, c]\ntc: O(n*amount)\nsc: O(amount)\nleetid: 322\ncompanies: [amazon, apple, google, microsoft, adobe]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: coin-change\n---\n\nYou are given an integer array coins representing coins of different denominations and \nan integer `amount` representing a total amount of money.\n\nReturn the _fewest number of coins that you need to make up that amount_. \nIf that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) coins = [1,2,5]\n(int) amount = 11\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\n11 = 5 + 5 + 1\n```\n\n---\n\n**Input:**\n```\n(int[]) coins = [2]\n(int) amount = 3\n```\n\n**Output:**\n```\n(int) -1\n```\n\n---\n\n**Input:**\n```\n(int[]) coins = [1]\n(int) amount = 0\n```\n\n**Output:**\n```\n(int) 0\n```",
    "body": "You are given an integer array coins representing coins of different denominations and \nan integer `amount` representing a total amount of money.\n\nReturn the _fewest number of coins that you need to make up that amount_. \nIf that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) coins = [1,2,5]\n(int) amount = 11\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\n11 = 5 + 5 + 1\n```\n\n---\n\n**Input:**\n```\n(int[]) coins = [2]\n(int) amount = 3\n```\n\n**Output:**\n```\n(int) -1\n```\n\n---\n\n**Input:**\n```\n(int[]) coins = [1]\n(int) amount = 0\n```\n\n**Output:**\n```\n(int) 0\n```",
    "solutions": {}
  },
  "combination-sum": {
    "id": "combination-sum",
    "title": "Combination Sum",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "airbnb",
      "amazon",
      "apple",
      "facebook",
      "goldman",
      "linkedin",
      "microsoft",
      "salesforce"
    ],
    "topics": [
      "array",
      "backtracking"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(2<sup>n</sup>)",
    "sc": "O(n)",
    "leetcode": "combination-sum",
    "gfg": null,
    "leetid": 32,
    "content": "---\nlayout: post\ntitle: Combination Sum\ntopics: [array, backtracking]\nlangs: [java, cpp, py]\ntc: O(2<sup>n</sup>)\nsc: O(n)\nleetid: 32\ncompanies: [adobe, airbnb, amazon, apple, facebook, goldman, linkedin, microsoft, salesforce]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: combination-sum\nleetcode: combination-sum\n---\n\nGiven an array of distinct integers `candidates` and a target integer `target`, \nreturn a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. \nYou may return the combinations in any order.\n\nThe same number may be chosen from `candidates` an unlimited number of times. \nTwo combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nIt is guaranteed that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n```\n\n**Example 2:** \n```\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n```",
    "body": "Given an array of distinct integers `candidates` and a target integer `target`, \nreturn a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. \nYou may return the combinations in any order.\n\nThe same number may be chosen from `candidates` an unlimited number of times. \nTwo combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nIt is guaranteed that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n```\n\n**Example 2:** \n```\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n```",
    "solutions": {}
  },
  "construct-binary-tree-from-preorder-and-inorder-traversal": {
    "id": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "binary-tree",
      "divide-and-conquer",
      "tree"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(h)",
    "sc": "O(1)",
    "leetcode": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "gfg": null,
    "leetid": 105,
    "content": "---\nlayout: post\ntitle: Construct Binary Tree from Preorder and Inorder Traversal\ntopics: [array, binary-tree, divide-and-conquer, tree]\nlangs: [java, py, cpp]\ntc: O(h)\nsc: O(1)\nleetid: 105\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: construct-binary-tree-from-preorder-and-inorder-traversal\n---\n\nGiven two integer arrays `preorder` and `inorder` where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, \nconstruct and return the binary tree.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n```\n\n**Example 2:** \n```\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n```",
    "body": "Given two integer arrays `preorder` and `inorder` where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, \nconstruct and return the binary tree.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n```\n\n**Example 2:** \n```\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n```",
    "solutions": {}
  },
  "convert-binary-tree-to-dll": {
    "id": "convert-binary-tree-to-dll",
    "title": "Convert Binary Tree to DLL",
    "difficulty": "medium",
    "companies": [
      "amazon",
      "microsoft",
      "facebook",
      "salesforce"
    ],
    "topics": [
      "binary-tree",
      "linked-list",
      "tree"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(h)",
    "leetcode": "convert-binary-tree-to-dll",
    "gfg": "convert-binary-tree-to-doubly-linked-list-using-inorder-traversal",
    "leetid": null,
    "content": "---\nlayout: post\ntitle: Convert Binary Tree to DLL\ntopics: [binary-tree, linked-list, tree]\nlangs: [java]\ntc: O(n)\nsc: O(h)\nleetid: \ndifficulty: medium\ncompanies: [amazon, microsoft, facebook, salesforce]\ngfg: convert-binary-tree-to-doubly-linked-list-using-inorder-traversal\nhackerrank: \ninterviewbit: \nleetcode: convert-binary-tree-to-dll\n---\n\nGiven a Binary Tree (BT), the task is to convert it to a Doubly Linked List (DLL) in place. The left and right pointers in nodes will be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be the same as the order of the given Binary Tree. The first node of Inorder traversal (leftmost node in BT) must be the head node of the DLL.\n\n---\n## Test Cases\n**Example 1:**\n\n```\nInput:\n      1\n    /  \\\n   3    2\nOutput:\n3 1 2 \n2 1 3\n```\n\n**Example 2:**\n```\nInput:\n       10\n      /   \\\n     20   30\n   /   \\\n  40   60\nOutput:\n40 20 60 10 30 \n30 10 60 20 40\n```",
    "body": "Given a Binary Tree (BT), the task is to convert it to a Doubly Linked List (DLL) in place. The left and right pointers in nodes will be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be the same as the order of the given Binary Tree. The first node of Inorder traversal (leftmost node in BT) must be the head node of the DLL.\n\n---\n## Test Cases\n**Example 1:**\n\n```\nInput:\n      1\n    /  \\\n   3    2\nOutput:\n3 1 2 \n2 1 3\n```\n\n**Example 2:**\n```\nInput:\n       10\n      /   \\\n     20   30\n   /   \\\n  40   60\nOutput:\n40 20 60 10 30 \n30 10 60 20 40\n```",
    "solutions": {}
  },
  "count-and-say": {
    "id": "count-and-say",
    "title": "Count and Say",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "count-and-say",
    "gfg": "look-and-say-sequence",
    "leetid": 38,
    "content": "---\nlayout: post\ntitle: Count and Say\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 38\ngfg: look-and-say-sequence\ncompanies: [facebook]\ndifficulty: medium\nhackerrank: \ninterviewbit: count-and-say\nleetcode: count-and-say\n---\n\nThe **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n- `countAndSay(1) = \"1\"`\n- `countAndSay(n)` is the way you would \"say\" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, \nsplit it into the minimal number of groups so that each group is a contiguous section of all the same character. \nThen for each group, say the number of characters, then say the character. \n\nTo convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n\nFor example, the saying and conversion for digit string \"3322251\":\n\n**\"<span style={{color:'red'}}>33</span><span style={{color:'blue'}}>222</span><span style={{color:'pink'}}>5</span><span style={{color:'green'}}>1</span>\"**\n\n**<span style={{color:'red'}}>two 3's, </span><span style={{color:'blue'}}>three 2's, </span><span style={{color:'pink'}}>one 5, </span><span style={{color:'green'}}>one 1</span>**\n\n**<span style={{color:'red'}}>2 3</span>+<span style={{color:'blue'}}>3 2</span>+<span style={{color:'pink'}}>1 5</span>+<span style={{color:'green'}}>1 1</span>**\n\n**\"<span style={{color:'red'}}>23</span><span style={{color:'blue'}}>32</span><span style={{color:'pink'}}>15</span><span style={{color:'green'}}>11</span>\"**\n\n\nGiven a positive integer `n`, return the nth term of the count-and-say sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n```\n\n**Example 2:** \n```\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n```",
    "body": "The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n- `countAndSay(1) = \"1\"`\n- `countAndSay(n)` is the way you would \"say\" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, \nsplit it into the minimal number of groups so that each group is a contiguous section of all the same character. \nThen for each group, say the number of characters, then say the character. \n\nTo convert the saying into a digit string, replace the counts with a number and concatenate every saying.\n\nFor example, the saying and conversion for digit string \"3322251\":\n\n**\"<span style={{color:'red'}}>33</span><span style={{color:'blue'}}>222</span><span style={{color:'pink'}}>5</span><span style={{color:'green'}}>1</span>\"**\n\n**<span style={{color:'red'}}>two 3's, </span><span style={{color:'blue'}}>three 2's, </span><span style={{color:'pink'}}>one 5, </span><span style={{color:'green'}}>one 1</span>**\n\n**<span style={{color:'red'}}>2 3</span>+<span style={{color:'blue'}}>3 2</span>+<span style={{color:'pink'}}>1 5</span>+<span style={{color:'green'}}>1 1</span>**\n\n**\"<span style={{color:'red'}}>23</span><span style={{color:'blue'}}>32</span><span style={{color:'pink'}}>15</span><span style={{color:'green'}}>11</span>\"**\n\n\nGiven a positive integer `n`, return the nth term of the count-and-say sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n```\n\n**Example 2:** \n```\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n```",
    "solutions": {}
  },
  "count-of-smaller-numbers-after-self": {
    "id": "count-of-smaller-numbers-after-self",
    "title": "Count of Smaller Numbers After Self",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "divide-and-conquer",
      "sorting"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(nlogn)",
    "sc": "O(n)",
    "leetcode": "count-of-smaller-numbers-after-self",
    "gfg": "count-smaller-elements-on-right-side",
    "leetid": 315,
    "content": "---\nlayout: post\ntitle: Count of Smaller Numbers After Self\ntopics: [array, divide-and-conquer, sorting]\nlangs: [java, cpp]\ntc: O(nlogn)\nsc: O(n)\nleetid: 315\ngfg: count-smaller-elements-on-right-side\ncompanies: [facebook]\ndifficulty: hard\nhackerrank: \ninterviewbit: \nleetcode: count-of-smaller-numbers-after-self\n---\n\nYou are given an integer array `nums` and you have to return a new `counts` array. \nThe `counts` array has the property where `counts[i]` is the number of smaller elements to the right of `nums[i]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [5,2,6,1]\nOutput: [2,1,1,0]\nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\n```\n\n**Example 2:** \n```\nInput: nums = [-1,-1]\nOutput: [0,0]\n```",
    "body": "You are given an integer array `nums` and you have to return a new `counts` array. \nThe `counts` array has the property where `counts[i]` is the number of smaller elements to the right of `nums[i]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [5,2,6,1]\nOutput: [2,1,1,0]\nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\n```\n\n**Example 2:** \n```\nInput: nums = [-1,-1]\nOutput: [0,0]\n```",
    "solutions": {}
  },
  "course-schedule-ii": {
    "id": "course-schedule-ii",
    "title": "Course Schedule II",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "depth-first-search",
      "graph",
      "topological-sort"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(V+E)",
    "sc": "O(V+E)",
    "leetcode": "course-schedule-ii",
    "gfg": null,
    "leetid": 210,
    "content": "---\nlayout: post\ntitle: Course Schedule II\ntopics: [depth-first-search, graph, topological-sort]\nlangs: [java, py]\ntc: O(V+E)\nsc: O(V+E)\nleetid: 210\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: course-schedule-ii\n---\n\nThere are a total of numCourses courses you have to take, labeled from `0` to `numCourses - 1`. \nYou are given an array prerequisites where prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]\nindicates that you must take course b<sub>i</sub> first if you want to take course a<sub>i</sub>.\n\nFor example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\nReturn the ordering of courses you should take to finish all courses. \nIf there are many valid answers, return any of them. \nIf it is impossible to finish all courses, return an empty array.\n\n---\n## How to Solve\n\n*The first node in the topological ordering will be the node that doesn't have any incoming edges. \nEssentially, any node that has an in-degree of 0 can start the topologically sorted order. \nIf there are multiple such nodes, their relative order doesn't matter, and they can appear in any order.*\n\n1. Initialize a queue, Q to keep a track of all the nodes in the graph with 0 in-degree. \n2. Iterate over all the edges in the input and create an adjacency list and also a map of node v/s in-degree. \n3. Add all the nodes with 0 in-degree to Q. \n4. The following steps are to be done until the Q becomes empty. \n   1. Pop a node from the Q. Let's call this node, N. \n   2. For all the neighbors of this node, N, reduce their in-degree by 1. If any of the nodes' in-degree reaches 0, add it to the Q. \n   3. Add the node N to the list maintaining topologically sorted order. \n   4. Continue from step `4.1`.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int) numCourses = 2\n(int[]) prerequisites = [[1,0]]\n```\n\n**Output:** \n```\n(int[]) [0, 1]\n```\n\n**Explanation:**\n```\nThere are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So the correct course order is [0,1].\n```\n\n---\n\n**Input:** \n```\n(int) numCourses = 4\n(int[]) prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n```\n\n**Output:** \n```\n(int[]) [0,2,1,3]\n```\n\n**Explanation:**\n```\nThere are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n```",
    "body": "There are a total of numCourses courses you have to take, labeled from `0` to `numCourses - 1`. \nYou are given an array prerequisites where prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]\nindicates that you must take course b<sub>i</sub> first if you want to take course a<sub>i</sub>.\n\nFor example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\nReturn the ordering of courses you should take to finish all courses. \nIf there are many valid answers, return any of them. \nIf it is impossible to finish all courses, return an empty array.\n\n---\n## How to Solve\n\n*The first node in the topological ordering will be the node that doesn't have any incoming edges. \nEssentially, any node that has an in-degree of 0 can start the topologically sorted order. \nIf there are multiple such nodes, their relative order doesn't matter, and they can appear in any order.*\n\n1. Initialize a queue, Q to keep a track of all the nodes in the graph with 0 in-degree. \n2. Iterate over all the edges in the input and create an adjacency list and also a map of node v/s in-degree. \n3. Add all the nodes with 0 in-degree to Q. \n4. The following steps are to be done until the Q becomes empty. \n   1. Pop a node from the Q. Let's call this node, N. \n   2. For all the neighbors of this node, N, reduce their in-degree by 1. If any of the nodes' in-degree reaches 0, add it to the Q. \n   3. Add the node N to the list maintaining topologically sorted order. \n   4. Continue from step `4.1`.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int) numCourses = 2\n(int[]) prerequisites = [[1,0]]\n```\n\n**Output:** \n```\n(int[]) [0, 1]\n```\n\n**Explanation:**\n```\nThere are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So the correct course order is [0,1].\n```\n\n---\n\n**Input:** \n```\n(int) numCourses = 4\n(int[]) prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n```\n\n**Output:** \n```\n(int[]) [0,2,1,3]\n```\n\n**Explanation:**\n```\nThere are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n```",
    "solutions": {}
  },
  "course-schedule-iii": {
    "id": "course-schedule-iii",
    "title": "Course Schedule III",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "greedy",
      "heap"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nlogn)",
    "sc": "O(n)",
    "leetcode": "course-schedule-iii",
    "gfg": null,
    "leetid": 630,
    "content": "---\nlayout: post\ntitle: Course Schedule III\ntopics: [array, greedy, heap]\nlangs: [java]\ntc: O(nlogn)\nsc: O(n)\nleetid: 630\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: course-schedule-iii\n---\n\nThere are `n` different online courses numbered from `1` to `n`. \nYou are given an array courses where `courses[i] = [duration, lastDay]` \nindicate that the ith course should be taken continuously for duration<sub>i</sub> days \nand must be finished before or on lastDay<sub>i</sub>.\n\nYou will start on the 1<sup>st</sup> day and you cannot take two or more courses simultaneously.\n\nReturn the maximum number of courses that you can take.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n```\n\n**Example 2:**\n```\nInput: courses = [[1,2]]\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: courses = [[3,2],[4,3]]\nOutput: 0\n```",
    "body": "There are `n` different online courses numbered from `1` to `n`. \nYou are given an array courses where `courses[i] = [duration, lastDay]` \nindicate that the ith course should be taken continuously for duration<sub>i</sub> days \nand must be finished before or on lastDay<sub>i</sub>.\n\nYou will start on the 1<sup>st</sup> day and you cannot take two or more courses simultaneously.\n\nReturn the maximum number of courses that you can take.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\nOutput: 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.\nSecond, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. \nThird, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. \nThe 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.\n```\n\n**Example 2:**\n```\nInput: courses = [[1,2]]\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: courses = [[3,2],[4,3]]\nOutput: 0\n```",
    "solutions": {}
  },
  "decode-string": {
    "id": "decode-string",
    "title": "Decode String",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "queue",
      "recursion",
      "stack",
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "decode-string",
    "gfg": null,
    "leetid": 394,
    "content": "---\nlayout: post\ntitle: Decode String\ntopics: [queue, recursion, stack, string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 394\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: decode-string\nhellointerview: code/stack/decode-string\n---\n\nGiven an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, \nwhere the encoded_string inside the square brackets is being repeated exactly k times. \nNote that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; \nthere are no extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. \nFor example, there will not be input like `3a` or `2[4]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"3[a]2[bc]\"\nOutput: \"aaabcbc\"\n```\n\n**Example 2:** \n```\nInput: s = \"3[a2[c]]\"\nOutput: \"accaccacc\"\n```\n\n**Example 3:**\n```\nInput: s = \"2[abc]3[cd]ef\"\nOutput: \"abcabccdcdcdef\"\n```",
    "body": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, \nwhere the encoded_string inside the square brackets is being repeated exactly k times. \nNote that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; \nthere are no extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. \nFor example, there will not be input like `3a` or `2[4]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"3[a]2[bc]\"\nOutput: \"aaabcbc\"\n```\n\n**Example 2:** \n```\nInput: s = \"3[a2[c]]\"\nOutput: \"accaccacc\"\n```\n\n**Example 3:**\n```\nInput: s = \"2[abc]3[cd]ef\"\nOutput: \"abcabccdcdcdef\"\n```",
    "solutions": {}
  },
  "decode-ways": {
    "id": "decode-ways",
    "title": "Decode Ways",
    "difficulty": "medium",
    "companies": [
      "facebook",
      "amazon",
      "uber"
    ],
    "topics": [
      "dynamic-programming",
      "string"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "decode-ways",
    "gfg": null,
    "leetid": 91,
    "content": "---\nlayout: post\ntitle: Decode Ways\ntopics: [dynamic-programming, string]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(n)\nleetid: 91\ninterviewbit: ways-to-decode\ndifficulty: medium\ncompanies: [facebook, amazon, uber]\ngfg: \nhackerrank: \nleetcode: decode-ways\n---\n\nA message containing letters from A-Z can be encoded into numbers using the following mapping:\n```\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nTo **decode** an encoded message, \nall the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). \nFor example, `\"11106\"` can be mapped into:\n- `\"AAJF\"` with the grouping `(1 1 10 6)`\n- `\"KJF\"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n\nGiven a string `s` containing only digits, return the number of ways to decode it.\n\n---\n\n## Test Cases\n\n#### Example 1\n```\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n```\n\n#### Example 2\n```\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n```",
    "body": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n```\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nTo **decode** an encoded message, \nall the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). \nFor example, `\"11106\"` can be mapped into:\n- `\"AAJF\"` with the grouping `(1 1 10 6)`\n- `\"KJF\"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n\nGiven a string `s` containing only digits, return the number of ways to decode it.\n\n---\n\n## Test Cases\n\n#### Example 1\n```\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n```\n\n#### Example 2\n```\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n```",
    "solutions": {}
  },
  "detect-cycle-directed-graph": {
    "id": "detect-cycle-directed-graph",
    "title": "Detect Cycle Directed Graph",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "graph"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(V+E)",
    "sc": "O(V)",
    "leetcode": null,
    "gfg": "detect-cycle-in-a-graph",
    "content": "---\nlayout: post\ntitle: Detect Cycle Directed Graph\ntopics: [graph]\nlangs: [java]\ntc: O(V+E)\nsc: O(V)\ngfg: detect-cycle-in-a-graph\ndifficulty: medium\ncompanies: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, check whether it contains any cycle or not.\n\n---\n\n## How to Solve\n\n1. Create the graph using the given number of edges and vertices. \n2. Create a recursive function that initializes the current index or vertex, visited, and recursion stack. \n3. Mark the current node as visited and also mark the index in recursion stack. \n4. Find all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true, return true. \n5. If the adjacent vertices are already marked in the recursion stack then return true. \n6. Create a wrapper class, that calls the recursive function for all the vertices and if any function returns true return true. Else if for all vertices the function returns false, return false.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: V=4 adj=[[1],[2],[3],[3]]\nOutput: true\nExplanation: 1->2->3->3 is cycle\n```\n\n**Example 2:** \n```\nInput: V=4 adj=[[1],[2],[]]\nOutput: false\n```",
    "body": "Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, check whether it contains any cycle or not.\n\n---\n\n## How to Solve\n\n1. Create the graph using the given number of edges and vertices. \n2. Create a recursive function that initializes the current index or vertex, visited, and recursion stack. \n3. Mark the current node as visited and also mark the index in recursion stack. \n4. Find all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true, return true. \n5. If the adjacent vertices are already marked in the recursion stack then return true. \n6. Create a wrapper class, that calls the recursive function for all the vertices and if any function returns true return true. Else if for all vertices the function returns false, return false.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: V=4 adj=[[1],[2],[3],[3]]\nOutput: true\nExplanation: 1->2->3->3 is cycle\n```\n\n**Example 2:** \n```\nInput: V=4 adj=[[1],[2],[]]\nOutput: false\n```",
    "solutions": {}
  },
  "detect-cycle-undirected-graph": {
    "id": "detect-cycle-undirected-graph",
    "title": "Detect Cycle Undirected Graph",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "graph"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(V+E)",
    "sc": "O(V)",
    "leetcode": null,
    "gfg": null,
    "content": "---\nlayout: post\ntitle: Detect Cycle Undirected Graph\ntopics: [graph]\nlangs: [java]\ntc: O(V+E)\nsc: O(V)\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven an undirected graph with V vertices and E edges, check whether it contains any cycle or not.\n\n---\n\n## How to Solve\n\n1. Create the graph using the given number of edges and vertices.\n2. Create a recursive function that have current index or vertex, visited array and parent node. \n3. Mark the current node as visited . \n4. Find all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true return true.\n5. If the adjacent node is not parent and already visited then return true. \n6. Create a wrapper class, that calls the recursive function for all the vertices and if any function returns true, return `true`. \n7. Else if for all vertices the function returns false, return `false`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: V=5 adj=[[1],[2,4],[1,3],[2,4],[1,3]]\nOutput: true\nExplanation: 1->2->3->4->1 is cycle\n```\n\n**Example 2:** \n```\nInput: V=4 adj=[[],[2],[1,3],[2]]\nOutput: false\n```",
    "body": "Given an undirected graph with V vertices and E edges, check whether it contains any cycle or not.\n\n---\n\n## How to Solve\n\n1. Create the graph using the given number of edges and vertices.\n2. Create a recursive function that have current index or vertex, visited array and parent node. \n3. Mark the current node as visited . \n4. Find all the vertices which are not visited and are adjacent to the current node. Recursively call the function for those vertices, If the recursive function returns true return true.\n5. If the adjacent node is not parent and already visited then return true. \n6. Create a wrapper class, that calls the recursive function for all the vertices and if any function returns true, return `true`. \n7. Else if for all vertices the function returns false, return `false`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: V=5 adj=[[1],[2,4],[1,3],[2,4],[1,3]]\nOutput: true\nExplanation: 1->2->3->4->1 is cycle\n```\n\n**Example 2:** \n```\nInput: V=4 adj=[[],[2],[1,3],[2]]\nOutput: false\n```",
    "solutions": {}
  },
  "edit-distance": {
    "id": "edit-distance",
    "title": "Edit Distance",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "dynamic-programming",
      "string"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(nm)",
    "sc": "O(nm)",
    "leetcode": "edit-distance",
    "gfg": null,
    "leetid": 72,
    "content": "---\nlayout: post\ntitle: Edit Distance\ntopics: [dynamic-programming, string]\nlangs: [java, cpp, py]\ntc: O(nm)\nsc: O(nm)\nleetid: 72\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: edit-distance\n---\n\nGiven two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\n\n- Insert a character\n- Delete a character\n- Replace a character\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n```\n\n**Example 2:** \n```\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n```",
    "body": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have the following three operations permitted on a word:\n\n- Insert a character\n- Delete a character\n- Replace a character\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n```\n\n**Example 2:** \n```\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n```",
    "solutions": {}
  },
  "find-k-closest-elements": {
    "id": "find-k-closest-elements",
    "title": "Find K Closest Elements",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "two-pointers",
      "binary-search",
      "sliding-window",
      "sorting",
      "heap-priority-queue"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "find-k-closest-elements",
    "gfg": null,
    "leetid": 658,
    "content": "---\nlayout: post\ntitle: Find K Closest Elements\ntopics: [array, two-pointers, binary-search, sliding-window, sorting, heap-priority-queue]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\nleetid: 658\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: find-k-closest-elements\nhellointerview: code/heap/find-k-closest-elements\n---\nGiven a **sorted** integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.\nAn integer `a` is closer to `x` than an integer `b` if:\n\t\n* `|a - x| < |b - x|`, or\n\t\n* `|a - x| == |b - x|` and `a < b`\n \n---\n## Test Cases\n\n**Example 1:**\n```\nInput: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]\n```\n\n**Example 2:**\n```\nInput: arr = [1,1,2,3,4,5], k = 4, x = -1\nOutput: [1,1,2,3]\n```\n \n**Constraints:**\n\t\n* `1 <= k <= arr.length`\n\t\n* `1 <= arr.length <= 10<sup>4</sup>`\n\t\n* `arr` is sorted in **ascending** order.\n\t\n* `-10<sup>4</sup> <= arr[i], x <= 10<sup>4</sup>`\n\n        ",
    "body": "Given a **sorted** integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.\nAn integer `a` is closer to `x` than an integer `b` if:\n\t\n* `|a - x| < |b - x|`, or\n\t\n* `|a - x| == |b - x|` and `a < b`\n \n---\n## Test Cases\n\n**Example 1:**\n```\nInput: arr = [1,2,3,4,5], k = 4, x = 3\nOutput: [1,2,3,4]\n```\n\n**Example 2:**\n```\nInput: arr = [1,1,2,3,4,5], k = 4, x = -1\nOutput: [1,1,2,3]\n```\n \n**Constraints:**\n\t\n* `1 <= k <= arr.length`\n\t\n* `1 <= arr.length <= 10<sup>4</sup>`\n\t\n* `arr` is sorted in **ascending** order.\n\t\n* `-10<sup>4</sup> <= arr[i], x <= 10<sup>4</sup>`\n\n        ",
    "solutions": {}
  },
  "find-median-from-data-stream": {
    "id": "find-median-from-data-stream",
    "title": "Find Median from Data Stream",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "heap",
      "sorting",
      "two-pointers"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(1)",
    "sc": "O(1)",
    "leetcode": "find-median-from-data-stream",
    "gfg": null,
    "leetid": 295,
    "content": "---\nlayout: post\ntitle: Find Median from Data Stream\ntopics: [heap, sorting, two-pointers]\nlangs: [java]\ntc: O(1)\nsc: O(1)\nleetid: 295\ndifficulty: hard\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: find-median-from-data-stream\nmetacareers: 547645422524434\n---\n\nThe median is the middle value in an ordered integer list. \nIf the size of the list is even, there is no middle value and the median is the mean of the two middle values.\n\n- For example, for `arr = [2,3,4]`, the median is `3`.\n- For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.\n\nImplement the MedianFinder class:\n- `MedianFinder()` initializes the `MedianFinder` object.\n- `void addNum(int num)` adds the integer num from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far. Answers within 10<sup>-5</sup> of the actual answer will be accepted.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n```\n",
    "body": "The median is the middle value in an ordered integer list. \nIf the size of the list is even, there is no middle value and the median is the mean of the two middle values.\n\n- For example, for `arr = [2,3,4]`, the median is `3`.\n- For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.\n\nImplement the MedianFinder class:\n- `MedianFinder()` initializes the `MedianFinder` object.\n- `void addNum(int num)` adds the integer num from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far. Answers within 10<sup>-5</sup> of the actual answer will be accepted.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n```\n",
    "solutions": {}
  },
  "find-minimum-in-rotated-sorted-array": {
    "id": "find-minimum-in-rotated-sorted-array",
    "title": "Find Minimum in Rotated Sorted Array",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "binary-search"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(logn)",
    "sc": "O(1)",
    "leetcode": "find-minimum-in-rotated-sorted-array",
    "gfg": null,
    "leetid": 153,
    "content": "---\nlayout: post\ntitle: Find Minimum in Rotated Sorted Array\ntopics: [array, binary-search]\nlangs: [java]\ntc: O(logn)\nsc: O(1)\nleetid: 153\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: find-minimum-in-rotated-sorted-array\n---\nSuppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\t\n* `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n\t\n* `[0,1,2,4,5,6,7]` if it was rotated `7` times.\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\nGiven the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*.\nYou must write an algorithm that runs in `O(log n) time.`\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n```\n**Example 2:**\n```\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n```\n**Example 3:**\n```\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n```\n \n**Constraints:**\n\t\n* `n == nums.length`\n\t\n* `1 <= n <= 5000`\n\t\n* `-5000 <= nums[i] <= 5000`\n\t\n* All the integers of `nums` are **unique**.\n\t\n* `nums` is sorted and rotated between `1` and `n` times.\n\n        ",
    "body": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\t\n* `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n\t\n* `[0,1,2,4,5,6,7]` if it was rotated `7` times.\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\nGiven the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*.\nYou must write an algorithm that runs in `O(log n) time.`\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n```\n**Example 2:**\n```\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n```\n**Example 3:**\n```\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n```\n \n**Constraints:**\n\t\n* `n == nums.length`\n\t\n* `1 <= n <= 5000`\n\t\n* `-5000 <= nums[i] <= 5000`\n\t\n* All the integers of `nums` are **unique**.\n\t\n* `nums` is sorted and rotated between `1` and `n` times.\n\n        ",
    "solutions": {}
  },
  "find-peak-element": {
    "id": "find-peak-element",
    "title": "Find Peak Element",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "binary-search"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(log n)",
    "sc": "O(1)",
    "leetcode": "find-peak-element",
    "gfg": "find-a-peak-in-a-given-array",
    "leetid": 162,
    "content": "---\nlayout: post\ntitle: Find Peak Element\ndifficulty: medium\ntopics: [array, binary-search]\nlangs: [java, cpp, py]\ntc: O(log n)\nsc: O(1)\nleetid: 162\ngfg: find-a-peak-in-a-given-array\ninterviewbit: \nhackerrank: \ncompanies: [facebook]\nleetcode: find-peak-element\n---\nA peak element is an element that is strictly greater than its neighbors.\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\nYou may imagine that `nums[-1] = nums[n] = -`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in `O(log n)` time.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.```\n**Example 2:**\n```\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 1000`\n\t\n* `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`\n\t\n* `nums[i] != nums[i + 1]` for all valid `i`.\n\n",
    "body": "A peak element is an element that is strictly greater than its neighbors.\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\nYou may imagine that `nums[-1] = nums[n] = -`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in `O(log n)` time.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.```\n**Example 2:**\n```\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 1000`\n\t\n* `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`\n\t\n* `nums[i] != nums[i + 1]` for all valid `i`.\n\n",
    "solutions": {}
  },
  "find-the-celebrity": {
    "id": "find-the-celebrity",
    "title": "Find the Celebrity",
    "difficulty": "medium",
    "companies": [
      "facebook",
      "linkedin",
      "amazon",
      "apple",
      "google",
      "microsoft",
      "pinterest",
      "uber"
    ],
    "topics": [
      "two-pointers"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "go"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "find-the-celebrity",
    "gfg": "the-celebrity-problem",
    "leetid": 277,
    "content": "---\nlayout: post\ntitle: Find the Celebrity\ntopics: [two-pointers]\nlangs: [java, py, cpp, go]\ntc: O(n)\nsc: O(1)\nleetid: 277\ncompanies: [facebook, linkedin, amazon, apple, google, microsoft, pinterest, uber]\ndifficulty: medium\ngfg: the-celebrity-problem\nhackerrank: \ninterviewbit: \nleetcode: find-the-celebrity\n---\n\nSuppose you are at a party with `n` people (labeled from `0` to `n - 1`) and among them, there may exist one celebrity. \nThe definition of a celebrity is that all the other `n - 1` people know him/her but he/she does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. \nThe only thing you are allowed to do is to ask questions like: \n\"Hi, A. Do you know B?\" to get information of whether A knows B. \nYou need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function `bool knows(a, b)` which tells you whether `a` knows `b`. \nImplement a function `int findCelebrity(n)`. There will be exactly one celebrity if he/she is in the party. \n\nReturn the celebrity's label if there is a celebrity in the party. If there is no celebrity, return `-1`.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: graph = [[1,1,0],[0,1,0],[1,1,1]]\nOutput: 1\nExplanation: There are three persons labeled with 0, 1 and 2. \ngraph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. \nThe celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n```\n\n**Example 2:**\n```\nInput: graph = [[1,0,1],[1,1,0],[0,1,1]]\nOutput: -1\nExplanation: There is no celebrity.\n```",
    "body": "Suppose you are at a party with `n` people (labeled from `0` to `n - 1`) and among them, there may exist one celebrity. \nThe definition of a celebrity is that all the other `n - 1` people know him/her but he/she does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. \nThe only thing you are allowed to do is to ask questions like: \n\"Hi, A. Do you know B?\" to get information of whether A knows B. \nYou need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function `bool knows(a, b)` which tells you whether `a` knows `b`. \nImplement a function `int findCelebrity(n)`. There will be exactly one celebrity if he/she is in the party. \n\nReturn the celebrity's label if there is a celebrity in the party. If there is no celebrity, return `-1`.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: graph = [[1,1,0],[0,1,0],[1,1,1]]\nOutput: 1\nExplanation: There are three persons labeled with 0, 1 and 2. \ngraph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. \nThe celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n```\n\n**Example 2:**\n```\nInput: graph = [[1,0,1],[1,1,0],[0,1,1]]\nOutput: -1\nExplanation: There is no celebrity.\n```",
    "solutions": {}
  },
  "find-the-duplicate-number": {
    "id": "find-the-duplicate-number",
    "title": "Find the Duplicate Number",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "google",
      "microsoft"
    ],
    "topics": [
      "array",
      "binary-search",
      "two-pointers"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "go",
      "kt"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "find-the-duplicate-number",
    "gfg": null,
    "leetid": 287,
    "content": "---\nlayout: post\ntitle: Find the Duplicate Number\ntopics: [array, binary-search, two-pointers]\nlangs: [java, py, cpp, go, kt]\ntc: O(n)\nsc: O(1)\nleetid: 287\ncompanies: [adobe, amazon, apple, bloomberg, facebook, google, microsoft]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: find-the-duplicate-number\n---\n\nGiven an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only one repeated number in `nums`, return this repeated number.\n\nYou must solve the problem without modifying the array nums and uses only constant extra space.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [1,3,4,2,2]\n```\n\n**Output:** \n```\n(int) 2\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [3,1,3,4,2]\n```\n\n**Output:**\n```\n(int) 3\n```",
    "body": "Given an array of integers nums containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only one repeated number in `nums`, return this repeated number.\n\nYou must solve the problem without modifying the array nums and uses only constant extra space.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [1,3,4,2,2]\n```\n\n**Output:** \n```\n(int) 2\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [3,1,3,4,2]\n```\n\n**Output:**\n```\n(int) 3\n```",
    "solutions": {}
  },
  "first-missing-positive": {
    "id": "first-missing-positive",
    "title": "First Missing Positive",
    "difficulty": "hard",
    "companies": [
      "adobe",
      "amazon",
      "apple",
      "facebook",
      "google",
      "microsoft"
    ],
    "topics": [
      "array",
      "hash-table"
    ],
    "langs": [
      "java",
      "py",
      "c",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "first-missing-positive",
    "gfg": null,
    "leetid": 41,
    "content": "---\nlayout: post\ntitle: First Missing Positive\ntopics: [array, hash-table]\nlangs: [java, py, c, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 41\ncompanies: [adobe, amazon, apple, facebook, google, microsoft]\ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: first-missing-positive\n---\n\nGiven an unsorted integer array `nums`, return the smallest missing positive integer.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums = [1,2,0]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: nums = [3,4,-1,1]\nOutput: 2\n```\n\n**Example 3:**\n```\nInput: nums = [7,8,9,11,12]\nOutput: 1\n```",
    "body": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums = [1,2,0]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: nums = [3,4,-1,1]\nOutput: 2\n```\n\n**Example 3:**\n```\nInput: nums = [7,8,9,11,12]\nOutput: 1\n```",
    "solutions": {}
  },
  "flatten-binary-tree-to-linked-list": {
    "id": "flatten-binary-tree-to-linked-list",
    "title": "Flatten Binary Tree to Linked List",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "binary-tree",
      "depth-first-search",
      "linked-list",
      "tree"
    ],
    "langs": [
      "java",
      "cpp",
      "c",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "flatten-binary-tree-to-linked-list",
    "gfg": null,
    "leetid": 114,
    "content": "---\nlayout: post\ntitle: Flatten Binary Tree to Linked List\ntopics: [binary-tree, depth-first-search, linked-list, tree]\nlangs: [java, cpp, c, py]\ntc: O(n)\nsc: O(n)\nleetid: 114\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: flatten-binary-tree-to-linked-list\n---\n\nGiven the root of a binary tree, flatten the tree into a \"linked list\":\n- The \"linked list\" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always null.\n- The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n```\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\nExplanation:\n     1\n    / \\\n   2   5\n  / \\   \\\n 3   4   6\n\nchanges to\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n```\n\n**Example 2:** \n```\nInput: root = []\nOutput: []\n```",
    "body": "Given the root of a binary tree, flatten the tree into a \"linked list\":\n- The \"linked list\" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always null.\n- The \"linked list\" should be in the same order as a pre-order traversal of the binary tree.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n```\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\nExplanation:\n     1\n    / \\\n   2   5\n  / \\   \\\n 3   4   6\n\nchanges to\n\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n```\n\n**Example 2:** \n```\nInput: root = []\nOutput: []\n```",
    "solutions": {}
  },
  "gas-station": {
    "id": "gas-station",
    "title": "Gas Station",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "greedy"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "gas-station",
    "gfg": "find-a-tour-that-visits-all-stations",
    "leetid": 134,
    "content": "---\nlayout: post\ntitle: Gas Station\ntopics: [array, greedy]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(1)\nleetid: 134\ncompanies: [facebook]\ngfg: find-a-tour-that-visits-all-stations\ninterviewbit: gas-station\nhackerrank: truck-tour\ndifficulty: medium\nleetcode: gas-station\n---\nThere are `n` gas stations along a circular route, where the amount of gas at the `i<sup>th</sup>` station is `gas[i]`.\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `i<sup>th</sup>` station to its next `(i + 1)<sup>th</sup>` station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays `gas` and `cost`, return *the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return* `-1`. If there exists a solution, it is **guaranteed** to be **unique**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n```\n\n**Example 2:**\n```\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n```\n \n**Constraints:**\n\t\n* `n == gas.length == cost.length`\n* `1 <= n <= 10<sup>5</sup>`\n* `0 <= gas[i], cost[i] <= 10<sup>4</sup>`\n* The input is generated such that the answer is unique.",
    "body": "There are `n` gas stations along a circular route, where the amount of gas at the `i<sup>th</sup>` station is `gas[i]`.\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `i<sup>th</sup>` station to its next `(i + 1)<sup>th</sup>` station. You begin the journey with an empty tank at one of the gas stations.\nGiven two integer arrays `gas` and `cost`, return *the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return* `-1`. If there exists a solution, it is **guaranteed** to be **unique**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n```\n\n**Example 2:**\n```\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n```\n \n**Constraints:**\n\t\n* `n == gas.length == cost.length`\n* `1 <= n <= 10<sup>5</sup>`\n* `0 <= gas[i], cost[i] <= 10<sup>4</sup>`\n* The input is generated such that the answer is unique.",
    "solutions": {}
  },
  "generate-parentheses": {
    "id": "generate-parentheses",
    "title": "Generate Parentheses",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "goldman",
      "google",
      "microsoft",
      "uber"
    ],
    "topics": [
      "backtracking",
      "dynamic-programming",
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(4<sup>n</sup>/n&#8730;n)",
    "sc": "O(4<sup>n</sup>/n&#8730;n)",
    "leetcode": "generate-parentheses",
    "gfg": "print-all-combinations-of-balanced-parentheses",
    "leetid": 22,
    "content": "---\nlayout: post\ntitle: Generate Parentheses\ntopics: [backtracking, dynamic-programming, string]\nlangs: [java]\ntc: O(4<sup>n</sup>/n&#8730;n)\nsc: O(4<sup>n</sup>/n&#8730;n)\nleetid: 22\ncompanies: [adobe, amazon, apple, bloomberg, facebook, goldman, google, microsoft, uber]\ngfg: print-all-combinations-of-balanced-parentheses\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: generate-parentheses\n---\n\nGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n---\n## How to Solve\n\n### Approach 1\nTo generate all sequences, we use a recursion. \nAll sequences of length n is just `(` plus all sequences of length n-1, and then `)` plus all sequences of length n-1.\n\nTo check whether a sequence is valid, we keep track of balance, \nthe net number of opening brackets minus closing brackets. \nIf it falls below zero at any time, or doesn't end in zero, the sequence is invalid - otherwise it is valid.\n\n### Approach 2\nInstead of adding '(' or ')' every time as in Approach 1, \nlet's only add them when we know it will remain a valid sequence.\nWe can do this by keeping track of the number of opening and closing brackets we have placed so far.\n\nWe can start an opening bracket if we still have one (of `n`) left to place. \nAnd we can start a closing bracket if it would not exceed the number of opening brackets.\n\n---\n## Test Cases\n\n**Input:**\n\n    (int) n = 3\n\n**Output:**\n\n    (String[]) [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] \n",
    "body": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n---\n## How to Solve\n\n### Approach 1\nTo generate all sequences, we use a recursion. \nAll sequences of length n is just `(` plus all sequences of length n-1, and then `)` plus all sequences of length n-1.\n\nTo check whether a sequence is valid, we keep track of balance, \nthe net number of opening brackets minus closing brackets. \nIf it falls below zero at any time, or doesn't end in zero, the sequence is invalid - otherwise it is valid.\n\n### Approach 2\nInstead of adding '(' or ')' every time as in Approach 1, \nlet's only add them when we know it will remain a valid sequence.\nWe can do this by keeping track of the number of opening and closing brackets we have placed so far.\n\nWe can start an opening bracket if we still have one (of `n`) left to place. \nAnd we can start a closing bracket if it would not exceed the number of opening brackets.\n\n---\n## Test Cases\n\n**Input:**\n\n    (int) n = 3\n\n**Output:**\n\n    (String[]) [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] \n",
    "solutions": {}
  },
  "group-anagrams": {
    "id": "group-anagrams",
    "title": "Group Anagrams",
    "difficulty": "medium",
    "companies": [
      "facebook",
      "uber"
    ],
    "topics": [
      "array",
      "hash-table",
      "string",
      "sorting"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(nm)",
    "sc": "O(nm)",
    "leetcode": "group-anagrams",
    "gfg": "given-a-sequence-of-words-print-all-anagrams-together",
    "leetid": 49,
    "content": "---\nlayout: post\ntitle: Group Anagrams\ntopics: [array, hash-table, string, sorting]\nlangs: [java, py]\ntc: O(nm)\nsc: O(nm)\nleetid: 49\ncompanies: [facebook, uber]\ngfg: given-a-sequence-of-words-print-all-anagrams-together\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: group-anagrams\n---\nGiven an array of strings `strs`, group the `anagrams` together. You can return the answer in **any order**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExplanation:\n* There is no string in strs that can be rearranged to form `\"bat\"`.\n* The strings `\"nat\"` and `\"tan\"` are anagrams as they can be rearranged to form each other.\n* The strings `\"ate\"`, `\"eat\"`, and `\"tea\"` are anagrams as they can be rearranged to form each other.\n```\n\n**Example 2:**\n```\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n```\n\n**Example 3:**\n```\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n```\n \n**Constraints:**\n* `1 <= strs.length <= 10<sup>4</sup>`\n* `0 <= strs[i].length <= 100`\n* `strs[i]` consists of lowercase English letters.\n\n        ",
    "body": "Given an array of strings `strs`, group the `anagrams` together. You can return the answer in **any order**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExplanation:\n* There is no string in strs that can be rearranged to form `\"bat\"`.\n* The strings `\"nat\"` and `\"tan\"` are anagrams as they can be rearranged to form each other.\n* The strings `\"ate\"`, `\"eat\"`, and `\"tea\"` are anagrams as they can be rearranged to form each other.\n```\n\n**Example 2:**\n```\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n```\n\n**Example 3:**\n```\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n```\n \n**Constraints:**\n* `1 <= strs.length <= 10<sup>4</sup>`\n* `0 <= strs[i].length <= 100`\n* `strs[i]` consists of lowercase English letters.\n\n        ",
    "solutions": {}
  },
  "group-shifted-strings": {
    "id": "group-shifted-strings",
    "title": "Group Shifted Strings",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "strings",
      "hash-table"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "go"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "group-shifted-strings",
    "gfg": null,
    "leetid": 249,
    "content": "---\nlayout: post\ntitle: Group Shifted Strings\ntopics: [strings, hash-table]\nlangs: [java, py, cpp, go]\ntc: O(n)\nsc: O(n)\nleetid: 249\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: group-shifted-strings\n---\n\nWe can shift a string by shifting each of its letters to its successive letter.\n* For example, `\"abc\"` can be shifted to be `\"bcd\"`.\n\nWe can keep shifting the string to form a sequence.\n* For example, we can keep shifting `\"abc\"` to form the sequence: `\"abc\" -> \"bcd\" -> ... -> \"xyz\"`.\n\n* Given an array of strings `strings`, group all `strings[i]` that belong to the same shifting sequence. \n* You may return the answer in **any order**.\n\n---\n## How to Solve\n\nThe relative distance between each letter of the string and the first character is equal.\n\nFor example, `abc` and `efg` are mutually offset. \nFor abc, the distance between b and a is 1, and the distance between c and a is 2. \nFor efg, the distance between f and e is 1, and the distance between g and e is 2.\n\nLets look at another example. \nThe distance between az and yx, z and a is 25, and the distance between x and y is also 25 (direct subtraction is -1, \nwhich is the reason for adding 26 and taking the remainder).\n\nThen, in this case, all strings that are offset from each other have a unique distance difference. \nAccording to this, the mapping can be well grouped.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: strings = [\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\nOutput: [[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\n```\n\n**Example 2:**\n```\nInput: strings = [\"a\"]\nOutput: [[\"a\"]]\n```\n\n**Constraints**\n* `1 <= strings.length <= 200`\n* `1 <= strings[i].length <= 50`\n* `strings[i] consists of lowercase English letters.`",
    "body": "We can shift a string by shifting each of its letters to its successive letter.\n* For example, `\"abc\"` can be shifted to be `\"bcd\"`.\n\nWe can keep shifting the string to form a sequence.\n* For example, we can keep shifting `\"abc\"` to form the sequence: `\"abc\" -> \"bcd\" -> ... -> \"xyz\"`.\n\n* Given an array of strings `strings`, group all `strings[i]` that belong to the same shifting sequence. \n* You may return the answer in **any order**.\n\n---\n## How to Solve\n\nThe relative distance between each letter of the string and the first character is equal.\n\nFor example, `abc` and `efg` are mutually offset. \nFor abc, the distance between b and a is 1, and the distance between c and a is 2. \nFor efg, the distance between f and e is 1, and the distance between g and e is 2.\n\nLets look at another example. \nThe distance between az and yx, z and a is 25, and the distance between x and y is also 25 (direct subtraction is -1, \nwhich is the reason for adding 26 and taking the remainder).\n\nThen, in this case, all strings that are offset from each other have a unique distance difference. \nAccording to this, the mapping can be well grouped.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: strings = [\"abc\",\"bcd\",\"acef\",\"xyz\",\"az\",\"ba\",\"a\",\"z\"]\nOutput: [[\"acef\"],[\"a\",\"z\"],[\"abc\",\"bcd\",\"xyz\"],[\"az\",\"ba\"]]\n```\n\n**Example 2:**\n```\nInput: strings = [\"a\"]\nOutput: [[\"a\"]]\n```\n\n**Constraints**\n* `1 <= strings.length <= 200`\n* `1 <= strings[i].length <= 50`\n* `strings[i] consists of lowercase English letters.`",
    "solutions": {}
  },
  "house-robber-ii": {
    "id": "house-robber-ii",
    "title": "House Robber II",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "house-robber-ii",
    "gfg": null,
    "leetid": 213,
    "content": "---\nlayout: post\ntitle: House Robber II\ntopics: [array, dynamic-programming]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 213\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: house-robber-ii\n---\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.\nGiven an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n```\n**Example 2:**\n```\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n```\n**Example 3:**\n```\nInput: nums = [1,2,3]\nOutput: 3\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 100`\n\t\n* `0 <= nums[i] <= 1000`\n\n        ",
    "body": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.\nGiven an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n```\n**Example 2:**\n```\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n```\n**Example 3:**\n```\nInput: nums = [1,2,3]\nOutput: 3\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 100`\n\t\n* `0 <= nums[i] <= 1000`\n\n        ",
    "solutions": {}
  },
  "house-robber-iii": {
    "id": "house-robber-iii",
    "title": "House Robber III",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "binary-tree",
      "depth-first-search",
      "dynamic-programming",
      "tree"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "house-robber-iii",
    "gfg": null,
    "leetid": 337,
    "content": "---\nlayout: post\ntitle: House Robber III\ntopics: [binary-tree, depth-first-search, dynamic-programming, tree]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 337\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: house-robber-iii\n---\n\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. \nAfter a tour, the smart thief realized that all houses in this place form a binary tree. \nIt will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(TreeNode) root = [3,2,3,null,3,null,1]\n```\n\n**Output:** \n```\n(int) 7\n```\n\n**Explanation:**\n```\n    3\n   / \\\n  2   3\n   \\   \\\n    3   1\n\nMaximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n```",
    "body": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. \nAfter a tour, the smart thief realized that all houses in this place form a binary tree. \nIt will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return the maximum amount of money the thief can rob without alerting the police.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(TreeNode) root = [3,2,3,null,3,null,1]\n```\n\n**Output:** \n```\n(int) 7\n```\n\n**Explanation:**\n```\n    3\n   / \\\n  2   3\n   \\   \\\n    3   1\n\nMaximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n```",
    "solutions": {}
  },
  "insert-delete-getrandom-o1": {
    "id": "insert-delete-getrandom-o1",
    "title": "Insert Delete GetRandom O1",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "hash-table"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(1)",
    "sc": "O(n)",
    "leetcode": "insert-delete-getrandom-o1",
    "gfg": null,
    "leetid": 380,
    "content": "---\nlayout: post\ntitle: Insert Delete GetRandom O1\ntopics: [array, hash-table]\nlangs: [java]\ntc: O(1)\nsc: O(n)\nleetid: 380\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: insert-delete-getrandom-o1\n---\n\nImplement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\n- `bool insert(int val)` Inserts an item val into the set if not present. Returns `true` if the item was not present, false otherwise.\n- `bool remove(int val)` Removes an item val from the set if present. Returns `true` if the item was present, false otherwise.\n- `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\n\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n```",
    "body": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\n- `bool insert(int val)` Inserts an item val into the set if not present. Returns `true` if the item was not present, false otherwise.\n- `bool remove(int val)` Removes an item val from the set if present. Returns `true` if the item was present, false otherwise.\n- `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\n\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n```",
    "solutions": {}
  },
  "integer-to-english-words": {
    "id": "integer-to-english-words",
    "title": "Integer to English Words",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "math",
      "string",
      "recursion"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(1)",
    "sc": "O(1)",
    "leetcode": "integer-to-english-words",
    "gfg": null,
    "leetid": 273,
    "content": "---\nlayout: post\ntitle: Integer to English Words\ndifficulty: hard\ntopics: [math, string, recursion]\nlangs: [java]\ntc: O(1)\nsc: O(1)\ncompanies: [facebook]\nleetid: 273\nleetcode: integer-to-english-words\ngfg: \ninterviewbit: \nhackerrank: \n---\nConvert a non-negative integer `num` to its English words representation.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: num = 123\nOutput: \"One Hundred Twenty Three\"\n```\n**Example 2:**\n```\nInput: num = 12345\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n```\n**Example 3:**\n```\nInput: num = 1234567\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n```\n \n**Constraints:**\n\t\n* `0 <= num <= 2<sup>31</sup> - 1`\n\n",
    "body": "Convert a non-negative integer `num` to its English words representation.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: num = 123\nOutput: \"One Hundred Twenty Three\"\n```\n**Example 2:**\n```\nInput: num = 12345\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n```\n**Example 3:**\n```\nInput: num = 1234567\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n```\n \n**Constraints:**\n\t\n* `0 <= num <= 2<sup>31</sup> - 1`\n\n",
    "solutions": {}
  },
  "k-closest-points-to-origin": {
    "id": "k-closest-points-to-origin",
    "title": "K Closest Points to Origin",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "math",
      "divide-and-conquer",
      "geometry",
      "sorting",
      "heap-priority-queue",
      "quickselect"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nlogk)",
    "sc": "O(k)",
    "leetcode": "k-closest-points-to-origin",
    "gfg": null,
    "leetid": 1014,
    "content": "---\nlayout: post\ntitle: K Closest Points to Origin\ndifficulty: medium\ntopics: [array, math, divide-and-conquer, geometry, sorting, heap-priority-queue, quickselect]\nlangs: [java]\ntc: O(nlogk)\nsc: O(k)\ncompanies: [facebook]\nleetid: 1014\nleetcode: k-closest-points-to-origin\ngfg: \ninterviewbit: \nhackerrank: \n---\nGiven an array of `points` where `points[i] = [x<sub>i</sub>, y<sub>i</sub>]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.\nThe distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `(x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y<sub>1</sub> - y<sub>2</sub>)<sup>2</sup>`).\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style={{width: '400px', height: '400px'}} />\n```\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n```\n\n**Example 2:**\n```\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n```\n \n**Constraints:**\n\t\n* `1 <= k <= points.length <= 10<sup>4</sup>`\n* `-10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>`\n",
    "body": "Given an array of `points` where `points[i] = [x<sub>i</sub>, y<sub>i</sub>]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.\nThe distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `(x<sub>1</sub> - x<sub>2</sub>)<sup>2</sup> + (y<sub>1</sub> - y<sub>2</sub>)<sup>2</sup>`).\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg\" style={{width: '400px', height: '400px'}} />\n```\nInput: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n```\n\n**Example 2:**\n```\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n```\n \n**Constraints:**\n\t\n* `1 <= k <= points.length <= 10<sup>4</sup>`\n* `-10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup>`\n",
    "solutions": {}
  },
  "koko-eating-bananas": {
    "id": "koko-eating-bananas",
    "title": "Koko Eating Bananas",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "binary-search"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(logn)",
    "sc": "O(1)",
    "leetcode": "koko-eating-bananas",
    "gfg": null,
    "leetid": 875,
    "content": "---\nlayout: post\ntitle: Koko Eating Bananas\ntopics: [array, binary-search]\nlangs: [java]\ntc: O(logn)\nsc: O(1)\nleetid: 875\ncompanies: [facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: koko-eating-bananas\n---\n\nKoko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. \nThe guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. \nEach hour, she chooses some pile of bananas and eats `k` bananas from that pile. \nIf the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n```\n\n**Example 2:** \n```\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n```\n\n**Example 3:**\n```\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n```",
    "body": "Koko loves to eat bananas. There are `n` piles of bananas, the ith pile has `piles[i]` bananas. \nThe guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. \nEach hour, she chooses some pile of bananas and eats `k` bananas from that pile. \nIf the pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer `k` such that she can eat all the bananas within `h` hours.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n```\n\n**Example 2:** \n```\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n```\n\n**Example 3:**\n```\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n```",
    "solutions": {}
  },
  "kth-smallest-element-in-a-bst": {
    "id": "kth-smallest-element-in-a-bst",
    "title": "Kth Smallest Element in a BST",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "binary-tree",
      "binary-search-tree",
      "depth-first-search",
      "tree"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(h+k)",
    "sc": "O(h)",
    "leetcode": "kth-smallest-element-in-a-bst",
    "gfg": null,
    "leetid": 230,
    "content": "---\nlayout: post\ntitle: Kth Smallest Element in a BST\ntopics: [binary-tree, binary-search-tree, depth-first-search, tree]\nlangs: [java, py, cpp]\ntc: O(h+k)\nsc: O(h)\nleetid: 230\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: kth-smallest-element-in-a-bst\n---\n\nGiven the root of a binary search tree, and an integer k, return the k<sup>th</sup> smallest value (1-indexed) of all the values of the nodes in the tree.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\nExplanation:\n   3\n  / \\\n 1   4\n  \\\n   2\n```\n\n**Example 2:**\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\nExplanation:\n      5\n     / \\\n    3   6\n   / \\\n  2   4\n /    \n1\n```",
    "body": "Given the root of a binary search tree, and an integer k, return the k<sup>th</sup> smallest value (1-indexed) of all the values of the nodes in the tree.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\nExplanation:\n   3\n  / \\\n 1   4\n  \\\n   2\n```\n\n**Example 2:**\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\nExplanation:\n      5\n     / \\\n    3   6\n   / \\\n  2   4\n /    \n1\n```",
    "solutions": {}
  },
  "kth-smallest-element-in-a-sorted-matrix": {
    "id": "kth-smallest-element-in-a-sorted-matrix",
    "title": "Kth Smallest Element in a Sorted Matrix",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "binary-search"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "kt"
    ],
    "tc": "O(n+m)",
    "sc": "O(1)",
    "leetcode": "kth-smallest-element-in-a-sorted-matrix",
    "gfg": null,
    "leetid": 378,
    "content": "---\nlayout: post\ntitle: Kth Smallest Element in a Sorted Matrix\ntopics: [array, binary-search]\nlangs: [java, py, cpp, kt]\ntc: O(n+m)\nsc: O(1)\nleetid: 378\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: kth-smallest-element-in-a-sorted-matrix\n---\n\nGiven an `n x n` matrix where each of the rows and columns is sorted in ascending order, \nreturn the k<sup>th</sup> smallest element in the matrix.\n\nNote that it is the k<sup>th</sup> smallest element in the sorted order, \nnot the k<sup>th</sup> distinct element.\n\n---\n\n## How to Solve\n\n### Algorithm\n- Start with `left = minOfMatrix = matrix[0][0]` and `right = maxOfMatrix = matrix[n-1][n-1]`. \n- Find the `mid` of the `left` and the `right`. This middle number is **NOT necessarily** an element in the matrix. \n- If `countLessOrEqual(mid) &gt;= k`, we keep current `ans = mid` and try to find smaller value by searching on the left side. Otherwise, we search on the right side. \n- Since `ans` is the smallest value which `countLessOrEqual(ans) &gt;= k`, so it's the k<sup>th</sup> smallest element in the matrix.\n\n### How to count number of elements less or equal to x efficiently?\n- Since our `matrix` is sorted in ascending order by rows and columns. \n- We use two pointers, one points to the rightmost column `c = n-1`, and one points to the lowest row `r = 0`.\n  - If `matrix[r][c] &lt;= x` then the number of elements in row `r` less or equal to `x` is `(c+1)` (Because `row[r]` is sorted in ascending order, so if `matrix[r][c] &lt;= x` then `matrix[r][c-1]` is also &lt;= `x`). \n  Then we go to next row to continue counting.\n  - Else if `matrix[r][c] &gt; x`, we decrease column c until `matrix[r][c] &lt;= x` (Because column is sorted in ascending order, so if `matrix[r][c] &gt; x` then `matrix[r+1][c]` is also &gt; `x`). \n- Time complexity for counting: `O(M+N)`.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) matrix = [[1,5,9],[10,11,13],[12,13,15]]\n(int) k = 8\n```\n\n**Output:**\n```\n(int) 13\n```\n\n**Explanation:**\n```\nThe elements in the matrix are [1,5,9,10,11,12,13,13,15], \nand the 8th smallest number is 13\n```",
    "body": "Given an `n x n` matrix where each of the rows and columns is sorted in ascending order, \nreturn the k<sup>th</sup> smallest element in the matrix.\n\nNote that it is the k<sup>th</sup> smallest element in the sorted order, \nnot the k<sup>th</sup> distinct element.\n\n---\n\n## How to Solve\n\n### Algorithm\n- Start with `left = minOfMatrix = matrix[0][0]` and `right = maxOfMatrix = matrix[n-1][n-1]`. \n- Find the `mid` of the `left` and the `right`. This middle number is **NOT necessarily** an element in the matrix. \n- If `countLessOrEqual(mid) &gt;= k`, we keep current `ans = mid` and try to find smaller value by searching on the left side. Otherwise, we search on the right side. \n- Since `ans` is the smallest value which `countLessOrEqual(ans) &gt;= k`, so it's the k<sup>th</sup> smallest element in the matrix.\n\n### How to count number of elements less or equal to x efficiently?\n- Since our `matrix` is sorted in ascending order by rows and columns. \n- We use two pointers, one points to the rightmost column `c = n-1`, and one points to the lowest row `r = 0`.\n  - If `matrix[r][c] &lt;= x` then the number of elements in row `r` less or equal to `x` is `(c+1)` (Because `row[r]` is sorted in ascending order, so if `matrix[r][c] &lt;= x` then `matrix[r][c-1]` is also &lt;= `x`). \n  Then we go to next row to continue counting.\n  - Else if `matrix[r][c] &gt; x`, we decrease column c until `matrix[r][c] &lt;= x` (Because column is sorted in ascending order, so if `matrix[r][c] &gt; x` then `matrix[r+1][c]` is also &gt; `x`). \n- Time complexity for counting: `O(M+N)`.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) matrix = [[1,5,9],[10,11,13],[12,13,15]]\n(int) k = 8\n```\n\n**Output:**\n```\n(int) 13\n```\n\n**Explanation:**\n```\nThe elements in the matrix are [1,5,9,10,11,12,13,13,15], \nand the 8th smallest number is 13\n```",
    "solutions": {}
  },
  "largest-number": {
    "id": "largest-number",
    "title": "Largest Number",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "greedy",
      "sorting",
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "largest-number",
    "gfg": null,
    "leetid": 179,
    "content": "---\nlayout: post\ntitle: Largest Number\ntopics: [greedy, sorting, string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 179\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: largest-number\n---\n\nGiven a list of non-negative integers `nums`, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [10,2]\nOutput: \"210\"\n```\n\n**Example 2:** \n```\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\n```",
    "body": "Given a list of non-negative integers `nums`, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [10,2]\nOutput: \"210\"\n```\n\n**Example 2:** \n```\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\n```",
    "solutions": {}
  },
  "largest-rectangle-in-histogram": {
    "id": "largest-rectangle-in-histogram",
    "title": "Largest Rectangle in Histogram",
    "difficulty": "hard",
    "companies": [
      "facebook",
      "google",
      "amazon"
    ],
    "topics": [
      "array",
      "stack"
    ],
    "langs": [
      "java",
      "py",
      "go",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "largest-rectangle-in-histogram",
    "gfg": "largest-rectangular-area-in-a-histogram-using-segment-tree",
    "leetid": 84,
    "content": "---\nlayout: post\ntitle: Largest Rectangle in Histogram\ntopics: [array, stack]\nlangs: [java, py, go, cpp]\ntc: O(n)\nsc: O(n)\nleetid: 84\ncompanies: [facebook, google, amazon]\ngfg: largest-rectangular-area-in-a-histogram-using-segment-tree\ndifficulty: hard\nhackerrank: \ninterviewbit: largest-rectangle-in-histogram\nleetcode: largest-rectangle-in-histogram\nhellointerview: code/stack/largest-rectangle-in-histogram\n---\n\nGiven an array of integers heights representing the histogram's bar height where the width of each bar is 1, \nreturn the area of the largest rectangle in the `histogram`.\n\n---\n\n## Test Cases\n\n**Input:**\n\n<img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" />\n\n```\n(int[]) heights = [2,1,5,6,2,3]\n```\n\n**Output:**\n```\n(int) 10\n```",
    "body": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, \nreturn the area of the largest rectangle in the `histogram`.\n\n---\n\n## Test Cases\n\n**Input:**\n\n<img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" />\n\n```\n(int[]) heights = [2,1,5,6,2,3]\n```\n\n**Output:**\n```\n(int) 10\n```",
    "solutions": {}
  },
  "least-number-of-unique-integers-after-k-removals": {
    "id": "least-number-of-unique-integers-after-k-removals",
    "title": "Least Number of Unique Integers after K Removals",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "hash-table",
      "greedy",
      "sorting",
      "counting"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "least-number-of-unique-integers-after-k-removals",
    "gfg": null,
    "leetid": 1604,
    "content": "---\nlayout: post\ntitle: Least Number of Unique Integers after K Removals\ntopics: [array, hash-table, greedy, sorting, counting]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 1604\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: least-number-of-unique-integers-after-k-removals\n---\nGiven an array of integers `arr` and an integer `k`. Find the *least number of unique integers* after removing **exactly** `k` elements\n\n---\n## Test Cases\n**Example 1:**\n\n```\nInput: arr = [5,5,4], k = 1\nOutput: 1\nExplanation: Remove the single 4, only 5 is left.\n```\n\n**Example 2:**\n\n```\nInput: arr = [4,3,1,1,3,3,2], k = 3\nOutput: 2\nExplanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n```\n\n**Constraints:**\n\n* `1 <= arr.length <= 10^5`\n\t\n* `1 <= arr[i] <= 10^9`\n\t\n* `0 <= k <= arr.length`",
    "body": "Given an array of integers `arr` and an integer `k`. Find the *least number of unique integers* after removing **exactly** `k` elements\n\n---\n## Test Cases\n**Example 1:**\n\n```\nInput: arr = [5,5,4], k = 1\nOutput: 1\nExplanation: Remove the single 4, only 5 is left.\n```\n\n**Example 2:**\n\n```\nInput: arr = [4,3,1,1,3,3,2], k = 3\nOutput: 2\nExplanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n```\n\n**Constraints:**\n\n* `1 <= arr.length <= 10^5`\n\t\n* `1 <= arr[i] <= 10^9`\n\t\n* `0 <= k <= arr.length`",
    "solutions": {}
  },
  "letter-combinations-of-a-phone-number": {
    "id": "letter-combinations-of-a-phone-number",
    "title": "Letter Combinations of a Phone Number",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "goldman",
      "google",
      "intuit",
      "microsoft",
      "oracle",
      "twitter",
      "uber"
    ],
    "topics": [
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "letter-combinations-of-a-phone-number",
    "gfg": "iterative-letter-combinations-of-a-phone-number",
    "leetid": 17,
    "content": "---\nlayout: post\ntitle: Letter Combinations of a Phone Number\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 17\ngfg: iterative-letter-combinations-of-a-phone-number\ncompanies: [adobe, amazon, apple, bloomberg, facebook, goldman, google, intuit, microsoft, oracle, twitter, uber]\ndifficulty: medium\nhackerrank: \ninterviewbit: letter-phone\nleetcode: letter-combinations-of-a-phone-number\n---\n\nGiven a string containing digits from `2-9` inclusive, \nreturn all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that `1` does not map to any letters.\n\n```\n2 -> abc\n3 -> def\n4 -> ghi\n5 -> jkl\n6 -> mno\n7 -> pqrs\n8 -> tuv\n9 -> wxyz\n```\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n```\n\n**Example 2:** \n```\nInput: digits = \"\"\nOutput: []\n```",
    "body": "Given a string containing digits from `2-9` inclusive, \nreturn all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that `1` does not map to any letters.\n\n```\n2 -> abc\n3 -> def\n4 -> ghi\n5 -> jkl\n6 -> mno\n7 -> pqrs\n8 -> tuv\n9 -> wxyz\n```\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n```\n\n**Example 2:** \n```\nInput: digits = \"\"\nOutput: []\n```",
    "solutions": {}
  },
  "linked-list-cycle-ii": {
    "id": "linked-list-cycle-ii",
    "title": "Linked List Cycle II",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "linked-list",
      "two-pointers"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "linked-list-cycle-ii",
    "gfg": null,
    "leetid": 142,
    "content": "---\nlayout: post\ntitle: Linked List Cycle II\ntopics: [linked-list, two-pointers]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 142\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: linked-list-cycle-ii\nhellointerview: code/linked-list/linked-list-cycle\n---\n\nGiven the `head` of a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. \nInternally, `pos` is used to denote the index of the node that tail's next pointer is connected to (0-indexed). \nIt is `-1` if there is no cycle. Note that pos is not passed as a parameter.\n\n**Do not modify the linked list.**\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n```\n\n**Example 2:** \n```\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n```",
    "body": "Given the `head` of a linked list, return the node where the cycle begins. If there is no cycle, return `null`.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. \nInternally, `pos` is used to denote the index of the node that tail's next pointer is connected to (0-indexed). \nIt is `-1` if there is no cycle. Note that pos is not passed as a parameter.\n\n**Do not modify the linked list.**\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n```\n\n**Example 2:** \n```\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n```",
    "solutions": {}
  },
  "longest-consecutive-sequence": {
    "id": "longest-consecutive-sequence",
    "title": "Longest Consecutive Sequence",
    "difficulty": "medium",
    "companies": [
      "amazon",
      "apple",
      "facebook",
      "goldman",
      "google",
      "linkedin",
      "microsoft",
      "salesforce"
    ],
    "topics": [
      "array",
      "hash-table"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "longest-consecutive-sequence",
    "gfg": null,
    "leetid": 128,
    "content": "---\nlayout: post\ntitle: Longest Consecutive Sequence\ntopics: [array, hash-table]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(n)\nleetid: 128\ncompanies: [amazon, apple, facebook, goldman, google, linkedin, microsoft, salesforce]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-consecutive-sequence\n---\n\nGiven an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n```\n\n**Example 2:** \n```\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n```",
    "body": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n```\n\n**Example 2:** \n```\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n```",
    "solutions": {}
  },
  "longest-cycle-in-graph": {
    "id": "longest-cycle-in-graph",
    "title": "Longest Cycle in Graph",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "depth-first-search",
      "graph",
      "topological-sort"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nm)",
    "sc": "O(nm)",
    "leetcode": "longest-cycle-in-graph",
    "gfg": null,
    "leetid": 2360,
    "content": "---\nlayout: post\ntitle: Longest Cycle in Graph\ntopics: [depth-first-search, graph, topological-sort]\nlangs: [java]\ntc: O(nm)\nsc: O(nm)\nleetid: 2360\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-cycle-in-graph\n---\n\nYou are given a directed graph of n nodes numbered from `0` to `n - 1`, where each node has at most one outgoing edge.\n\nThe graph is represented with a given **0-indexed** array edges of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`.\n\nReturn the *length of the longest cycle in the graph*. If no cycle exists, return `-1`.\n\nA cycle is a path that starts and ends at the same node.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<MdxImage src=\"code/longest-cycle.png\" />\n```\nInput: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: \nThe longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n```\n\n**Example 2:** \n```\nInput: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph.\n```",
    "body": "You are given a directed graph of n nodes numbered from `0` to `n - 1`, where each node has at most one outgoing edge.\n\nThe graph is represented with a given **0-indexed** array edges of size `n`, indicating that there is a directed edge from node `i` to node `edges[i]`. If there is no outgoing edge from node `i`, then `edges[i] == -1`.\n\nReturn the *length of the longest cycle in the graph*. If no cycle exists, return `-1`.\n\nA cycle is a path that starts and ends at the same node.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<MdxImage src=\"code/longest-cycle.png\" />\n```\nInput: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: \nThe longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n```\n\n**Example 2:** \n```\nInput: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph.\n```",
    "solutions": {}
  },
  "longest-increasing-path-in-a-matrix": {
    "id": "longest-increasing-path-in-a-matrix",
    "title": "Longest Increasing Path in a Matrix",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "depth-first-search",
      "dynamic-programming",
      "graph"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(4<sup>mn</sup>)",
    "sc": "O(mn)",
    "leetcode": "longest-increasing-path-in-a-matrix",
    "gfg": null,
    "leetid": 329,
    "content": "---\nlayout: post\ntitle: Longest Increasing Path in a Matrix\ntopics: [depth-first-search, dynamic-programming, graph]\nlangs: [java, cpp]\ntc: O(4<sup>mn</sup>)\nsc: O(mn)\nleetid: 329\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-increasing-path-in-a-matrix\n---\n\nGiven an `m` x `n` integers `matrix`, return the length of the longest increasing path in `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. \nYou may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n```\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path is [1, 2, 6, 9].\n```\n\n**Example 2:**\n\n```\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]\nOutput: 4\nExplanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n```",
    "body": "Given an `m` x `n` integers `matrix`, return the length of the longest increasing path in `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. \nYou may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n```\nInput: matrix = [[9,9,4],[6,6,8],[2,1,1]]\nOutput: 4\nExplanation: The longest increasing path is [1, 2, 6, 9].\n```\n\n**Example 2:**\n\n```\nInput: matrix = [[3,4,5],[3,2,6],[2,2,1]]\nOutput: 4\nExplanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n```",
    "solutions": {}
  },
  "longest-increasing-subsequence": {
    "id": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "difficulty": "medium",
    "companies": [
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "google",
      "microsoft",
      "adobe"
    ],
    "topics": [
      "array",
      "binary-search",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(nlogn)",
    "sc": "O(n)",
    "leetcode": "longest-increasing-subsequence",
    "gfg": "longest-increasing-subsequence-dp-3",
    "leetid": 300,
    "content": "---\nlayout: post\ntitle: Longest Increasing Subsequence\ntopics: [array, binary-search, dynamic-programming]\nlangs: [java, py]\ntc: O(nlogn)\nsc: O(n)\nleetid: 300\ncompanies: [amazon, apple, bloomberg, facebook, google, microsoft, adobe]\ngfg: longest-increasing-subsequence-dp-3\ninterviewbit: longest-increasing-subsequence\ndifficulty: medium\nhackerrank: \nleetcode: longest-increasing-subsequence\n---\n\nGiven an integer array `nums`, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. \nFor example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n```\n\n**Example 2:** \n```\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n```\n\n**Example 3:**\n```\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n```",
    "body": "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. \nFor example, `[3,6,2,7]` is a subsequence of the array `[0,3,1,6,2,2,7]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n```\n\n**Example 2:** \n```\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n```\n\n**Example 3:**\n```\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n```",
    "solutions": {}
  },
  "longest-palindromic-substring": {
    "id": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "google",
      "linkedin",
      "microsoft",
      "oracle",
      "salesforce"
    ],
    "topics": [
      "string",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(n<sup>2</sup>)",
    "sc": "O(n<sup>2</sup>)",
    "leetcode": "longest-palindromic-substring",
    "gfg": null,
    "leetid": 5,
    "content": "---\nlayout: post\ntitle: Longest Palindromic Substring\ntopics: [string, dynamic-programming]\nlangs: [java, py, cpp]\ntc: O(n<sup>2</sup>)\nsc: O(n<sup>2</sup>)\nleetid: 5\ncompanies: [adobe, amazon, apple, bloomberg, facebook, google, linkedin, microsoft, oracle, salesforce]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-palindromic-substring\n---\n\nGiven a string s, return the longest palindromic substring in s.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n**Example 2:**\n```\nInput: s = \"cbbd\"\nOutput: \"bb\"\n```",
    "body": "Given a string s, return the longest palindromic substring in s.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n**Example 2:**\n```\nInput: s = \"cbbd\"\nOutput: \"bb\"\n```",
    "solutions": {}
  },
  "longest-repeating-character-replacement": {
    "id": "longest-repeating-character-replacement",
    "title": "Longest Repeating Character Replacement",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "hash-table",
      "string",
      "sliding-window"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "longest-repeating-character-replacement",
    "gfg": null,
    "leetid": 424,
    "content": "---\nlayout: post\ntitle: Longest Repeating Character Replacement\ntopics: [hash-table, string, sliding-window]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 424\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-repeating-character-replacement\nhellointerview: code/sliding-window/longest-repeating-character-replacement\n---\nYou are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\nReturn *the length of the longest substring containing the same letter you can get after performing the above operations*.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\n```\n**Example 2:**\n```\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 10<sup>5</sup>`\n\t\n* `s` consists of only uppercase English letters.\n\t\n* `0 <= k <= s.length`\n\n        ",
    "body": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\nReturn *the length of the longest substring containing the same letter you can get after performing the above operations*.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\n```\n**Example 2:**\n```\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 10<sup>5</sup>`\n\t\n* `s` consists of only uppercase English letters.\n\t\n* `0 <= k <= s.length`\n\n        ",
    "solutions": {}
  },
  "longest-substring-with-at-least-k-repeating-characters": {
    "id": "longest-substring-with-at-least-k-repeating-characters",
    "title": "Longest Substring with at least k repeating characters",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "divide-and-conquer",
      "hash-table",
      "sliding-window",
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(26)",
    "leetcode": "longest-substring-with-at-least-k-repeating-characters",
    "gfg": null,
    "leetid": 395,
    "content": "---\nlayout: post\ntitle: Longest Substring with at least k repeating characters\ntopics: [divide-and-conquer, hash-table, sliding-window, string]\nlangs: [java]\ntc: O(n)\nsc: O(26)\nleetid: 395\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-substring-with-at-least-k-repeating-characters\n---\n\nGiven a string `s` and an integer `k`, \nreturn the length of the longest substring of `s` such that the frequency of each character in this substring is greater than or equal to `k`.\n\n---\n\n## How to Solve\n\nDivide and Conquer is one of the popular strategies that work in 2 phases. \n- Divide the problem into subproblems. (Divide Phase).\n- Repeatedly solve each subproblem independently and combine the result to solve the original problem. (Conquer Phase).\n\nWe could apply this strategy by recursively splitting the string into substrings and \ncombine the result to find the longest substring that satisfies the given condition.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) s = \"aaabb\"\n(int) k = 3\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\n```\n\n---\n\n**Input:**\n```\n(string) s = \"ababbc\"\n(int) k = 2\n```\n\n**Output:**\n```\n(int) 5\n```\n\n**Explanation:**\n```\nThe longest substring is \"ababb\", as 'a' is repeated 2 times, b 3 times.\n```",
    "body": "Given a string `s` and an integer `k`, \nreturn the length of the longest substring of `s` such that the frequency of each character in this substring is greater than or equal to `k`.\n\n---\n\n## How to Solve\n\nDivide and Conquer is one of the popular strategies that work in 2 phases. \n- Divide the problem into subproblems. (Divide Phase).\n- Repeatedly solve each subproblem independently and combine the result to solve the original problem. (Conquer Phase).\n\nWe could apply this strategy by recursively splitting the string into substrings and \ncombine the result to find the longest substring that satisfies the given condition.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) s = \"aaabb\"\n(int) k = 3\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\n```\n\n---\n\n**Input:**\n```\n(string) s = \"ababbc\"\n(int) k = 2\n```\n\n**Output:**\n```\n(int) 5\n```\n\n**Explanation:**\n```\nThe longest substring is \"ababb\", as 'a' is repeated 2 times, b 3 times.\n```",
    "solutions": {}
  },
  "longest-substring-without-repeating-characters": {
    "id": "longest-substring-without-repeating-characters",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "hash-table",
      "sliding-window",
      "string"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "ts"
    ],
    "tc": "O(n)",
    "sc": "O(26)",
    "leetcode": "longest-substring-without-repeating-characters",
    "gfg": null,
    "leetid": 3,
    "content": "---\nlayout: post\ntitle: Longest Substring Without Repeating Characters\ntopics: [hash-table, sliding-window, string]\nlangs: [java, py, cpp, ts]\ntc: O(n)\nsc: O(26)\nleetid: 3\ncompanies: [facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: longest-substring-without-repeating-characters\nhellointerview: code/sliding-window/longest-substring-without-repeating-characters\n---\n\nGiven a string `s`, find the length of the longest substring without repeating characters.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n**Example 2:**\n```\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n```\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```",
    "body": "Given a string `s`, find the length of the longest substring without repeating characters.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n```\n\n**Example 2:**\n```\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n```\n\n**Example 3:**\n```\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n```",
    "solutions": {}
  },
  "lowest-common-ancestor-of-a-binary-tree": {
    "id": "lowest-common-ancestor-of-a-binary-tree",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "amazon",
      "facebook",
      "microsoft",
      "google"
    ],
    "topics": [
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "c"
    ],
    "tc": "O(n)",
    "sc": "O(h)",
    "leetcode": "lowest-common-ancestor-of-a-binary-tree",
    "gfg": "lowest-common-ancestor-binary-tree-set-1",
    "leetid": 236,
    "content": "---\nlayout: post\ntitle: Lowest Common Ancestor of a Binary Tree\ntopics: [tree, depth-first-search, binary-tree]\nlangs: [java, py, cpp, c]\ntc: O(n)\nsc: O(h)\nleetid: 236\ncompanies: [adobe, amazon, facebook, microsoft, google]\ndifficulty: medium\ngfg: lowest-common-ancestor-binary-tree-set-1\nhackerrank: \ninterviewbit: least-common-ancestor\nleetcode: lowest-common-ancestor-of-a-binary-tree\n---\nGiven a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow <b>a node to be a descendant of itself</b>).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style={{width: '200px', height: '190px'}} />\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n```\n**Example 2:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style={{width: '200px', height: '190px'}} />\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n```\n**Example 3:**\n```\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[2, 10<sup>5</sup>]`.\n\t\n* `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`\n\t\n* All `Node.val` are **unique**.\n\t\n* `p != q`\n\t\n* `p` and `q` will exist in the tree.\n\n        ",
    "body": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow <b>a node to be a descendant of itself</b>).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style={{width: '200px', height: '190px'}} />\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n```\n**Example 2:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style={{width: '200px', height: '190px'}} />\n```\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n```\n**Example 3:**\n```\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[2, 10<sup>5</sup>]`.\n\t\n* `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`\n\t\n* All `Node.val` are **unique**.\n\t\n* `p != q`\n\t\n* `p` and `q` will exist in the tree.\n\n        ",
    "solutions": {}
  },
  "lru-cache": {
    "id": "lru-cache",
    "title": "LRU Cache",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "hash-table",
      "linked-list"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(1)",
    "sc": "O(n)",
    "leetcode": "lru-cache",
    "gfg": null,
    "leetid": 146,
    "content": "---\nlayout: post\ntitle: LRU Cache\ntopics: [hash-table, linked-list]\nlangs: [java, py]\ntc: O(1)\nsc: O(n)\nleetid: 146\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: lru-cache\n---\n\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n\n- `LRUCache(int capacity)` Initialize the LRU cache with positive size capacity.\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\n- `void put(int key, int value)` Update the value of the key if the key exists. \nOtherwise, add the key-value pair to the cache. \nIf the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\n---\n## Test Cases\n\n**Input:**\n```\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n```\n\n**Output:**\n```\n    [null, null, null, 1, null, -1, null, -1, 3, 4]\n```\n\n**Explanation**\n```\n    LRUCache lRUCache = new LRUCache(2);\n    lRUCache.put(1, 1); // cache is {1=1}\n    lRUCache.put(2, 2); // cache is {1=1, 2=2}\n    lRUCache.get(1);    // return 1\n    lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n    lRUCache.get(2);    // returns -1 (not found)\n    lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\n    lRUCache.get(1);    // return -1 (not found)\n    lRUCache.get(3);    // return 3\n    lRUCache.get(4);    // return 4\n```",
    "body": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n\n- `LRUCache(int capacity)` Initialize the LRU cache with positive size capacity.\n- `int get(int key)` Return the value of the key if the key exists, otherwise return -1.\n- `void put(int key, int value)` Update the value of the key if the key exists. \nOtherwise, add the key-value pair to the cache. \nIf the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\n---\n## Test Cases\n\n**Input:**\n```\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n```\n\n**Output:**\n```\n    [null, null, null, 1, null, -1, null, -1, 3, 4]\n```\n\n**Explanation**\n```\n    LRUCache lRUCache = new LRUCache(2);\n    lRUCache.put(1, 1); // cache is {1=1}\n    lRUCache.put(2, 2); // cache is {1=1, 2=2}\n    lRUCache.get(1);    // return 1\n    lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n    lRUCache.get(2);    // returns -1 (not found)\n    lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\n    lRUCache.get(1);    // return -1 (not found)\n    lRUCache.get(3);    // return 3\n    lRUCache.get(4);    // return 4\n```",
    "solutions": {}
  },
  "matching-pairs": {
    "id": "matching-pairs",
    "title": "Matching Pairs",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": null,
    "gfg": null,
    "content": "---\nlayout: post\ntitle: Matching Pairs\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven two strings s and t of length N, \nfind the maximum number of possible matching pairs in strings s and t after swapping exactly two characters within s.\n\nA swap is switching s[i] and s[j], \nwhere s[i] and s[j] denotes the character that is present at the ith and jth index of s, respectively. \nThe matching pairs of the two strings are defined as the number of indices for which s[i] and t[i] are equal.\n\nNote: This means you must swap two characters at different indices.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"abcd\" t = \"adcb\"\nOutput: 4\nExplanation: Using 0-based indexing, and with i = 1 and j = 3, s[1] and s[3] can be swapped, making it  \"adcb\".\nTherefore, the number of matching pairs of s and t will be 4.\n```\n\n**Output:** \n```\nInput: s = \"mno\" t = \"mno\"\nOutput: 1\nExplanation: Two indices have to be swapped, regardless of which two it is, only one letter will remain the same. \nIf i = 0 and j=1, s[0] and s[1] are swapped, making s = \"nmo\", which shares only \"o\" with t.\n```",
    "body": "Given two strings s and t of length N, \nfind the maximum number of possible matching pairs in strings s and t after swapping exactly two characters within s.\n\nA swap is switching s[i] and s[j], \nwhere s[i] and s[j] denotes the character that is present at the ith and jth index of s, respectively. \nThe matching pairs of the two strings are defined as the number of indices for which s[i] and t[i] are equal.\n\nNote: This means you must swap two characters at different indices.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"abcd\" t = \"adcb\"\nOutput: 4\nExplanation: Using 0-based indexing, and with i = 1 and j = 3, s[1] and s[3] can be swapped, making it  \"adcb\".\nTherefore, the number of matching pairs of s and t will be 4.\n```\n\n**Output:** \n```\nInput: s = \"mno\" t = \"mno\"\nOutput: 1\nExplanation: Two indices have to be swapped, regardless of which two it is, only one letter will remain the same. \nIf i = 0 and j=1, s[0] and s[1] are swapped, making s = \"nmo\", which shares only \"o\" with t.\n```",
    "solutions": {}
  },
  "max-area-of-island": {
    "id": "max-area-of-island",
    "title": "Max Area of Island",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "depth-first-search",
      "matrix"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(nm)",
    "sc": "O(1)",
    "leetcode": "max-area-of-island",
    "gfg": null,
    "leetid": 695,
    "content": "---\nlayout: post\ntitle: Max Area of Island\ntopics: [array, depth-first-search, matrix]\nlangs: [java, cpp]\ntc: O(nm)\nsc: O(1)\nleetid: 695\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: max-area-of-island\n---\n\nYou are given an `m` x `n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected\n4-directionally (horizontal or vertical.)\nYou may assume all four edges of the grid are surrounded by water.\n\nThe area of an island is the number of cells with a value `1` on the island.\n\nReturn the maximum area of an island in `grid`. If there is no island, return `0`.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: grid = \n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,1,1,0,1,0,0,0,0,0,0,0,0],\n[0,1,0,0,1,1,0,0,1,0,1,0,0],\n[0,1,0,0,1,1,0,0,1,1,1,0,0],\n[0,0,0,0,0,0,0,0,0,0,1,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\n```\n\n**Example 2:**\n\n```\nInput: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n```",
    "body": "You are given an `m` x `n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected\n4-directionally (horizontal or vertical.)\nYou may assume all four edges of the grid are surrounded by water.\n\nThe area of an island is the number of cells with a value `1` on the island.\n\nReturn the maximum area of an island in `grid`. If there is no island, return `0`.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: grid = \n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,1,1,0,1,0,0,0,0,0,0,0,0],\n[0,1,0,0,1,1,0,0,1,0,1,0,0],\n[0,1,0,0,1,1,0,0,1,1,1,0,0],\n[0,0,0,0,0,0,0,0,0,0,1,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\n```\n\n**Example 2:**\n\n```\nInput: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n```",
    "solutions": {}
  },
  "max-consecutive-ones-iii": {
    "id": "max-consecutive-ones-iii",
    "title": "Max Consecutive Ones III",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "binary-search",
      "sliding-window"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "max-consecutive-ones-iii",
    "gfg": null,
    "leetid": 1004,
    "content": "---\nlayout: post\ntitle: Max Consecutive Ones III\ntopics: [array, binary-search, sliding-window]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 1004\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: max-consecutive-ones-iii\n---\n\nGiven a binary array `nums` and an integer `k`, return the maximum number of consecutive `1`'s in the array if you can flip at most `k` `0`'s.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```\n\n**Example 2:** \n```\nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\nOutput: 10\nExplanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```",
    "body": "Given a binary array `nums` and an integer `k`, return the maximum number of consecutive `1`'s in the array if you can flip at most `k` `0`'s.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2\nOutput: 6\nExplanation: [1,1,1,0,0,1,1,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```\n\n**Example 2:** \n```\nInput: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3\nOutput: 10\nExplanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]\nBolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n```",
    "solutions": {}
  },
  "max-increase-to-keep-city-skyline": {
    "id": "max-increase-to-keep-city-skyline",
    "title": "Max Increase to Keep City Skyline",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "greedy"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n<sup>2</sup>)",
    "sc": "O(n)",
    "leetcode": "max-increase-to-keep-city-skyline",
    "gfg": null,
    "leetid": 807,
    "content": "---\nlayout: post\ntitle: Max Increase to Keep City Skyline\ntopics: [array, greedy]\nlangs: [java, py]\ntc: O(n<sup>2</sup>)\nsc: O(n)\nleetid: 807\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: max-increase-to-keep-city-skyline\n---\n\nThere is a city composed of `n x n` blocks, \nwhere each block contains a single building shaped like a vertical square prism. \nYou are given a 0-indexed `n x n` integer matrix grid where \n`grid[r][c]` represents the height of the building located in the block at row `r` and column `c`.\n\nA city's `skyline` is the outer contour formed by all the building when viewing the side of the city from a distance. \nThe skyline from each cardinal direction north, east, south, and west may be different.\n\nWe are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). \nThe height of a `0`-height building can also be increased. \nHowever, increasing the height of a building should not affect the city's skyline from any cardinal direction.\n\nReturn the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<MdxImage src=\"code/max-skyline.png\" alt=\"Max Skyline\" />\n\n```\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n```\n\n**Example 2:** \n```\nInput: grid = [[0,0,0],[0,0,0],[0,0,0]]\nOutput: 0\nExplanation: Increasing the height of any building will result in the skyline changing.\n```",
    "body": "There is a city composed of `n x n` blocks, \nwhere each block contains a single building shaped like a vertical square prism. \nYou are given a 0-indexed `n x n` integer matrix grid where \n`grid[r][c]` represents the height of the building located in the block at row `r` and column `c`.\n\nA city's `skyline` is the outer contour formed by all the building when viewing the side of the city from a distance. \nThe skyline from each cardinal direction north, east, south, and west may be different.\n\nWe are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). \nThe height of a `0`-height building can also be increased. \nHowever, increasing the height of a building should not affect the city's skyline from any cardinal direction.\n\nReturn the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<MdxImage src=\"code/max-skyline.png\" alt=\"Max Skyline\" />\n\n```\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n```\n\n**Example 2:** \n```\nInput: grid = [[0,0,0],[0,0,0],[0,0,0]]\nOutput: 0\nExplanation: Increasing the height of any building will result in the skyline changing.\n```",
    "solutions": {}
  },
  "maximal-rectangle": {
    "id": "maximal-rectangle",
    "title": "Maximal Rectangle",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming",
      "matrix",
      "stack"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(nm)",
    "sc": "O(m)",
    "leetcode": "maximal-rectangle",
    "gfg": null,
    "leetid": 85,
    "content": "---\nlayout: post\ntitle: Maximal Rectangle\ntopics: [array, dynamic-programming, matrix, stack]\nlangs: [java, cpp]\ntc: O(nm)\nsc: O(m)\nleetid: 85\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximal-rectangle\n---\n\nGiven a `rows x cols` binary matrix filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: grid = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\n```",
    "body": "Given a `rows x cols` binary matrix filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: grid = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\n```",
    "solutions": {}
  },
  "maximal-square": {
    "id": "maximal-square",
    "title": "Maximal Square",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming",
      "matrix"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(mn)",
    "sc": "O(mn)",
    "leetcode": "maximal-square",
    "gfg": null,
    "leetid": 221,
    "content": "---\nlayout: post\ntitle: Maximal Square\ntopics: [array, dynamic-programming, matrix]\nlangs: [java]\ntc: O(mn)\nsc: O(mn)\nleetid: 221\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximal-square\n---\n\nGiven an `m x n` binary matrix filled with `0`'s and `1`'s, find the largest square containing only `1`'s and return its area.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\n\n```\n\n**Example 2:** \n\n\n```\nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\n```",
    "body": "Given an `m x n` binary matrix filled with `0`'s and `1`'s, find the largest square containing only `1`'s and return its area.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n\n```\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\n\n```\n\n**Example 2:** \n\n\n```\nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\n```",
    "solutions": {}
  },
  "maximum-frequency-stack": {
    "id": "maximum-frequency-stack",
    "title": "Maximum Frequency Stack",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "hash-table",
      "heap",
      "queue"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(logn)",
    "sc": "O(n)",
    "leetcode": "maximum-frequency-stack",
    "gfg": null,
    "leetid": 895,
    "content": "---\nlayout: post\ntitle: Maximum Frequency Stack\ntopics: [hash-table, heap, queue]\nlangs: [java]\ntc: O(logn)\nsc: O(n)\nleetid: 895\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximum-frequency-stack\n---\n\nDesign a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n\nImplement the FreqStack class:\n- `FreqStack()` constructs an empty frequency stack. \n- `void push(int val)` pushes an integer val onto the top of the stack. \n- `int pop()` removes and returns the most frequent element in the stack. \n  - If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\nExplanation\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n```\n\n**Example 2:** \n```\nInput\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"pop\", \"pop\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\"]\n[[],[1], [1], [1], [2], [], [], [2], [2], [1], [], [], []]\nOutput\n[null,null,null,null,null,1,1,null,null,null,2,1,2]\n```",
    "body": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\n\nImplement the FreqStack class:\n- `FreqStack()` constructs an empty frequency stack. \n- `void push(int val)` pushes an integer val onto the top of the stack. \n- `int pop()` removes and returns the most frequent element in the stack. \n  - If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\nExplanation\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].\n```\n\n**Example 2:** \n```\nInput\n[\"FreqStack\",\"push\",\"push\",\"push\",\"push\",\"pop\", \"pop\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\"]\n[[],[1], [1], [1], [2], [], [], [2], [2], [1], [], [], []]\nOutput\n[null,null,null,null,null,1,1,null,null,null,2,1,2]\n```",
    "solutions": {}
  },
  "maximum-product-subarray": {
    "id": "maximum-product-subarray",
    "title": "Maximum Product Subarray",
    "difficulty": "medium",
    "companies": [
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "google",
      "linkedin",
      "microsoft"
    ],
    "topics": [
      "array",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "maximum-product-subarray",
    "gfg": null,
    "leetid": 152,
    "content": "---\nlayout: post\ntitle: Maximum Product Subarray\ntopics: [array, dynamic-programming]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 152\ncompanies: [amazon, apple, bloomberg, facebook, google, linkedin, microsoft]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximum-product-subarray\n---\n\nGiven an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\nA **subarray** is a contiguous subsequence of the array.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [2,3,-2,4]\n```\n\n**Output:** \n```\n(int) 6\n```\n\n**Explanation:**\n```\n[2,3] has the largest product 6.\n```",
    "body": "Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\nA **subarray** is a contiguous subsequence of the array.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [2,3,-2,4]\n```\n\n**Output:** \n```\n(int) 6\n```\n\n**Explanation:**\n```\n[2,3] has the largest product 6.\n```",
    "solutions": {}
  },
  "maximum-subarray": {
    "id": "maximum-subarray",
    "title": "Maximum Subarray",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "divide-and-conquer",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "cpp",
      "py",
      "go"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "maximum-subarray",
    "gfg": "find-subarray-with-given-sum",
    "leetid": 53,
    "content": "---\nlayout: post\ntitle: Maximum Subarray\ntopics: [array, divide-and-conquer, dynamic-programming]\nlangs: [java, cpp, py, go]\ntc: O(n)\nsc: O(n)\nleetid: 53\ncompanies: [facebook]\ngfg: find-subarray-with-given-sum\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: maximum-subarray\n---\nGiven an integer array `nums`, find the `subarray` with the largest sum, and return *its sum*.\n \n---\n## How to Solve:\n\nThe idea of Kadane's algorithm is to traverse over the array from left to right and for each element, \nfind the maximum sum among all subarrays ending at that element. The result will be the maximum of all these values.\n\nBut, the main issue is how to calculate maximum sum among all the subarrays ending at an element in O(N) time?\n\nTo calculate the maximum sum of subarray ending at current element, say maxEnding, \nwe can use the maximum sum ending at the previous element. So for any element, we have two choices:\n\n* Choice 1: Extend the maximum sum subarray ending at the previous element by adding the current element to it. \nIf the maximum subarray sum ending at the previous index is positive, then it is always better to extend the subarray.\n* Choice 2: Start a new subarray starting from the current element. \n* If the maximum subarray sum ending at the previous index is negative, \n* it is always better to start a new subarray from the current element.\n\nThis means that maxEnding at index `i = max(maxEnding at index (i - 1) + arr[i], arr[i])` \nand the maximum value of `maxEnding` at any index will be our answer.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n**Example 2:**\n```\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n**Example 3:**\n```\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 10<sup>5</sup>`\n\t\n* `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`\n \n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.\n\n        ",
    "body": "Given an integer array `nums`, find the `subarray` with the largest sum, and return *its sum*.\n \n---\n## How to Solve:\n\nThe idea of Kadane's algorithm is to traverse over the array from left to right and for each element, \nfind the maximum sum among all subarrays ending at that element. The result will be the maximum of all these values.\n\nBut, the main issue is how to calculate maximum sum among all the subarrays ending at an element in O(N) time?\n\nTo calculate the maximum sum of subarray ending at current element, say maxEnding, \nwe can use the maximum sum ending at the previous element. So for any element, we have two choices:\n\n* Choice 1: Extend the maximum sum subarray ending at the previous element by adding the current element to it. \nIf the maximum subarray sum ending at the previous index is positive, then it is always better to extend the subarray.\n* Choice 2: Start a new subarray starting from the current element. \n* If the maximum subarray sum ending at the previous index is negative, \n* it is always better to start a new subarray from the current element.\n\nThis means that maxEnding at index `i = max(maxEnding at index (i - 1) + arr[i], arr[i])` \nand the maximum value of `maxEnding` at any index will be our answer.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n**Example 2:**\n```\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n**Example 3:**\n```\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 10<sup>5</sup>`\n\t\n* `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`\n \n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.\n\n        ",
    "solutions": {}
  },
  "maximum-width-of-binary-tree": {
    "id": "maximum-width-of-binary-tree",
    "title": "Maximum Width of Binary Tree",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "binary-tree",
      "depth-first-search",
      "tree"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(h)",
    "sc": "O(1)",
    "leetcode": "maximum-width-of-binary-tree",
    "gfg": null,
    "leetid": 662,
    "content": "---\nlayout: post\ntitle: Maximum Width of Binary Tree\ntopics: [binary-tree, depth-first-search, tree]\nlangs: [java, py]\ntc: O(h)\nsc: O(1)\nleetid: 662\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: maximum-width-of-binary-tree\n---\n\nGiven the root of a binary tree, return the **_maximum width_** of the given tree.\n\nThe **maximum width** of a tree is the maximum width among all levels.\n\nThe **width** of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.\n\nIt is guaranteed that the answer will in the range of 32-bit signed integer.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [1,3,null,5,3]\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n    1\n   / \\\n  3   2\n / \\   \\\n5   3   9\n```\n\n**Example 2:** \n```\nInput: root = [1,3,2,5]\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n    1\n   / \\\n  3   2\n /\n5\n```\n",
    "body": "Given the root of a binary tree, return the **_maximum width_** of the given tree.\n\nThe **maximum width** of a tree is the maximum width among all levels.\n\nThe **width** of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation.\n\nIt is guaranteed that the answer will in the range of 32-bit signed integer.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [1,3,null,5,3]\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n    1\n   / \\\n  3   2\n / \\   \\\n5   3   9\n```\n\n**Example 2:** \n```\nInput: root = [1,3,2,5]\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n    1\n   / \\\n  3   2\n /\n5\n```\n",
    "solutions": {}
  },
  "median-of-two-sorted-arrays": {
    "id": "median-of-two-sorted-arrays",
    "title": "Median of Two Sorted Arrays",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "binary-search",
      "divide-and-conquer"
    ],
    "langs": [
      "java",
      "cpp",
      "py",
      "kt",
      "ts"
    ],
    "tc": "O(log(m+n))",
    "sc": "O(1)",
    "leetcode": "median-of-two-sorted-arrays",
    "gfg": "median-of-two-sorted-arrays-of-different-sizes",
    "leetid": 4,
    "content": "---\nlayout: post\ntitle: Median of Two Sorted Arrays\ntopics: [array, binary-search, divide-and-conquer]\nlangs: [java, cpp, py, kt, ts]\ntc: O(log(m+n))\nsc: O(1)\nleetid: 4\ngfg: median-of-two-sorted-arrays-of-different-sizes\ncompanies: [facebook]\ndifficulty: hard\nhackerrank: \ninterviewbit: \nleetcode: median-of-two-sorted-arrays\n---\n\nGiven two sorted arrays, a[] and b[], the task is to find the median of these sorted arrays, in `O(log n + log m)` time complexity, \nwhen n is the number of elements in the first array, and m is the number of elements in the second array.\n\n---\n## How to Solve\n\n1. Let assume that there are two arrays `A` and `B` with array `A` having the minimum number of elements.\n   If this is not the case than swap `A` and `B` to make `A` having small size.\n2. The edge cases like one array is empty or both are empty will be handled.\n   1. let `n` be the size of `A` and `m` be the size of `B`. \n   2. Now think of an idea that if we have to find the median than we have to divide the whole merged array into two parts\n   namely `left` and `right` parts. \n   3. Now since we are given the size of left part (i.e (n+m+1)/2), Now look at below given example.\n      ```\n      A-> 1,2,3,4,5     n = 5\n      B-> 1,2,3,4,5,6   m = 6\n      ```\n\n      Here merged array will look like :- <span style={{color:'orange'}}>1,1,2,2,3</span>,3,<span style={{color:'green'}}>4,4,5,5,6</span> \n      and median then is `3`\n   \n   4. Now we can see our left part which is in <span style={{color:'orange'}}>orange</span>. \n   5. We divide A and B into two parts such that the sum of left part of both A and B will result in left part of merged array.\n      ```\n      A-> 1,2,3,4,5     // pointers l =0 and r = n-1 hence mid = (l+r)/2;\n      B -> 1,2,3,4,5,6\n      ```\n      we can see that left part of A is given as `n/2` and since total length of left part in merged array\n      is `(m+n+1)/2`, so left part of B = `(m+n+1)/2-n/2`;\n\n      Now we just have to confirm if our left and right partitions in `A` and `B` are correct or not.\n\n3. Now we have 4 variables indicating four values two from array A and two from array B.\n   ```   \n   leftA -> Rightmost element in left part of A = 2\n   leftb -> Rightmost element in left part of B = 4\n   rightA -> Leftmost element in right part of A = 3\n   rightB -> Leftmost element in right part of B = 5\n   ```\n\n   Hence to confirm that partition is correct we have to check the following conditions.\n\n   `leftA<=rightB` and `leftB<=rightA`  // This is the case when the sum of two parts of A and B results in left part of merged array\n\n   if our partition not works that means we have to  find other mid point in A and then left part in B\n   This is seen when\n   ```\n   leftA > rightB    //means we have to dec size of A's partition\n   so do r = mid-1;\n   else\n   do l =mid+1;\n   ```\n\n   Hence repeat the above steps with new partitions till we get the answers.\n\n4. If `leftA<=rightB` and `leftB<=rightA`\n   then we get correct partition and our answer depends on the total size of merged array (i.e. m+n)\n   ```\n   If (m+n)%2==0\n   ans is max(leftA,leftB)+min(rightA,rightB)/2; // max of left part is nearest to median and min of right part is nearest to medain\n   else\n   ans is max(leftA,leftB);\n   ```\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n**Example 2:**\n```\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```",
    "body": "Given two sorted arrays, a[] and b[], the task is to find the median of these sorted arrays, in `O(log n + log m)` time complexity, \nwhen n is the number of elements in the first array, and m is the number of elements in the second array.\n\n---\n## How to Solve\n\n1. Let assume that there are two arrays `A` and `B` with array `A` having the minimum number of elements.\n   If this is not the case than swap `A` and `B` to make `A` having small size.\n2. The edge cases like one array is empty or both are empty will be handled.\n   1. let `n` be the size of `A` and `m` be the size of `B`. \n   2. Now think of an idea that if we have to find the median than we have to divide the whole merged array into two parts\n   namely `left` and `right` parts. \n   3. Now since we are given the size of left part (i.e (n+m+1)/2), Now look at below given example.\n      ```\n      A-> 1,2,3,4,5     n = 5\n      B-> 1,2,3,4,5,6   m = 6\n      ```\n\n      Here merged array will look like :- <span style={{color:'orange'}}>1,1,2,2,3</span>,3,<span style={{color:'green'}}>4,4,5,5,6</span> \n      and median then is `3`\n   \n   4. Now we can see our left part which is in <span style={{color:'orange'}}>orange</span>. \n   5. We divide A and B into two parts such that the sum of left part of both A and B will result in left part of merged array.\n      ```\n      A-> 1,2,3,4,5     // pointers l =0 and r = n-1 hence mid = (l+r)/2;\n      B -> 1,2,3,4,5,6\n      ```\n      we can see that left part of A is given as `n/2` and since total length of left part in merged array\n      is `(m+n+1)/2`, so left part of B = `(m+n+1)/2-n/2`;\n\n      Now we just have to confirm if our left and right partitions in `A` and `B` are correct or not.\n\n3. Now we have 4 variables indicating four values two from array A and two from array B.\n   ```   \n   leftA -> Rightmost element in left part of A = 2\n   leftb -> Rightmost element in left part of B = 4\n   rightA -> Leftmost element in right part of A = 3\n   rightB -> Leftmost element in right part of B = 5\n   ```\n\n   Hence to confirm that partition is correct we have to check the following conditions.\n\n   `leftA<=rightB` and `leftB<=rightA`  // This is the case when the sum of two parts of A and B results in left part of merged array\n\n   if our partition not works that means we have to  find other mid point in A and then left part in B\n   This is seen when\n   ```\n   leftA > rightB    //means we have to dec size of A's partition\n   so do r = mid-1;\n   else\n   do l =mid+1;\n   ```\n\n   Hence repeat the above steps with new partitions till we get the answers.\n\n4. If `leftA<=rightB` and `leftB<=rightA`\n   then we get correct partition and our answer depends on the total size of merged array (i.e. m+n)\n   ```\n   If (m+n)%2==0\n   ans is max(leftA,leftB)+min(rightA,rightB)/2; // max of left part is nearest to median and min of right part is nearest to medain\n   else\n   ans is max(leftA,leftB);\n   ```\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n**Example 2:**\n```\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```",
    "solutions": {}
  },
  "meeting-rooms-ii": {
    "id": "meeting-rooms-ii",
    "title": "Meeting Rooms II",
    "difficulty": "medium",
    "companies": [
      "facebook",
      "amazon",
      "apple",
      "microsoft"
    ],
    "topics": [
      "array",
      "greedy",
      "sorting"
    ],
    "langs": [
      "java",
      "py",
      "cpp",
      "go",
      "ts"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "meeting-rooms-ii",
    "gfg": "attend-all-meetings-ii",
    "leetid": 253,
    "content": "---\nlayout: post\ntitle: Meeting Rooms II\ntopics: [array, greedy, sorting]\nlangs: [java, py, cpp, go, ts]\ntc: O(n)\nsc: O(n)\nleetid: 253\ndifficulty: medium\ncompanies: [facebook, amazon, apple, microsoft]\ngfg: attend-all-meetings-ii\nhackerrank: \ninterviewbit: meeting-rooms\nleetcode: meeting-rooms-ii\n---\n\nGiven an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.\nA conference room is available if it is not occupied by any meeting at the time of the new meeting.\n\n---\n## How it works\n1. **Initialize a Large Array:** `delta = [0] * 1000010` creates an array (or list in Python terms) of size 1,000,010, initialized with zeros. \nThis array acts as a map, where the index represents a time point and the value at each index represents the net change in the number of ongoing meetings at that time.\n2. **Populate the delta Array:** For each meeting defined by its `start` and `end` times, the code increments the value at the start index by 1 and decrements the value at the end index by 1 in the delta array.\nThis increment and decrement operation effectively marks the beginning and end of a meeting, respectively. The positive value at the start time indicates new meetings starting, and the negative value at the end time indicates meetings ending.\n3. **Accumulate Changes:** The expression accumulate(delta) computes the cumulative sum of the delta array. This step calculates the net number of meetings ongoing at each time point, based on the previously marked start and end times.\nAfter accumulation, each value in the delta array represents the total number of meetings ongoing at the corresponding time point.\n4. **Find the Maximum Value:** The maximum value in the accumulated delta array represents the peak number of simultaneous meetings. \nThis peak value is the minimum number of conference rooms needed to accommodate all meetings without any overlap.\n\n---\n## Test Cases\n**Example 1:** \n```\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2\nExplanation:\n- Room 1 is occupied from 0 to 30.\n- Room 2 is occupied from 5 to 10.\n- Room 2 is occupied from 15 to 20.\n```\n\n**Example 2:** \n```\nInput: intervals = [[7,10],[2,4]]\nOutput: 1\nExplanation:\n- Room 1 is occupied from 2 to 4.\n- Room 1 is occupied from 7 to 10.\n```\n",
    "body": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.\nA conference room is available if it is not occupied by any meeting at the time of the new meeting.\n\n---\n## How it works\n1. **Initialize a Large Array:** `delta = [0] * 1000010` creates an array (or list in Python terms) of size 1,000,010, initialized with zeros. \nThis array acts as a map, where the index represents a time point and the value at each index represents the net change in the number of ongoing meetings at that time.\n2. **Populate the delta Array:** For each meeting defined by its `start` and `end` times, the code increments the value at the start index by 1 and decrements the value at the end index by 1 in the delta array.\nThis increment and decrement operation effectively marks the beginning and end of a meeting, respectively. The positive value at the start time indicates new meetings starting, and the negative value at the end time indicates meetings ending.\n3. **Accumulate Changes:** The expression accumulate(delta) computes the cumulative sum of the delta array. This step calculates the net number of meetings ongoing at each time point, based on the previously marked start and end times.\nAfter accumulation, each value in the delta array represents the total number of meetings ongoing at the corresponding time point.\n4. **Find the Maximum Value:** The maximum value in the accumulated delta array represents the peak number of simultaneous meetings. \nThis peak value is the minimum number of conference rooms needed to accommodate all meetings without any overlap.\n\n---\n## Test Cases\n**Example 1:** \n```\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2\nExplanation:\n- Room 1 is occupied from 0 to 30.\n- Room 2 is occupied from 5 to 10.\n- Room 2 is occupied from 15 to 20.\n```\n\n**Example 2:** \n```\nInput: intervals = [[7,10],[2,4]]\nOutput: 1\nExplanation:\n- Room 1 is occupied from 2 to 4.\n- Room 1 is occupied from 7 to 10.\n```\n",
    "solutions": {}
  },
  "merge-k-sorted-lists": {
    "id": "merge-k-sorted-lists",
    "title": "Merge k Sorted Lists",
    "difficulty": "hard",
    "companies": [
      "airbnb",
      "facebook",
      "google",
      "uber",
      "linkedin"
    ],
    "topics": [
      "linked-list",
      "divide-and-conquer",
      "heap-priority-queue",
      "merge-sort"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(k)",
    "leetcode": "merge-k-sorted-lists",
    "gfg": "merge-k-sorted-linked-lists",
    "leetid": 23,
    "content": "---\nlayout: post\ntitle: Merge k Sorted Lists\ndifficulty: hard\ntopics: [linked-list, divide-and-conquer, heap-priority-queue, merge-sort]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(k)\ncompanies: [airbnb, facebook, google, uber, linkedin]\nleetid: 23\nleetcode: merge-k-sorted-lists\ngfg: merge-k-sorted-linked-lists\ninterviewbit: merge-k-sorted-lists\nhackerrank: merge-two-sorted-linked-lists\nhellointerview: code/heap/merge-k-sorted-lists\n---\nYou are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n*Merge all the linked-lists into one sorted linked-list and return it.*\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n```\n**Example 2:**\n```\nInput: lists = []\nOutput: []\n```\n**Example 3:**\n```\nInput: lists = [[]]\nOutput: []\n```\n \n**Constraints:**\n\t\n* `k == lists.length`\n\t\n* `0 <= k <= 10<sup>4</sup>`\n\t\n* `0 <= lists[i].length <= 500`\n\t\n* `-10<sup>4</sup> <= lists[i][j] <= 10<sup>4</sup>`\n\t\n* `lists[i]` is sorted in **ascending order**.\n\t\n* The sum of `lists[i].length` will not exceed `10<sup>4</sup>`.\n\n",
    "body": "You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.\n*Merge all the linked-lists into one sorted linked-list and return it.*\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n```\n**Example 2:**\n```\nInput: lists = []\nOutput: []\n```\n**Example 3:**\n```\nInput: lists = [[]]\nOutput: []\n```\n \n**Constraints:**\n\t\n* `k == lists.length`\n\t\n* `0 <= k <= 10<sup>4</sup>`\n\t\n* `0 <= lists[i].length <= 500`\n\t\n* `-10<sup>4</sup> <= lists[i][j] <= 10<sup>4</sup>`\n\t\n* `lists[i]` is sorted in **ascending order**.\n\t\n* The sum of `lists[i].length` will not exceed `10<sup>4</sup>`.\n\n",
    "solutions": {}
  },
  "min-cost-to-connect-all-points": {
    "id": "min-cost-to-connect-all-points",
    "title": "Min Cost to Connect All Points",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "graph"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(1)",
    "sc": "O(1)",
    "leetcode": "min-cost-to-connect-all-points",
    "gfg": null,
    "leetid": 1584,
    "content": "---\nlayout: post\ntitle: Min Cost to Connect All Points\ntopics: [array, graph]\nlangs: [java]\ntc: O(1)\nsc: O(1)\nleetid: 1584\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: min-cost-to-connect-all-points\n---\n\nYou are given an array points representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the manhattan distance between them: \n```|xi - xj| + |yi - yj|```\nwhere `|val|` denotes the absolute value of `val`.\n\nReturn the minimum cost to make all points connected. All points are connected if there is **exactly one** simple path between any two points.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<div style={{backgroundColor: 'white', width: 'auto'}}>\n    <img src=\"/assets/img/code/min-cost.png\" alt=\"\" />\n    <img src=\"/assets/img/code/min-cost2.png\" alt=\"\" />\n</div>\n\n```\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation: \n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n```\n\n**Example 2:** \n```\nInput: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18\n```",
    "body": "You are given an array points representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the manhattan distance between them: \n```|xi - xj| + |yi - yj|```\nwhere `|val|` denotes the absolute value of `val`.\n\nReturn the minimum cost to make all points connected. All points are connected if there is **exactly one** simple path between any two points.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n<div style={{backgroundColor: 'white', width: 'auto'}}>\n    <img src=\"/assets/img/code/min-cost.png\" alt=\"\" />\n    <img src=\"/assets/img/code/min-cost2.png\" alt=\"\" />\n</div>\n\n```\nInput: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation: \n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n```\n\n**Example 2:** \n```\nInput: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18\n```",
    "solutions": {}
  },
  "minimize-deviation-in-array": {
    "id": "minimize-deviation-in-array",
    "title": "Minimize Deviation in Array",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "greedy",
      "heap"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "minimize-deviation-in-array",
    "gfg": null,
    "leetid": 1675,
    "content": "---\nlayout: post\ntitle: Minimize Deviation in Array\ntopics: [array, greedy, heap]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 1675\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: minimize-deviation-in-array\n---\n\nYou are given an array nums of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number of times:\n\n- If the element is **even, divide it by 2**. \nFor example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2]`.\n- If the element is **odd, multiply it by 2**.\nFor example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4]`.\n\nThe **deviation** of the array is the **maximum difference** between any two elements in the array.\n\nReturn the minimum deviation the array can have after performing some number of operations.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) nums = [1,2,3,4]\n```\n\n**Output:**\n```\n(int) 1\n```\n\n**Explanation:**\n```\nYou can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [4,1,5,20,3]\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nYou can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.\n```\n",
    "body": "You are given an array nums of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number of times:\n\n- If the element is **even, divide it by 2**. \nFor example, if the array is `[1,2,3,4]`, then you can do this operation on the last element, and the array will be `[1,2,3,2]`.\n- If the element is **odd, multiply it by 2**.\nFor example, if the array is `[1,2,3,4]`, then you can do this operation on the first element, and the array will be `[2,2,3,4]`.\n\nThe **deviation** of the array is the **maximum difference** between any two elements in the array.\n\nReturn the minimum deviation the array can have after performing some number of operations.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) nums = [1,2,3,4]\n```\n\n**Output:**\n```\n(int) 1\n```\n\n**Explanation:**\n```\nYou can transform the array to [1,2,3,2], then to [2,2,3,2], then the deviation will be 3 - 2 = 1.\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [4,1,5,20,3]\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nYou can transform the array after two operations to [4,2,5,5,3], then the deviation will be 5 - 2 = 3.\n```\n",
    "solutions": {}
  },
  "minimum-cost-for-tickets": {
    "id": "minimum-cost-for-tickets",
    "title": "Minimum Cost for Tickets",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(N)",
    "sc": "O(N)",
    "leetcode": "minimum-cost-for-tickets",
    "gfg": null,
    "leetid": 983,
    "content": "---\nlayout: post\ntitle: Minimum Cost for Tickets\ntopics: [array, dynamic-programming]\nlangs: [java]\ntc: O(N)\nsc: O(N)\nleetid: 983\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: minimum-cost-for-tickets\n---\n\nYou have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from `1` to `365`.\n\nTrain tickets are sold in three different ways:\n\na **1-day** pass is sold for `costs[0]` dollars,\na **7-day** pass is sold for `costs[1]` dollars, and\na **30-day** pass is sold for `costs[2]` dollars.\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day `2`, then we can travel for 7 days: `2, 3, 4, 5, 6, 7, and 8`.\nReturn the _minimum number of dollars you need to travel every day in the given list of days._\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n```\n\n**Example 2:** \n```\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n```",
    "body": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from `1` to `365`.\n\nTrain tickets are sold in three different ways:\n\na **1-day** pass is sold for `costs[0]` dollars,\na **7-day** pass is sold for `costs[1]` dollars, and\na **30-day** pass is sold for `costs[2]` dollars.\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day `2`, then we can travel for 7 days: `2, 3, 4, 5, 6, 7, and 8`.\nReturn the _minimum number of dollars you need to travel every day in the given list of days._\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n```\n\n**Example 2:** \n```\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n```",
    "solutions": {}
  },
  "minimum-remove-to-make-valid-parentheses": {
    "id": "minimum-remove-to-make-valid-parentheses",
    "title": "Minimum Remove to Make Valid Parentheses",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "stack",
      "string"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "minimum-remove-to-make-valid-parentheses",
    "gfg": null,
    "leetid": 1249,
    "content": "---\nlayout: post\ntitle: Minimum Remove to Make Valid Parentheses\ntopics: [stack, string]\nlangs: [java, py, cpp]\ntc: O(n)\nsc: O(n)\nleetid: 1249\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: minimum-remove-to-make-valid-parentheses\n---\n\nGiven a string s of `'('` , `')'` and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) \nso that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n- It is the empty string, contains only lowercase characters, or\n- It can be written as `AB` (A concatenated with B), where A and B are valid strings, or\n- It can be written as `(A)`, where A is a valid string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n```\n\n**Example 2:** \n```\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.\n```",
    "body": "Given a string s of `'('` , `')'` and lowercase English characters.\n\nYour task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) \nso that the resulting parentheses string is valid and return any valid string.\n\nFormally, a parentheses string is valid if and only if:\n- It is the empty string, contains only lowercase characters, or\n- It can be written as `AB` (A concatenated with B), where A and B are valid strings, or\n- It can be written as `(A)`, where A is a valid string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"lee(t(c)o)de)\"\nOutput: \"lee(t(c)o)de\"\nExplanation: \"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.\n```\n\n**Example 2:** \n```\nInput: s = \"))((\"\nOutput: \"\"\nExplanation: An empty string is also valid.\n```",
    "solutions": {}
  },
  "minimum-size-subarray-sum": {
    "id": "minimum-size-subarray-sum",
    "title": "Minimum Size Subarray Sum",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "binary-search",
      "sliding-window",
      "prefix-sum"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "minimum-size-subarray-sum",
    "gfg": null,
    "leetid": 209,
    "content": "---\nlayout: post\ntitle: Minimum Size Subarray Sum\ndifficulty: medium\ntopics: [array, binary-search, sliding-window, prefix-sum]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\ncompanies: [facebook]\nleetid: 209\nleetcode: minimum-size-subarray-sum\ngfg: \ninterviewbit: \nhackerrank: \n---\nGiven an array of positive integers `nums` and a positive integer `target`, return *the **minimal length** of a *<span data-keyword=\"subarray-nonempty\">*subarray*</span>* whose sum is greater than or equal to* `target`. If there is no such subarray, return `0` instead.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n```\n\n**Example 2:**\n```\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n```\n \n**Constraints:**\n* `1 <= target <= 10<sup>9</sup>`\n* `1 <= nums.length <= 10<sup>5</sup>`\n* `1 <= nums[i] <= 10<sup>4</sup>`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`.\n",
    "body": "Given an array of positive integers `nums` and a positive integer `target`, return *the **minimal length** of a *<span data-keyword=\"subarray-nonempty\">*subarray*</span>* whose sum is greater than or equal to* `target`. If there is no such subarray, return `0` instead.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n```\n\n**Example 2:**\n```\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n```\n\n**Example 3:**\n```\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n```\n \n**Constraints:**\n* `1 <= target <= 10<sup>9</sup>`\n* `1 <= nums.length <= 10<sup>5</sup>`\n* `1 <= nums[i] <= 10<sup>4</sup>`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`.\n",
    "solutions": {}
  },
  "minimum-sum-partition": {
    "id": "minimum-sum-partition",
    "title": "Minimum sum partition",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": null,
    "gfg": null,
    "content": "---\nlayout: post\ntitle: Minimum sum partition\ntopics: [array, dynamic-programming]\nlangs: [java]\ntc: O(n)\nsc: O(n)\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nGiven an integer array arr of size N, \nthe task is to divide it into two sets `S1` and `S2` such that the absolute difference between their sums is minimum and find the minimum difference\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: N = 4, arr[] = {1, 6, 11, 5} \nOutput: 1\nExplanation: \nSubset1 = {1, 5, 6}, sum of Subset1 = 12 \nSubset2 = {11}, sum of Subset2 = 11   \n```\n\n**Example 2:** \n```\nInput: N = 2, arr[] = {1, 4}\nOutput: 3\nExplanation: \nSubset1 = {1}, sum of Subset1 = 1\nSubset2 = {4}, sum of Subset2 = 4\n```",
    "body": "Given an integer array arr of size N, \nthe task is to divide it into two sets `S1` and `S2` such that the absolute difference between their sums is minimum and find the minimum difference\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: N = 4, arr[] = {1, 6, 11, 5} \nOutput: 1\nExplanation: \nSubset1 = {1, 5, 6}, sum of Subset1 = 12 \nSubset2 = {11}, sum of Subset2 = 11   \n```\n\n**Example 2:** \n```\nInput: N = 2, arr[] = {1, 4}\nOutput: 3\nExplanation: \nSubset1 = {1}, sum of Subset1 = 1\nSubset2 = {4}, sum of Subset2 = 4\n```",
    "solutions": {}
  },
  "minimum-window-substring": {
    "id": "minimum-window-substring",
    "title": "Minimum Window Substring",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "hash-table",
      "sliding-window",
      "string"
    ],
    "langs": [
      "java",
      "cpp",
      "py",
      "c",
      "kt"
    ],
    "tc": "O(n+m)",
    "sc": "O(n+m)",
    "leetcode": "minimum-window-substring",
    "gfg": "find-the-smallest-window-in-a-string-containing-all-characters-of-another-string",
    "leetid": 76,
    "content": "---\nlayout: post\ntitle: Minimum Window Substring\ncategory: hard\ntopics: [hash-table, sliding-window, string]\nlangs: [java, cpp, py, c, kt]\ntc: O(n+m)\nsc: O(n+m)\nleetid: 76\ngfg: find-the-smallest-window-in-a-string-containing-all-characters-of-another-string\ncompanies: [facebook]\ndifficulty: hard\nhackerrank: \ninterviewbit: \nleetcode: minimum-window-substring\n---\n\nGiven two strings `s` and `t` of lengths `m` and `n` respectively, \nreturn the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. \nIf there is no such substring, return the empty string `\"\"`.\n\n**A substring is a contiguous sequence of characters within the string**.\n\n---\n## How to Solve\n\nThe question asks us to return the minimum window from the string `S` which has all the characters of the string `T`. \nLet us call a window desirable if it has all the characters from `T`.\n\nWe can use a simple sliding window approach to solve this problem.\nIn any sliding window based problem we have two pointers. One `right` pointer whose job is to expand the current window, \nand then we have the `left` pointer whose job is to contract a given window. \nAt any point in time only one of these pointers move and the other one remains fixed.\n\nThe solution is pretty intuitive. We keep expanding the window by moving the right pointer. \nWhen the window has all the desired characters, we contract (if possible) and save the smallest window till now.\n\nThe answer is the smallest desirable window.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n```\n\n**Example 2:**\n```\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n```\n\n**Example 3:**\n```\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n```",
    "body": "Given two strings `s` and `t` of lengths `m` and `n` respectively, \nreturn the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. \nIf there is no such substring, return the empty string `\"\"`.\n\n**A substring is a contiguous sequence of characters within the string**.\n\n---\n## How to Solve\n\nThe question asks us to return the minimum window from the string `S` which has all the characters of the string `T`. \nLet us call a window desirable if it has all the characters from `T`.\n\nWe can use a simple sliding window approach to solve this problem.\nIn any sliding window based problem we have two pointers. One `right` pointer whose job is to expand the current window, \nand then we have the `left` pointer whose job is to contract a given window. \nAt any point in time only one of these pointers move and the other one remains fixed.\n\nThe solution is pretty intuitive. We keep expanding the window by moving the right pointer. \nWhen the window has all the desired characters, we contract (if possible) and save the smallest window till now.\n\nThe answer is the smallest desirable window.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n```\n\n**Example 2:**\n```\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n```\n\n**Example 3:**\n```\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n```",
    "solutions": {}
  },
  "multiply-strings": {
    "id": "multiply-strings",
    "title": "Multiply Strings",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "math",
      "string",
      "simulation"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(nm)",
    "sc": "O(nm)",
    "leetcode": "multiply-strings",
    "gfg": "multiply-large-numbers-represented-as-strings",
    "leetid": 43,
    "content": "---\nlayout: post\ntitle: Multiply Strings\ntopics: [math, string, simulation]\nlangs: [java, py, cpp]\ntc: O(nm)\nsc: O(nm)\nleetid: 43\ncompanies: [facebook]\ngfg: multiply-large-numbers-represented-as-strings\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: multiply-strings\n---\nGiven two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n```\n\n**Example 2:**\n```\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n```\n \n**Constraints:**\n\t\n* `1 <= num1.length, num2.length <= 200`\n\t\n* `num1` and `num2` consist of digits only.\n\t\n* Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.\n\n        ",
    "body": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n```\n\n**Example 2:**\n```\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n```\n \n**Constraints:**\n\t\n* `1 <= num1.length, num2.length <= 200`\n\t\n* `num1` and `num2` consist of digits only.\n\t\n* Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.\n\n        ",
    "solutions": {}
  },
  "next-permutation": {
    "id": "next-permutation",
    "title": "Next Permutation",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "two-pointers"
    ],
    "langs": [
      "java",
      "py",
      "go",
      "cpp",
      "c"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "next-permutation",
    "gfg": null,
    "leetid": 31,
    "content": "---\nlayout: post\ntitle: Next Permutation\ntopics: [array, two-pointers]\nlangs: [java, py, go, cpp, c]\ntc: O(n)\nsc: O(1)\nleetid: 31\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: next-permutation\n---\n\nA permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n- For example, for `arr = [1,2,3]`, the following are considered permutations of `arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]`.\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. \nMore formally, if all the permutations of the array are sorted in one container according to their lexicographical order, \nthen the next permutation of that array is the permutation that follows it in the sorted container.\nIf such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n- For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n- Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n- While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n---\n\n## How to Solve\n\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\nFor example, no next permutation is possible for the array: `[9, 5, 4, 3, 1]`.\n\nWe need to find the first pair of two successive numbers `a[i]` and `a[i1]`, \nfrom the right, which satisfy `a[i] > a[i-1]`.\n\nNow, no rearrangements to the right of `a[i-1]` can create a larger permutation since that subarray consists of numbers in descending order.\nThus, we need to rearrange the numbers to the right of `a[i1]` including itself.\n\nNow, what kind of rearrangement will produce the next larger number?\n\nWe want to create the permutation just larger than the current one.\nTherefore, we need to replace the number `a[i-1]` with the number which is just larger than itself among the numbers lying to its right section, say `a[j]`.\n\n<MdxImage src=\"code/nextpermutation.png\" alt=\"Next Permutation\" />\n\nWe swap the numbers `a[i-1]` and `a[j]`. We now have the correct number at index `i-1`.\nBut still the current permutation isn't the permutation that we are looking for.\nWe need the smallest permutation that can be formed by using the numbers only to the right of `a[i-1]`.\nTherefore, we need to place those numbers in ascending order to get their smallest permutation.\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair `a[i]` and `a[i-1]` where, `a[i] > a[i-1]`.\nThus, all numbers to the right of `a[i1]` were already sorted in descending order.\nFurthermore, swapping `a[i-1]` and `a[j]` didn't change that order.\nTherefore, we simply need to reverse the numbers following `a[i-1]` to get the next smallest lexicographic permutation.\n\n---\n## Test Cases\n\n**Input:**\n\n      (int[]) nums = [1,2,3]\n\n**Output:**\n\n      (int[]) [1,3,2]\n\n---\n\n**Input:**\n\n      (int[]) nums = [3,2,1]\n\n**Output:**\n\n      (int[]) [1,2,3]\n\n---",
    "body": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n- For example, for `arr = [1,2,3]`, the following are considered permutations of `arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]`.\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. \nMore formally, if all the permutations of the array are sorted in one container according to their lexicographical order, \nthen the next permutation of that array is the permutation that follows it in the sorted container.\nIf such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n- For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n- Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n- While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n---\n\n## How to Solve\n\nFirst, we observe that for any given sequence that is in descending order, no next larger permutation is possible.\nFor example, no next permutation is possible for the array: `[9, 5, 4, 3, 1]`.\n\nWe need to find the first pair of two successive numbers `a[i]` and `a[i1]`, \nfrom the right, which satisfy `a[i] > a[i-1]`.\n\nNow, no rearrangements to the right of `a[i-1]` can create a larger permutation since that subarray consists of numbers in descending order.\nThus, we need to rearrange the numbers to the right of `a[i1]` including itself.\n\nNow, what kind of rearrangement will produce the next larger number?\n\nWe want to create the permutation just larger than the current one.\nTherefore, we need to replace the number `a[i-1]` with the number which is just larger than itself among the numbers lying to its right section, say `a[j]`.\n\n<MdxImage src=\"code/nextpermutation.png\" alt=\"Next Permutation\" />\n\nWe swap the numbers `a[i-1]` and `a[j]`. We now have the correct number at index `i-1`.\nBut still the current permutation isn't the permutation that we are looking for.\nWe need the smallest permutation that can be formed by using the numbers only to the right of `a[i-1]`.\nTherefore, we need to place those numbers in ascending order to get their smallest permutation.\n\nBut, recall that while scanning the numbers from the right, we simply kept decrementing the index until we found the pair `a[i]` and `a[i-1]` where, `a[i] > a[i-1]`.\nThus, all numbers to the right of `a[i1]` were already sorted in descending order.\nFurthermore, swapping `a[i-1]` and `a[j]` didn't change that order.\nTherefore, we simply need to reverse the numbers following `a[i-1]` to get the next smallest lexicographic permutation.\n\n---\n## Test Cases\n\n**Input:**\n\n      (int[]) nums = [1,2,3]\n\n**Output:**\n\n      (int[]) [1,3,2]\n\n---\n\n**Input:**\n\n      (int[]) nums = [3,2,1]\n\n**Output:**\n\n      (int[]) [1,2,3]\n\n---",
    "solutions": {}
  },
  "number-of-islands": {
    "id": "number-of-islands",
    "title": "Number of Islands",
    "difficulty": "medium",
    "companies": [
      "google",
      "facebook"
    ],
    "topics": [
      "array",
      "depth-first-search",
      "breadth-first-search",
      "union-find",
      "matrix"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(mn)",
    "sc": "O(1)",
    "leetcode": "number-of-islands",
    "gfg": null,
    "leetid": 200,
    "content": "---\nlayout: post\ntitle: Number of Islands\ntopics: [array, depth-first-search, breadth-first-search, union-find, matrix]\nlangs: [java, py, cpp]\ntc: O(mn)\nsc: O(1)\nleetid: 200\ncompanies: [google, facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: number-of-islands\n---\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n```\n**Example 2:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n```\n \n**Constraints:**\n\t\n* `m == grid.length`\n\t\n* `n == grid[i].length`\n\t\n* `1 <= m, n <= 300`\n\t\n* `grid[i][j]` is `'0'` or `'1'`.\n\n        ",
    "body": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n```\n**Example 2:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n```\n \n**Constraints:**\n\t\n* `m == grid.length`\n\t\n* `n == grid[i].length`\n\t\n* `1 <= m, n <= 300`\n\t\n* `grid[i][j]` is `'0'` or `'1'`.\n\n        ",
    "solutions": {}
  },
  "palindrome-partitioning-ii": {
    "id": "palindrome-partitioning-ii",
    "title": "Palindrome Partitioning II",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "dynamic-programming",
      "string"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n<sup>2</sup>)",
    "sc": "O(n<sup>2</sup>)",
    "leetcode": "palindrome-partitioning-ii",
    "gfg": null,
    "leetid": 132,
    "content": "---\nlayout: post\ntitle: Palindrome Partitioning II\ntopics: [dynamic-programming, string]\nlangs: [java, cpp]\ntc: O(n<sup>2</sup>)\nsc: O(n<sup>2</sup>)\nleetid: 132\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: palindrome-partitioning-ii\n---\n\nGiven a string s, partition s such that every substring of the partition is a palindrome.\n\nReturn the minimum cuts needed for a palindrome partitioning of `s`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n```\n\n**Example 2:**\n```\nInput: s = \"abaa\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aba\",\"a\"] could be produced using 1 cut.\n```",
    "body": "Given a string s, partition s such that every substring of the partition is a palindrome.\n\nReturn the minimum cuts needed for a palindrome partitioning of `s`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n```\n\n**Example 2:**\n```\nInput: s = \"abaa\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aba\",\"a\"] could be produced using 1 cut.\n```",
    "solutions": {}
  },
  "palindrome-partitioning": {
    "id": "palindrome-partitioning",
    "title": "Palindrome Partitioning",
    "difficulty": "hard",
    "companies": [
      "adobe",
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "goldman",
      "google",
      "microsoft",
      "oracle",
      "twitter"
    ],
    "topics": [
      "backtracking",
      "dynamic-programming",
      "string"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(n2<sup>n</sup>)",
    "sc": "O(n<sup>2</sup>)",
    "leetcode": "palindrome-partitioning",
    "gfg": null,
    "leetid": 131,
    "content": "---\nlayout: post\ntitle: Palindrome Partitioning\ntopics: [backtracking, dynamic-programming, string]\nlangs: [java, py, cpp]\ntc: O(n2<sup>n</sup>)\nsc: O(n<sup>2</sup>)\nleetid: 131\ncompanies: [adobe, amazon, apple, bloomberg, facebook, goldman, google, microsoft, oracle, twitter]\ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: palindrome-partitioning\n---\n\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**. \nReturn all possible palindrome partitioning of `s`.\n\nA palindrome string is a string that reads the same backward as forward.\n\n---\n## How to Solve\n\nA given string `s` starting at index `start` and ending at index `end` is a palindrome if following conditions are satisfied :\n1. The characters at `start` and `end` indexes are equal. \n2. The substring starting at index `start+1` and ending at index `end1` is a palindrome.\n\n<MdxImage src=\"code/palindrome_dp.png\" alt=\"Palindrome\" />\n\nLet `N` be the length of the string. \nTo determine if a substring starting at index `start` and ending at index `end` is a palindrome or not, \nwe use a 2 Dimensional array `dp` of size `NxN` where,\n\n`dp[start][end]=true` , if the substring beginning at index `start` and ending at index `end` is a palindrome.\n\nOtherwise, `dp[start][end] ==false`.\n\nAlso, we must update the `dp` array, if we find that the current string is a palindrome.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**Example 2:**\n```\nInput: s = \"a\"\nOutput: [[\"a\"]]\n```",
    "body": "Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. \nReturn all possible palindrome partitioning of `s`.\n\nA palindrome string is a string that reads the same backward as forward.\n\n---\n## How to Solve\n\nA given string `s` starting at index `start` and ending at index `end` is a palindrome if following conditions are satisfied :\n1. The characters at `start` and `end` indexes are equal. \n2. The substring starting at index `start+1` and ending at index `end1` is a palindrome.\n\n<MdxImage src=\"code/palindrome_dp.png\" alt=\"Palindrome\" />\n\nLet `N` be the length of the string. \nTo determine if a substring starting at index `start` and ending at index `end` is a palindrome or not, \nwe use a 2 Dimensional array `dp` of size `NxN` where,\n\n`dp[start][end]=true` , if the substring beginning at index `start` and ending at index `end` is a palindrome.\n\nOtherwise, `dp[start][end] ==false`.\n\nAlso, we must update the `dp` array, if we find that the current string is a palindrome.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**Example 2:**\n```\nInput: s = \"a\"\nOutput: [[\"a\"]]\n```",
    "solutions": {}
  },
  "partition-array-for-maximum-sum": {
    "id": "partition-array-for-maximum-sum",
    "title": "Partition Array for Maximum Sum",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nk)",
    "sc": "O(n)",
    "leetcode": "partition-array-for-maximum-sum",
    "gfg": null,
    "leetid": 1043,
    "content": "---\nlayout: post\ntitle: Partition Array for Maximum Sum\ntopics: [array, dynamic-programming]\nlangs: [java]\ntc: O(nk)\nsc: O(n)\nleetid: 1043\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: partition-array-for-maximum-sum\n---\n\nGiven an integer array `arr`, partition the array into (contiguous) subarrays of length **at most** `k`. \nAfter partitioning, each subarray has their values changed to become the maximum value of that subarray.\n\nReturn the _largest sum of the given array after partitioning_. Test cases are generated so that the answer fits in a **_32-bit integer_**.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\n```\n\n**Example 2:** \n```\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n```\n\n**Example 2:**\n```\nInput: arr = [1], k = 1\nOutput: 1\n```\n\n---\n\n## How to Solve\n\nAt every index, we need to decide whether to move the element at the index to a new partition or use the existing partition\n\nFor the first test case, `arr = [1,15,7,9,2,5,10], k = 3`\n```mermaid\ngraph TD\n    0 --> 1\n    0 --> 2\n    0 --> 3\n    1 --> 2\n    1 --> 3\n    1 --> 4\n    2 --> 3\n    2 --> 4\n    2 --> 5\n```\n\nFrom above graph, we can see that we are reusing some of the pre-calculated values. We should proceed with dynamic programming for this\n\nAt every index, check for all elements upto `index + k` and find max sum that can be made by multipying the max element in sub-array",
    "body": "Given an integer array `arr`, partition the array into (contiguous) subarrays of length **at most** `k`. \nAfter partitioning, each subarray has their values changed to become the maximum value of that subarray.\n\nReturn the _largest sum of the given array after partitioning_. Test cases are generated so that the answer fits in a **_32-bit integer_**.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\n```\n\n**Example 2:** \n```\nInput: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n```\n\n**Example 2:**\n```\nInput: arr = [1], k = 1\nOutput: 1\n```\n\n---\n\n## How to Solve\n\nAt every index, we need to decide whether to move the element at the index to a new partition or use the existing partition\n\nFor the first test case, `arr = [1,15,7,9,2,5,10], k = 3`\n```mermaid\ngraph TD\n    0 --> 1\n    0 --> 2\n    0 --> 3\n    1 --> 2\n    1 --> 3\n    1 --> 4\n    2 --> 3\n    2 --> 4\n    2 --> 5\n```\n\nFrom above graph, we can see that we are reusing some of the pre-calculated values. We should proceed with dynamic programming for this\n\nAt every index, check for all elements upto `index + k` and find max sum that can be made by multipying the max element in sub-array",
    "solutions": {}
  },
  "partition-equal-subset-sum": {
    "id": "partition-equal-subset-sum",
    "title": "Partition Equal Subset Sum",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n*sum)",
    "sc": "O(sum)",
    "leetcode": "partition-equal-subset-sum",
    "gfg": null,
    "leetid": 416,
    "content": "---\nlayout: post\ntitle: Partition Equal Subset Sum\ntopics: [array, dynamic-programming]\nlangs: [java, py]\ntc: O(n*sum)\nsc: O(sum)\nleetid: 416\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: partition-equal-subset-sum\n---\n\nGiven a non-empty array nums containing only positive integers, \nfind if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n```\n\n**Example 2:** \n```\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n```",
    "body": "Given a non-empty array nums containing only positive integers, \nfind if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n```\n\n**Example 2:** \n```\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n```",
    "solutions": {}
  },
  "partition-labels": {
    "id": "partition-labels",
    "title": "Partition Labels",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "hash-table",
      "greedy",
      "string"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "partition-labels",
    "gfg": null,
    "leetid": 763,
    "content": "---\nlayout: post\ntitle: Partition Labels\ntopics: [hash-table, greedy, string]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\nleetid: 763\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: partition-labels\n---\n\nYou are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn a list of integers representing the size of these parts.\n\n---\n\n## How to Solve\n\n### Intuition\n\nLet's try to repeatedly choose the smallest left-justified partition. \nConsider the first label, say it's 'a'. \nThe first partition must include it, and also the last occurrence of 'a'. \nHowever, between those two occurrences of 'a', \nthere could be other labels that make the minimum size of this partition bigger. \nFor example, in `\"abccaddbeffe\"`, the minimum first partition is `\"abccaddb\"`. \nThis gives us the idea for the algorithm: For each letter encountered, \nprocess the last occurrence of that letter, extending the current partition `[start, end]` appropriately.\n\n### Algorithm\n\nWe need an array `last[char] -> index of S where char occurs last`. \nThen, let `start` and `end` be the start and end of the current partition. \nIf we are at a label that occurs last at some index after `end`, \nwe'll extend the partition `end = last[c]`. \nIf we are at the end of the partition `(i == end)` then we'll append a partition size to our answer, \nand set the start of our new partition to `i+1`.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(string) s = \"ababcbacadefegdehijhklij\"\n```\n\n**Output:** \n```\n(int[]) [9,7,8]\n```\n\n**Explanation:**\n```\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n```\n\n---\n\n**Input:**\n```\n(string) s = \"eccbbbbdec\"\n```\n\n**Output:**\n```\n(int[]) [10]\n```\n",
    "body": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be `s`.\n\nReturn a list of integers representing the size of these parts.\n\n---\n\n## How to Solve\n\n### Intuition\n\nLet's try to repeatedly choose the smallest left-justified partition. \nConsider the first label, say it's 'a'. \nThe first partition must include it, and also the last occurrence of 'a'. \nHowever, between those two occurrences of 'a', \nthere could be other labels that make the minimum size of this partition bigger. \nFor example, in `\"abccaddbeffe\"`, the minimum first partition is `\"abccaddb\"`. \nThis gives us the idea for the algorithm: For each letter encountered, \nprocess the last occurrence of that letter, extending the current partition `[start, end]` appropriately.\n\n### Algorithm\n\nWe need an array `last[char] -> index of S where char occurs last`. \nThen, let `start` and `end` be the start and end of the current partition. \nIf we are at a label that occurs last at some index after `end`, \nwe'll extend the partition `end = last[c]`. \nIf we are at the end of the partition `(i == end)` then we'll append a partition size to our answer, \nand set the start of our new partition to `i+1`.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(string) s = \"ababcbacadefegdehijhklij\"\n```\n\n**Output:** \n```\n(int[]) [9,7,8]\n```\n\n**Explanation:**\n```\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n```\n\n---\n\n**Input:**\n```\n(string) s = \"eccbbbbdec\"\n```\n\n**Output:**\n```\n(int[]) [10]\n```\n",
    "solutions": {}
  },
  "path-sum-iii": {
    "id": "path-sum-iii",
    "title": "Path Sum III",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "tree",
      "depth-first-search",
      "binary-tree"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "path-sum-iii",
    "gfg": null,
    "leetid": 437,
    "content": "---\nlayout: post\ntitle: Path Sum III\ntopics: [tree, depth-first-search, binary-tree]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 437\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: path-sum-iii\n---\nGiven the `root` of a binary tree and an integer `targetSum`, return *the number of paths where the sum of the values along the path equals* `targetSum`.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style={{width: '450px', height: '386px'}} />\n```\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n\n```\n**Example 2:**\n```\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[0, 1000]`.\n\t\n* `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`\n\t\n* `-1000 <= targetSum <= 1000`\n\n        ",
    "body": "Given the `root` of a binary tree and an integer `targetSum`, return *the number of paths where the sum of the values along the path equals* `targetSum`.\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style={{width: '450px', height: '386px'}} />\n```\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\nOutput: 3\nExplanation: The paths that sum to 8 are shown.\n\n```\n**Example 2:**\n```\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: 3\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[0, 1000]`.\n\t\n* `-10<sup>9</sup> <= Node.val <= 10<sup>9</sup>`\n\t\n* `-1000 <= targetSum <= 1000`\n\n        ",
    "solutions": {}
  },
  "perfect-squares": {
    "id": "perfect-squares",
    "title": "Perfect Squares",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "dynamic-programming"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n<sup>2</sup>)",
    "sc": "O(n)",
    "leetcode": "perfect-squares",
    "gfg": null,
    "leetid": 279,
    "content": "---\nlayout: post\ntitle: Perfect Squares\ntopics: [dynamic-programming]\nlangs: [java]\ntc: O(n<sup>2</sup>)\nsc: O(n)\nleetid: 279\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: perfect-squares\n---\n\nGiven an integer `n`, return the _least number of perfect square numbers that sum to_ `n`.\n\nA *perfect square* is an integer that is the square of an integer; \nin other words, it is the product of some integer with itself. \nFor example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int) n = 12\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\n12 = 4 + 4 + 4\n```\n\n---\n\n**Input:**\n```\n(int) n = 13\n```\n\n**Output:**\n```\n(int) 2\n```\n\n**Explanation:**\n```\n12 = 4 + 9\n```",
    "body": "Given an integer `n`, return the _least number of perfect square numbers that sum to_ `n`.\n\nA *perfect square* is an integer that is the square of an integer; \nin other words, it is the product of some integer with itself. \nFor example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int) n = 12\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\n12 = 4 + 4 + 4\n```\n\n---\n\n**Input:**\n```\n(int) n = 13\n```\n\n**Output:**\n```\n(int) 2\n```\n\n**Explanation:**\n```\n12 = 4 + 9\n```",
    "solutions": {}
  },
  "permutation-sequence": {
    "id": "permutation-sequence",
    "title": "Permutation Sequence",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "recursion"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "permutation-sequence",
    "gfg": null,
    "leetid": 60,
    "content": "---\nlayout: post\ntitle: Permutation Sequence\ntopics: [recursion]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 60\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: permutation-sequence\n---\n\nThe set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all the permutations in order, we get the following sequence for `n = 3`:\n\n1. \"123\"\n2. \"132\"\n3. \"213\"\n4. \"231\"\n5. \"312\"\n6. \"321\"\n\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: n = 3, k = 3\nOutput: \"213\"\n```\n\n**Example 2:** \n```\nInput: n = 4, k = 9\nOutput: \"2314\"\n```",
    "body": "The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all the permutations in order, we get the following sequence for `n = 3`:\n\n1. \"123\"\n2. \"132\"\n3. \"213\"\n4. \"231\"\n5. \"312\"\n6. \"321\"\n\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: n = 3, k = 3\nOutput: \"213\"\n```\n\n**Example 2:** \n```\nInput: n = 4, k = 9\nOutput: \"2314\"\n```",
    "solutions": {}
  },
  "populating-next-right-pointers-in-each-node": {
    "id": "populating-next-right-pointers-in-each-node",
    "title": "Populating Next Right Pointers in Each Node",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "binary-tree",
      "breadth-first-search",
      "linked-list",
      "tree"
    ],
    "langs": [
      "java",
      "go",
      "py",
      "cpp"
    ],
    "tc": "O(h)",
    "sc": "O(1)",
    "leetcode": "populating-next-right-pointers-in-each-node",
    "gfg": null,
    "leetid": 116,
    "content": "---\nlayout: post\ntitle: Populating Next Right Pointers in Each Node\ntopics: [binary-tree, breadth-first-search, linked-list, tree]\nlangs: [java, go, py, cpp]\ntc: O(h)\nsc: O(1)\nleetid: 116\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: populating-next-right-pointers-in-each-node\n---\n\nYou are given a perfect binary tree where all leaves are on the same level, and **every parent has two children**. \nThe binary tree has the following definition:\n```java\nclass Node {\n    int val;\n    Node left;\n    Node right;\n    Node next;\n}\n```\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n---\n## How to Solve\n\nTo solve, we will be traversing the tree per level.\nFor each node `curr` on a particular level (would already have `next` pointer due to parent level), do following\n1. if `curr.left` is not null, point its next to `curr.right`\n2. if `curr.right` is not null, point its next to `curr` neighbouring child\n3. `curr = curr.next`\n\nFor next level, move to `level.left`\n\n---\n## Test Cases\n\n<MdxImage src=\"code/116_sample.png\" alt=\"Example\" />\n\n**Example 1:**\n```\nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given the above perfect binary tree (Figure A), \nyour function should populate each next pointer to point to its next right node, just like in Figure B. \nThe serialized output is in level order as connected by the next pointers, \nwith '#' signifying the end of each level.\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```",
    "body": "You are given a perfect binary tree where all leaves are on the same level, and **every parent has two children**. \nThe binary tree has the following definition:\n```java\nclass Node {\n    int val;\n    Node left;\n    Node right;\n    Node next;\n}\n```\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.\n\n---\n## How to Solve\n\nTo solve, we will be traversing the tree per level.\nFor each node `curr` on a particular level (would already have `next` pointer due to parent level), do following\n1. if `curr.left` is not null, point its next to `curr.right`\n2. if `curr.right` is not null, point its next to `curr` neighbouring child\n3. `curr = curr.next`\n\nFor next level, move to `level.left`\n\n---\n## Test Cases\n\n<MdxImage src=\"code/116_sample.png\" alt=\"Example\" />\n\n**Example 1:**\n```\nInput: root = [1,2,3,4,5,6,7]\nOutput: [1,#,2,3,#,4,5,6,7,#]\nExplanation: Given the above perfect binary tree (Figure A), \nyour function should populate each next pointer to point to its next right node, just like in Figure B. \nThe serialized output is in level order as connected by the next pointers, \nwith '#' signifying the end of each level.\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```",
    "solutions": {}
  },
  "predict-the-winner": {
    "id": "predict-the-winner",
    "title": "Predict the Winner",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming",
      "recursion"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n<sup>2</sup>)",
    "sc": "O(n)",
    "leetcode": "predict-the-winner",
    "gfg": null,
    "leetid": 486,
    "content": "---\nlayout: post\ntitle: Predict the Winner\ntopics: [array, dynamic-programming, recursion]\nlangs: [java, cpp]\ntc: O(n<sup>2</sup>)\nsc: O(n)\nleetid: 486\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: predict-the-winner\n---\n\nYou are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. \nBoth players start the game with a score of `0`. \nAt each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) \nwhich reduces the size of the array by `1`. \nThe player adds the chosen number to their score. \nThe game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. \nIf the scores of both players are equal, then player 1 is still the winner, \nand you should also return `true`. You may assume that both players are playing optimally.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,5,2]\nOutput: false\nExplanation: Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n```\n\n**Example 2:** \n```\nInput: nums = [1,5,233,7]\nOutput: true\nExplanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n```",
    "body": "You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. \nBoth players start the game with a score of `0`. \nAt each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) \nwhich reduces the size of the array by `1`. \nThe player adds the chosen number to their score. \nThe game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. \nIf the scores of both players are equal, then player 1 is still the winner, \nand you should also return `true`. You may assume that both players are playing optimally.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,5,2]\nOutput: false\nExplanation: Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n```\n\n**Example 2:** \n```\nInput: nums = [1,5,233,7]\nOutput: true\nExplanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n```",
    "solutions": {}
  },
  "product-of-array-except-self": {
    "id": "product-of-array-except-self",
    "title": "Product of Array Except Self",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "prefix-sum"
    ],
    "langs": [
      "java",
      "cpp",
      "py",
      "c"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "product-of-array-except-self",
    "gfg": "a-product-array-puzzle",
    "leetid": 238,
    "content": "---\nlayout: post\ntitle: Product of Array Except Self\ntopics: [array, prefix-sum]\nlangs: [java, cpp, py, c]\ntc: O(n)\nsc: O(1)\nleetid: 238\ncompanies: [facebook]\ngfg: a-product-array-puzzle\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: product-of-array-except-self\n---\nGiven an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.\n \n---\n## Test Cases\n**Example 1:**\n```Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n```\n\n**Example 2:**\n```Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n```\n \n**Constraints:**\n\t\n* `2 <= nums.length <= 10<sup>5</sup>`\n\t\n* `-30 <= nums[i] <= 30`\n\t\n* The input is generated such that `answer[i]` is **guaranteed** to fit in a **32-bit** integer.\n \n**Follow up:** Can you solve the problem in `O(1)` extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)\n\n        ",
    "body": "Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.\n \n---\n## Test Cases\n**Example 1:**\n```Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n```\n\n**Example 2:**\n```Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n```\n \n**Constraints:**\n\t\n* `2 <= nums.length <= 10<sup>5</sup>`\n\t\n* `-30 <= nums[i] <= 30`\n\t\n* The input is generated such that `answer[i]` is **guaranteed** to fit in a **32-bit** integer.\n \n**Follow up:** Can you solve the problem in `O(1)` extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)\n\n        ",
    "solutions": {}
  },
  "random-pick-with-weight": {
    "id": "random-pick-with-weight",
    "title": "Random Pick with Weight",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "math",
      "binary-search",
      "prefix-sum",
      "randomized"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(log n)",
    "sc": "O(n)",
    "leetcode": "random-pick-with-weight",
    "gfg": null,
    "leetid": 912,
    "content": "---\nlayout: post\ntitle: Random Pick with Weight\ndifficulty: medium\ntopics: [array, math, binary-search, prefix-sum, randomized]\nlangs: [java]\ntc: O(log n)\nsc: O(n)\ncompanies: [facebook]\nleetid: 912\nleetcode: random-pick-with-weight\ngfg: \ninterviewbit: \nhackerrank: \n---\nYou are given a **0-indexed** array of positive integers `w` where `w[i]` describes the **weight** of the `i<sup>th</sup>` index.\nYou need to implement the function `pickIndex()`, which **randomly** picks an index in the range `[0, w.length - 1]` (**inclusive**) and returns it. The **probability** of picking an index `i` is `w[i] / sum(w)`.\n\t\n* For example, if `w = [1, 3]`, the probability of picking index `0` is `1 / (1 + 3) = 0.25` (i.e., `25%`), and the probability of picking index `1` is `3 / (1 + 3) = 0.75` (i.e., `75%`).\n \n---\n## Test Cases\n**Example 1:**\n```\n**Input**\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n**Output**\n[null,0]\n**Explanation**\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n```\n\n**Example 2:**\n```\n**Input**\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n**Output**\n[null,1,1,1,1,0]\n\n**Explanation**\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n```\n \n**Constraints:**\n\n* `1 <= w.length <= 10<sup>4</sup>`\n* `1 <= w[i] <= 10<sup>5</sup>`\n* `pickIndex` will be called at most `10<sup>4</sup>` times.\n\n",
    "body": "You are given a **0-indexed** array of positive integers `w` where `w[i]` describes the **weight** of the `i<sup>th</sup>` index.\nYou need to implement the function `pickIndex()`, which **randomly** picks an index in the range `[0, w.length - 1]` (**inclusive**) and returns it. The **probability** of picking an index `i` is `w[i] / sum(w)`.\n\t\n* For example, if `w = [1, 3]`, the probability of picking index `0` is `1 / (1 + 3) = 0.25` (i.e., `25%`), and the probability of picking index `1` is `3 / (1 + 3) = 0.75` (i.e., `75%`).\n \n---\n## Test Cases\n**Example 1:**\n```\n**Input**\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n**Output**\n[null,0]\n**Explanation**\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n```\n\n**Example 2:**\n```\n**Input**\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n**Output**\n[null,1,1,1,1,0]\n\n**Explanation**\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n```\n \n**Constraints:**\n\n* `1 <= w.length <= 10<sup>4</sup>`\n* `1 <= w[i] <= 10<sup>5</sup>`\n* `pickIndex` will be called at most `10<sup>4</sup>` times.\n\n",
    "solutions": {}
  },
  "reconstruct-itinerary": {
    "id": "reconstruct-itinerary",
    "title": "Reconstruct Itinerary",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(1)",
    "sc": "O(V<sup>2</sup>)",
    "leetcode": "reconstruct-itinerary",
    "gfg": null,
    "leetid": 332,
    "content": "---\nlayout: post\ntitle: Reconstruct Itinerary\ntopics: [string]\nlangs: [java]\ntc: O(1)\nsc: O(V<sup>2</sup>)\nleetid: 332\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: reconstruct-itinerary\n---\n\nYou are given a list of airline tickets where `tickets[i] = [from[i], to[i]]` represent the departure and the arrival airports of one flight. \nReconstruct the itinerary in order and return it.\n\nAll the tickets belong to a man who departs from `\"JFK\"`, thus, the itinerary must begin with \"JFK\". \nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\nFor example, the itinerary `[\"JFK\", \"LGA\"]` has a smaller lexical order than `[\"JFK\", \"LGB\"]`.\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\nOutput: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\nJFK -> MUC -> LHR -> SFO -> SJC\n```\n\n**Example 2:** \n```\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\nOutput: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\nExplanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n```",
    "body": "You are given a list of airline tickets where `tickets[i] = [from[i], to[i]]` represent the departure and the arrival airports of one flight. \nReconstruct the itinerary in order and return it.\n\nAll the tickets belong to a man who departs from `\"JFK\"`, thus, the itinerary must begin with \"JFK\". \nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\nFor example, the itinerary `[\"JFK\", \"LGA\"]` has a smaller lexical order than `[\"JFK\", \"LGB\"]`.\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\nOutput: [\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\nJFK -> MUC -> LHR -> SFO -> SJC\n```\n\n**Example 2:** \n```\nInput: tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\nOutput: [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\nExplanation: Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order.\n```",
    "solutions": {}
  },
  "recover-binary-search-tree": {
    "id": "recover-binary-search-tree",
    "title": "Recover Binary Search Tree",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "binary-search-tree",
      "binary-tree",
      "depth-first-search",
      "tree"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "recover-binary-search-tree",
    "gfg": null,
    "leetid": 99,
    "content": "---\nlayout: post\ntitle: Recover Binary Search Tree\ntopics: [binary-search-tree, binary-tree, depth-first-search, tree]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 99\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: recover-binary-search-tree\n---\n\nYou are given the root of a binary search tree (BST), \nwhere the values of exactly two nodes of the tree were swapped by mistake. \nRecover the tree without changing its structure.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n```\n\n**Example 2:** \n```\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n```",
    "body": "You are given the root of a binary search tree (BST), \nwhere the values of exactly two nodes of the tree were swapped by mistake. \nRecover the tree without changing its structure.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: root = [1,3,null,null,2]\nOutput: [3,1,null,null,2]\nExplanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n```\n\n**Example 2:** \n```\nInput: root = [3,1,4,null,null,2]\nOutput: [2,1,4,null,null,3]\nExplanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n```",
    "solutions": {}
  },
  "regular-expression-matching": {
    "id": "regular-expression-matching",
    "title": "Regular Expression Matching",
    "difficulty": "hard",
    "companies": [
      "facebook",
      "microsoft",
      "goldman",
      "uber",
      "google",
      "airbnb"
    ],
    "topics": [
      "string",
      "dynamic-programming",
      "recursion"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(mn)",
    "sc": "O(mn)",
    "leetcode": "regular-expression-matching",
    "gfg": null,
    "leetid": 10,
    "content": "---\nlayout: post\ntitle: Regular Expression Matching\ntopics: [string, dynamic-programming, recursion]\nlangs: [java, py]\ntc: O(mn)\nsc: O(mn)\nleetid: 10\ngfg: \ninterviewbit: regular-expression-match\nhackerrank: \ncompanies: [facebook, microsoft, goldman, uber, google, airbnb]\ndifficulty: hard\nleetcode: regular-expression-matching\n---\nGiven an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\t\n* `'.'` Matches any single character.\n\t\n* `'*'` Matches zero or more of the preceding element.\nThe matching should cover the **entire** input string (not partial).\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:**\n```\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n```\n\n**Example 3:**\n```\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 20`\n* `1 <= p.length <= 20`\n* `s` contains only lowercase English letters.\n* `p` contains only lowercase English letters, `'.'`, and `'*'`.\n* It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.\n",
    "body": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\t\n* `'.'` Matches any single character.\n\t\n* `'*'` Matches zero or more of the preceding element.\nThe matching should cover the **entire** input string (not partial).\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:**\n```\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n```\n\n**Example 3:**\n```\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 20`\n* `1 <= p.length <= 20`\n* `s` contains only lowercase English letters.\n* `p` contains only lowercase English letters, `'.'`, and `'*'`.\n* It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.\n",
    "solutions": {}
  },
  "remove-duplicate-letters": {
    "id": "remove-duplicate-letters",
    "title": "Remove Duplicate Letters",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "greedy",
      "stack",
      "string"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "remove-duplicate-letters",
    "gfg": null,
    "leetid": 316,
    "content": "---\nlayout: post\ntitle: Remove Duplicate Letters\ntopics: [greedy, stack, string]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 316\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: remove-duplicate-letters\n---\n\nGiven a string `s`, remove duplicate letters so that every letter appears once and only once. \nYou must make sure your result is **the smallest in lexicographical order** among all possible results.\n\n---\n## How to Solve\n\n1. Store occurrences of every character\n2. For every character in string, do following-\n   1. decrement number of characters remaining in the string to be analysed\n   2. if character is already present in stack, don't bother\n   3. if current character is smaller than last character in stack which occurs later in the string again, \n      it can be removed and  added later e.g. stack = bc remaining string abc then a can pop b and then c\n   4. add current character in stack and mark it as visited\n3. pop character from stack and build answer string from back\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"bcabc\"\nOutput: \"abc\"\n```\n\n**Example 2:** \n```\nInput: s = \"cbacdcbc\"\nOutput: \"acdb\"\n```",
    "body": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. \nYou must make sure your result is **the smallest in lexicographical order** among all possible results.\n\n---\n## How to Solve\n\n1. Store occurrences of every character\n2. For every character in string, do following-\n   1. decrement number of characters remaining in the string to be analysed\n   2. if character is already present in stack, don't bother\n   3. if current character is smaller than last character in stack which occurs later in the string again, \n      it can be removed and  added later e.g. stack = bc remaining string abc then a can pop b and then c\n   4. add current character in stack and mark it as visited\n3. pop character from stack and build answer string from back\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"bcabc\"\nOutput: \"abc\"\n```\n\n**Example 2:** \n```\nInput: s = \"cbacdcbc\"\nOutput: \"acdb\"\n```",
    "solutions": {}
  },
  "remove-duplicates-from-sorted-list-ii": {
    "id": "remove-duplicates-from-sorted-list-ii",
    "title": "Remove Duplicates from Sorted List II",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "linked-list"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "remove-duplicates-from-sorted-list-ii",
    "gfg": null,
    "leetid": 82,
    "content": "---\nlayout: post\ntitle: Remove Duplicates from Sorted List II\ntopics: [linked-list]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 82\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: remove-duplicates-from-sorted-list-ii\n---\n\nGiven the `head` of a sorted linked list, delete all nodes that have duplicate numbers, \nleaving only distinct numbers from the original list. Return the linked list sorted as well.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n```\n\n**Example 2:** \n```\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n```",
    "body": "Given the `head` of a sorted linked list, delete all nodes that have duplicate numbers, \nleaving only distinct numbers from the original list. Return the linked list sorted as well.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n```\n\n**Example 2:** \n```\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n```",
    "solutions": {}
  },
  "remove-invalid-parentheses": {
    "id": "remove-invalid-parentheses",
    "title": "Remove Invalid Parentheses",
    "difficulty": "hard",
    "companies": [
      "facebook",
      "google"
    ],
    "topics": [
      "string",
      "backtracking",
      "breadth-first-search"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(2<sup>n</sup>)",
    "sc": "O(n2<sup>n</sup>)",
    "leetcode": "remove-invalid-parentheses",
    "gfg": "remove-invalid-parentheses",
    "leetid": 301,
    "content": "---\nlayout: post\ntitle: Remove Invalid Parentheses\ndifficulty: hard\ntopics: [string, backtracking, breadth-first-search]\nlangs: [java]\ntc: O(2<sup>n</sup>)\nsc: O(n2<sup>n</sup>)\ncompanies: [facebook, google]\nleetid: 301\nleetcode: remove-invalid-parentheses\ngfg: remove-invalid-parentheses\ninterviewbit: \nhackerrank: \n---\nGiven a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\nReturn *a list of **unique strings** that are valid with the minimum number of removals*. You may return the answer in **any order**.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\n```\n\n**Example 2:**\n```\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\n```\n\n**Example 3:**\n```\nInput: s = \")(\"\nOutput: [\"\"]\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 25`\n* `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n* There will be at most `20` parentheses in `s`.\n\n",
    "body": "Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\nReturn *a list of **unique strings** that are valid with the minimum number of removals*. You may return the answer in **any order**.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\n```\n\n**Example 2:**\n```\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\n```\n\n**Example 3:**\n```\nInput: s = \")(\"\nOutput: [\"\"]\n```\n \n**Constraints:**\n\t\n* `1 <= s.length <= 25`\n* `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n* There will be at most `20` parentheses in `s`.\n\n",
    "solutions": {}
  },
  "remove-k-digits": {
    "id": "remove-k-digits",
    "title": "Remove K Digits",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "greedy",
      "string",
      "stack"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n+k)",
    "sc": "O(n)",
    "leetcode": "remove-k-digits",
    "gfg": null,
    "leetid": 402,
    "content": "---\nlayout: post\ntitle: Remove K Digits\ntopics: [greedy, string, stack]\nlangs: [java, py]\ntc: O(n+k)\nsc: O(n)\nleetid: 402\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: remove-k-digits\n---\n\nGiven string `num` representing a non-negative integer `num`, and an integer `k`, \nreturn the smallest possible integer after removing `k` digits from `num`.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) num = \"1432219\"\n(int) k = 3\n```\n\n**Output:**\n```\n(string) \"1219\"\n```\n\n**Explanation:**\n```\nRemove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n```\n\n---\n\n**Input:**\n```\n(string) num = \"10200\"\n(int) k = 1\n```\n\n**Output:**\n```\n(string) \"200\"\n```\n\n**Explanation:**\n```\nRemove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n```\n",
    "body": "Given string `num` representing a non-negative integer `num`, and an integer `k`, \nreturn the smallest possible integer after removing `k` digits from `num`.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) num = \"1432219\"\n(int) k = 3\n```\n\n**Output:**\n```\n(string) \"1219\"\n```\n\n**Explanation:**\n```\nRemove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n```\n\n---\n\n**Input:**\n```\n(string) num = \"10200\"\n(int) k = 1\n```\n\n**Output:**\n```\n(string) \"200\"\n```\n\n**Explanation:**\n```\nRemove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n```\n",
    "solutions": {}
  },
  "remove-nth-node-from-end-of-list": {
    "id": "remove-nth-node-from-end-of-list",
    "title": "Remove Nth Node From End of List",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "linked-list"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "remove-nth-node-from-end-of-list",
    "gfg": null,
    "leetid": 19,
    "content": "---\nlayout: post\ntitle: Remove Nth Node From End of List\ntopics: [linked-list]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(1)\nleetid: 19\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: remove-nth-node-from-end-of-list\nhellointerview: code/linked-list/remove-nth-node-from-end-of-list\n---\n\nGiven the `head` of a linked list, remove the `n`th node from the end of the list and return its `head`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n```\n\n**Example 2:** \n```\nInput: head = [1], n = 1\nOutput: []\n```",
    "body": "Given the `head` of a linked list, remove the `n`th node from the end of the list and return its `head`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n```\n\n**Example 2:** \n```\nInput: head = [1], n = 1\nOutput: []\n```",
    "solutions": {}
  },
  "reorder-list": {
    "id": "reorder-list",
    "title": "Reorder List",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "linked-list",
      "recursion",
      "stack",
      "two-pointers"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "reorder-list",
    "gfg": null,
    "leetid": 143,
    "content": "---\nlayout: post\ntitle: Reorder List\ntopics: [linked-list, recursion, stack, two-pointers]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\nleetid: 143\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: reorder-list\nhellointerview: code/linked-list/reorder-list\n---\n\nYou are given the head of a singly linked-list. The list can be represented as:\n```\nL0  L1    Ln - 1  Ln\n```\nReorder the list to be on the following form:\n\n```\nL0  Ln  L1  Ln - 1  L2  Ln - 2  \n```\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n```\n\n**Example 2:** \n```\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n```",
    "body": "You are given the head of a singly linked-list. The list can be represented as:\n```\nL0  L1    Ln - 1  Ln\n```\nReorder the list to be on the following form:\n\n```\nL0  Ln  L1  Ln - 1  L2  Ln - 2  \n```\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n```\n\n**Example 2:** \n```\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n```",
    "solutions": {}
  },
  "replace-words": {
    "id": "replace-words",
    "title": "Replace Words",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "hash-table",
      "string",
      "trie"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(nm)",
    "sc": "O(d)",
    "leetcode": "replace-words",
    "gfg": null,
    "leetid": 648,
    "content": "---\nlayout: post\ntitle: Replace Words\ntopics: [array, hash-table, string, trie]\nlangs: [java, py]\ntc: O(nm)\nsc: O(d)\nleetid: 648\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: replace-words\n---\nIn English, we have a concept called **root**, which can be followed by some other word to form another longer word - let's call this word **derivative**. For example, when the **root** `\"help\"` is followed by the word `\"ful\"`, we can form a derivative `\"helpful\"`.\nGiven a `dictionary` consisting of many **roots** and a `sentence` consisting of words separated by spaces, replace all the derivatives in the sentence with the **root** forming it. If a derivative can be replaced by more than one **root**, replace it with the **root** that has **the shortest length**.\nReturn *the `sentence`* after the replacement.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\nOutput: \"the cat was rat by the bat\"\n```\n\n**Example 2:**\n```\nInput: dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\nOutput: \"a a b c\"\n```\n \n**Constraints:**\n\t\n* `1 <= dictionary.length <= 1000`\n* `1 <= dictionary[i].length <= 100`\n* `dictionary[i]` consists of only lower-case letters.\n* `1 <= sentence.length <= 10<sup>6</sup>`\n* `sentence` consists of only lower-case letters and spaces.\n* The number of words in `sentence` is in the range `[1, 1000]`\n* The length of each word in `sentence` is in the range `[1, 1000]`\n* Every two consecutive words in `sentence` will be separated by exactly one space.\n* `sentence` does not have leading or trailing spaces.\n\n        ",
    "body": "In English, we have a concept called **root**, which can be followed by some other word to form another longer word - let's call this word **derivative**. For example, when the **root** `\"help\"` is followed by the word `\"ful\"`, we can form a derivative `\"helpful\"`.\nGiven a `dictionary` consisting of many **roots** and a `sentence` consisting of words separated by spaces, replace all the derivatives in the sentence with the **root** forming it. If a derivative can be replaced by more than one **root**, replace it with the **root** that has **the shortest length**.\nReturn *the `sentence`* after the replacement.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\nOutput: \"the cat was rat by the bat\"\n```\n\n**Example 2:**\n```\nInput: dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\nOutput: \"a a b c\"\n```\n \n**Constraints:**\n\t\n* `1 <= dictionary.length <= 1000`\n* `1 <= dictionary[i].length <= 100`\n* `dictionary[i]` consists of only lower-case letters.\n* `1 <= sentence.length <= 10<sup>6</sup>`\n* `sentence` consists of only lower-case letters and spaces.\n* The number of words in `sentence` is in the range `[1, 1000]`\n* The length of each word in `sentence` is in the range `[1, 1000]`\n* Every two consecutive words in `sentence` will be separated by exactly one space.\n* `sentence` does not have leading or trailing spaces.\n\n        ",
    "solutions": {}
  },
  "restore-ip-addresses": {
    "id": "restore-ip-addresses",
    "title": "Restore IP Addresses",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "backtracking",
      "string"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n<sup>3</sup>)",
    "sc": "O(1)",
    "leetcode": "restore-ip-addresses",
    "gfg": null,
    "leetid": 93,
    "content": "---\nlayout: post\ntitle: Restore IP Addresses\ntopics: [backtracking, string]\nlangs: [java, py]\ntc: O(n<sup>3</sup>)\nsc: O(1)\nleetid: 93\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: restore-ip-addresses\n---\n\nA valid IP address consists of exactly four integers separated by single dots. \nEach integer is between `0` and `255` (inclusive) and cannot have leading zeros. \n- For example, `\"0.1.2.201\"` and `\"192.168.1.1\"` are valid IP addresses, \nbut `\"0.011.255.245\"`, `\"192.168.1.312\"` and `\"192.168@1.1\"` are invalid IP addresses.\n\nGiven a string s containing only digits, \nreturn all possible valid IP addresses that can be formed by inserting dots into s. \nYou are not allowed to reorder or remove any digits in s. \nYou may return the valid IP addresses in any order.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) s = \"25525511135\"\n```\n\n**Output:**\n```\n(string[]) [\"255.255.11.135\",\"255.255.111.35\"]\n```\n\n---\n\n**Input:**\n```\n(string) s = \"101023\"\n```\n\n**Output:**\n```\n(string[]) [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n```",
    "body": "A valid IP address consists of exactly four integers separated by single dots. \nEach integer is between `0` and `255` (inclusive) and cannot have leading zeros. \n- For example, `\"0.1.2.201\"` and `\"192.168.1.1\"` are valid IP addresses, \nbut `\"0.011.255.245\"`, `\"192.168.1.312\"` and `\"192.168@1.1\"` are invalid IP addresses.\n\nGiven a string s containing only digits, \nreturn all possible valid IP addresses that can be formed by inserting dots into s. \nYou are not allowed to reorder or remove any digits in s. \nYou may return the valid IP addresses in any order.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(string) s = \"25525511135\"\n```\n\n**Output:**\n```\n(string[]) [\"255.255.11.135\",\"255.255.111.35\"]\n```\n\n---\n\n**Input:**\n```\n(string) s = \"101023\"\n```\n\n**Output:**\n```\n(string[]) [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n```",
    "solutions": {}
  },
  "reverse-linked-list-ii": {
    "id": "reverse-linked-list-ii",
    "title": "Reverse Linked List II",
    "difficulty": "medium",
    "companies": [
      "facebook",
      "uber"
    ],
    "topics": [
      "linked-list"
    ],
    "langs": [
      "java",
      "c",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "reverse-linked-list-ii",
    "gfg": null,
    "leetid": 92,
    "content": "---\nlayout: post\ntitle: Reverse Linked List II\ntopics: [linked-list]\nlangs: [java, c, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 92\ninterviewbit: reverse-link-list-ii\ndifficulty: medium\ncompanies: [facebook, uber]\ngfg: \nhackerrank: \nleetcode: reverse-linked-list-ii\n---\n\nGiven the head of a singly linked list and two integers `left` and `right` where `left <= right`, \nreverse the nodes of the list from position `left` to position `right`, and return the reversed list.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/rev2ex2.jpeg\" alt=\"Linked list\" />\n\n**Input:**\n```\n(ListNode) head = [1,2,3,4,5]\n(int) left = 2\n(int) right = 4\n```\n\n**Output:**\n```\n(ListNode) [1,4,3,2,5]\n```",
    "body": "Given the head of a singly linked list and two integers `left` and `right` where `left <= right`, \nreverse the nodes of the list from position `left` to position `right`, and return the reversed list.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/rev2ex2.jpeg\" alt=\"Linked list\" />\n\n**Input:**\n```\n(ListNode) head = [1,2,3,4,5]\n(int) left = 2\n(int) right = 4\n```\n\n**Output:**\n```\n(ListNode) [1,4,3,2,5]\n```",
    "solutions": {}
  },
  "reverse-nodes-in-k-group": {
    "id": "reverse-nodes-in-k-group",
    "title": "Reverse Nodes in k-Group",
    "difficulty": "hard",
    "companies": [
      "amazon",
      "apple",
      "facebook",
      "google",
      "microsoft",
      "oracle"
    ],
    "topics": [
      "linked-list",
      "recursion"
    ],
    "langs": [
      "java",
      "cpp",
      "py",
      "c"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "reverse-nodes-in-k-group",
    "gfg": "reverse-a-linked-list-in-groups-of-given-size",
    "leetid": 25,
    "content": "---\nlayout: post\ntitle: Reverse Nodes in k-Group\ntopics: [linked-list, recursion]\nlangs: [java, cpp, py, c]\ntc: O(n)\nsc: O(1)\nleetid: 25\ncompanies: [amazon, apple, facebook, google, microsoft, oracle]\ndifficulty: hard\ngfg: reverse-a-linked-list-in-groups-of-given-size\nhackerrank: \ninterviewbit: \nleetcode: reverse-nodes-in-k-group\n---\n\nGiven the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. \nIf the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n```\n\n**Example 2:** \n```\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n```",
    "body": "Given the `head` of a linked list, reverse the nodes of the list `k` at a time, and return the modified list.\n\n`k` is a positive integer and is less than or equal to the length of the linked list. \nIf the number of nodes is not a multiple of `k` then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n```\n\n**Example 2:** \n```\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n```",
    "solutions": {}
  },
  "rotate-array": {
    "id": "rotate-array",
    "title": "Rotate Array",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "two-pointers"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(logn)",
    "sc": "O(1)",
    "leetcode": "rotate-array",
    "gfg": null,
    "leetid": 189,
    "content": "---\nlayout: post\ntitle: Rotate Array\ntopics: [array, two-pointers]\nlangs: [java, cpp, py]\ntc: O(logn)\nsc: O(1)\nleetid: 189\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: rotate-array\n---\n\nGiven an array, rotate the array to the right by k steps, where k is non-negative.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n**Example 2:** \n```\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```",
    "body": "Given an array, rotate the array to the right by k steps, where k is non-negative.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n```\n\n**Example 2:** \n```\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n```",
    "solutions": {}
  },
  "rotate-list": {
    "id": "rotate-list",
    "title": "Rotate List",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "linked-list"
    ],
    "langs": [
      "java",
      "cpp",
      "c"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "rotate-list",
    "gfg": null,
    "leetid": 61,
    "content": "---\nlayout: post\ntitle: Rotate List\ntopics: [linked-list]\nlangs: [java, cpp, c]\ntc: O(n)\nsc: O(1)\nleetid: 61\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: rotate-list\n---\n\nGiven the head of a linked list, rotate the list to the right by k places.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n```\n\n**Example 2:** \n```\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n```",
    "body": "Given the head of a linked list, rotate the list to the right by k places.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n```\n\n**Example 2:** \n```\nInput: head = [0,1,2], k = 4\nOutput: [2,0,1]\n```",
    "solutions": {}
  },
  "rotational-cipher": {
    "id": "rotational-cipher",
    "title": "Rotational Cipher",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": null,
    "gfg": null,
    "content": "---\nlayout: post\ntitle: Rotational Cipher\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(1)\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: \n---\n\nOne simple way to encrypt a string is to \"rotate\" every alphanumeric character by a certain amount. Rotating a character means replacing it with another character that is a certain number of steps away in normal alphabetic or numerical order.\nFor example, if the string \"Zebra-493?\" is rotated 3 places, the resulting string is \"Cheud-726?\". Every alphabetic character is replaced with the character 3 letters higher (wrapping around from Z to A), and every numeric character replaced with the character 3 digits higher (wrapping around from 9 to 0). Note that the non-alphanumeric characters remain unchanged.\nGiven a string and a rotation factor, return an encrypted string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\ninput = Zebra-493?\nrotationFactor = 3\noutput = Cheud-726?\n```\n\n**Example 2:** \n```\ninput = abcdefghijklmNOPQRSTUVWXYZ0123456789\nrotationFactor = 39\noutput = nopqrstuvwxyzABCDEFGHIJKLM9012345678\n```",
    "body": "One simple way to encrypt a string is to \"rotate\" every alphanumeric character by a certain amount. Rotating a character means replacing it with another character that is a certain number of steps away in normal alphabetic or numerical order.\nFor example, if the string \"Zebra-493?\" is rotated 3 places, the resulting string is \"Cheud-726?\". Every alphabetic character is replaced with the character 3 letters higher (wrapping around from Z to A), and every numeric character replaced with the character 3 digits higher (wrapping around from 9 to 0). Note that the non-alphanumeric characters remain unchanged.\nGiven a string and a rotation factor, return an encrypted string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\ninput = Zebra-493?\nrotationFactor = 3\noutput = Cheud-726?\n```\n\n**Example 2:** \n```\ninput = abcdefghijklmNOPQRSTUVWXYZ0123456789\nrotationFactor = 39\noutput = nopqrstuvwxyzABCDEFGHIJKLM9012345678\n```",
    "solutions": {}
  },
  "russian-doll-envelopes": {
    "id": "russian-doll-envelopes",
    "title": "Russian Doll Envelopes",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "binary-search",
      "dynamic-programming",
      "sorting"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nlogn)",
    "sc": "O(n)",
    "leetcode": "russian-doll-envelopes",
    "gfg": null,
    "leetid": 354,
    "content": "---\nlayout: post\ntitle: Russian Doll Envelopes\ntopics: [array, binary-search, dynamic-programming, sorting]\nlangs: [java]\ntc: O(nlogn)\nsc: O(n)\nleetid: 354\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: russian-doll-envelopes\n---\n\nYou are given a 2D array of integers envelopes where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll_ (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n```\n\n**Example 2:** \n```\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n```",
    "body": "You are given a 2D array of integers envelopes where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll_ (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n```\n\n**Example 2:** \n```\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n```",
    "solutions": {}
  },
  "score-of-parentheses": {
    "id": "score-of-parentheses",
    "title": "Score of Parentheses",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "stack",
      "string"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "score-of-parentheses",
    "gfg": null,
    "leetid": 856,
    "content": "---\nlayout: post\ntitle: Score of Parentheses\ntopics: [stack, string]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 856\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: score-of-parentheses\n---\n\nGiven a balanced parentheses string `s`, return the score of the string.\n\nThe score of a balanced parentheses string is based on the following rule:\n- `\"()\"` has score `1`.\n- `AB` has score `A + B`, where `A` and `B` are balanced parentheses strings.\n- `(A)` has score `2 * A`, where `A` is a balanced parentheses string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"()\"\nOutput: 1\n```\n\n**Example 2:** \n```\nInput: s = \"(())\"\nOutput: 2\n```\n\n**Example 3:**\n```\nInput: s = \"()()\"\nOutput: 2\n```",
    "body": "Given a balanced parentheses string `s`, return the score of the string.\n\nThe score of a balanced parentheses string is based on the following rule:\n- `\"()\"` has score `1`.\n- `AB` has score `A + B`, where `A` and `B` are balanced parentheses strings.\n- `(A)` has score `2 * A`, where `A` is a balanced parentheses string.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"()\"\nOutput: 1\n```\n\n**Example 2:** \n```\nInput: s = \"(())\"\nOutput: 2\n```\n\n**Example 3:**\n```\nInput: s = \"()()\"\nOutput: 2\n```",
    "solutions": {}
  },
  "scramble-string": {
    "id": "scramble-string",
    "title": "Scramble String",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "dynamic-programming",
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(2<sup>n</sup>)",
    "sc": "O(m+n)",
    "leetcode": "scramble-string",
    "gfg": null,
    "leetid": 87,
    "content": "---\nlayout: post\ntitle: Scramble String\ntopics: [dynamic-programming, string]\nlangs: [java]\ntc: O(2<sup>n</sup>)\nsc: O(m+n)\nleetid: 87\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: scramble-string\n---\n\nWe can scramble a string `s` to get a string `t` using the following algorithm:\n1. If the length of the string is 1, stop. \n2. If the length of the string is > 1, do the following:\n   - Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to `x` and `y` where `s = x + y`. \n   - **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`. \n   - Apply step 1 recursively on each of the two substrings `x` and `y`.\n   \nGiven two strings `s1` and `s2` of the same length, return true if `s2` is a scrambled string of `s1`, otherwise, return false.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n```\n\n**Example 2:** \n```\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n```\n\n**Example 3:**\n```\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n```",
    "body": "We can scramble a string `s` to get a string `t` using the following algorithm:\n1. If the length of the string is 1, stop. \n2. If the length of the string is > 1, do the following:\n   - Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to `x` and `y` where `s = x + y`. \n   - **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`. \n   - Apply step 1 recursively on each of the two substrings `x` and `y`.\n   \nGiven two strings `s1` and `s2` of the same length, return true if `s2` is a scrambled string of `s1`, otherwise, return false.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n```\n\n**Example 2:** \n```\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n```\n\n**Example 3:**\n```\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n```",
    "solutions": {}
  },
  "search-a-2d-matrix": {
    "id": "search-a-2d-matrix",
    "title": "Search a 2D Matrix",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "binary-search",
      "matrix"
    ],
    "langs": [
      "java",
      "cpp",
      "c",
      "py",
      "go"
    ],
    "tc": "O(mn)",
    "sc": "O(1)",
    "leetcode": "search-a-2d-matrix",
    "gfg": null,
    "leetid": 74,
    "content": "---\nlayout: post\ntitle: Search a 2D Matrix\ntopics: [array, binary-search, matrix]\nlangs: [java, cpp, c, py, go]\ntc: O(mn)\nsc: O(1)\nleetid: 74\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: search-a-2d-matrix\n---\n\nWrite an efficient algorithm that searches for a value target in an `m` x `n` integer `matrix`. This matrix has the following properties:\n- Integers in each row are sorted from left to right.\n- The first integer of each row is greater than the last integer of the previous row.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n```\n\n**Example 2:** \n\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n```",
    "body": "Write an efficient algorithm that searches for a value target in an `m` x `n` integer `matrix`. This matrix has the following properties:\n- Integers in each row are sorted from left to right.\n- The first integer of each row is greater than the last integer of the previous row.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n```\n\n**Example 2:** \n\n```\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n```",
    "solutions": {}
  },
  "search-in-rotated-sorted-array-ii": {
    "id": "search-in-rotated-sorted-array-ii",
    "title": "Search in Rotated Sorted Array II",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "binary-search"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "search-in-rotated-sorted-array-ii",
    "gfg": "search-an-element-in-a-sorted-and-pivoted-array",
    "leetid": 81,
    "content": "---\nlayout: post\ntitle: Search in Rotated Sorted Array II\ntopics: [array, binary-search]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 81\ngfg: search-an-element-in-a-sorted-and-pivoted-array\ncompanies: [facebook]\ndifficulty: medium\nhackerrank: \ninterviewbit: \nleetcode: search-in-rotated-sorted-array-ii\nhellointerview: code/binary-search/search-in-rotated-sorted-array\n---\n\nThere is an integer array `nums` sorted in non-decreasing order (not necessarily with distinct values).\n\nBefore being passed to your function, \n`nums` is rotated at an unknown pivot index `k` (`0` &lt;= `k` &lt; `nums.length`) \nsuch that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). \nFor example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index 5 and become `[4,5,6,6,7,0,1,2,4,4]`.\n\nGiven the array `nums` after the rotation and an integer `target`, return true if `target` is in nums, or false if it is not in nums.\n\nYou must decrease the overall operation steps as much as possible.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n```\n\n**Example 2:** \n```\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n```",
    "body": "There is an integer array `nums` sorted in non-decreasing order (not necessarily with distinct values).\n\nBefore being passed to your function, \n`nums` is rotated at an unknown pivot index `k` (`0` &lt;= `k` &lt; `nums.length`) \nsuch that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). \nFor example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index 5 and become `[4,5,6,6,7,0,1,2,4,4]`.\n\nGiven the array `nums` after the rotation and an integer `target`, return true if `target` is in nums, or false if it is not in nums.\n\nYou must decrease the overall operation steps as much as possible.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n```\n\n**Example 2:** \n```\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n```",
    "solutions": {}
  },
  "search-in-rotated-sorted-array": {
    "id": "search-in-rotated-sorted-array",
    "title": "Search in Rotated Sorted Array",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "two-pointers"
    ],
    "langs": [
      "java",
      "go",
      "cpp",
      "py",
      "c"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "search-in-rotated-sorted-array",
    "gfg": "search-an-element-in-a-sorted-and-pivoted-array",
    "leetid": 33,
    "content": "---\nlayout: post\ntitle: Search in Rotated Sorted Array\ntopics: [array, two-pointers]\nlangs: [java, go, cpp, py, c]\ntc: O(n)\nsc: O(n)\nleetid: 33\ngfg: search-an-element-in-a-sorted-and-pivoted-array\ncompanies: [facebook]\ndifficulty: medium\nhackerrank: \ninterviewbit: rotated-sorted-array-search\nleetcode: search-in-rotated-sorted-array\nhellointerview: code/binary-search/search-in-rotated-sorted-array\n---\n\nThere is an integer array `nums` sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, \nnums is possibly rotated at an unknown pivot index `k (1 <= k < nums.length)` \nsuch that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0],nums[1], ..., nums[k-1]]` (0-indexed). \nFor example, `[0,1,2,4,5,6,7]` might be rotated at pivot index 3 and become `[4,5,6,7,0,1,2]`.\n\nGiven the array nums after the possible rotation and an integer `target`, return the index of target if it is in `nums`, or `-1` if it is not in nums.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) nums = [4,5,6,7,0,1,2]\n(int) target = 0\n```\n\n**Output:**\n```\n(int) 4\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [4,5,6,7,0,1,2]\n(int) target = 3\n```\n\n**Output:**\n```\n(int) -1\n```",
    "body": "There is an integer array `nums` sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, \nnums is possibly rotated at an unknown pivot index `k (1 <= k < nums.length)` \nsuch that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0],nums[1], ..., nums[k-1]]` (0-indexed). \nFor example, `[0,1,2,4,5,6,7]` might be rotated at pivot index 3 and become `[4,5,6,7,0,1,2]`.\n\nGiven the array nums after the possible rotation and an integer `target`, return the index of target if it is in `nums`, or `-1` if it is not in nums.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) nums = [4,5,6,7,0,1,2]\n(int) target = 0\n```\n\n**Output:**\n```\n(int) 4\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [4,5,6,7,0,1,2]\n(int) target = 3\n```\n\n**Output:**\n```\n(int) -1\n```",
    "solutions": {}
  },
  "search-suggestions-system": {
    "id": "search-suggestions-system",
    "title": "Search Suggestions System",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "string",
      "trie"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(ns)",
    "sc": "O(1)",
    "leetcode": "search-suggestions-system",
    "gfg": null,
    "leetid": 1268,
    "content": "---\nlayout: post\ntitle: Search Suggestions System\ntopics: [array, string, trie]\nlangs: [java]\ntc: O(ns)\nsc: O(1)\nleetid: 1268\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: search-suggestions-system\n---\n\nYou are given an array of strings `products` and a string `searchWord`.\n\nDesign a system that suggests at most three `product` names from products after each character of `searchWord` is typed. \nSuggested products should have common prefix with `searchWord`. \nIf there are more than three products with a common prefix return the three **lexicographically** minimums products.\n\nReturn a list of lists of the suggested products after each character of searchWord is typed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\nOutput: [\n[\"mobile\",\"moneypot\",\"monitor\"],\n[\"mobile\",\"moneypot\",\"monitor\"],\n[\"mouse\",\"mousepad\"],\n[\"mouse\",\"mousepad\"],\n[\"mouse\",\"mousepad\"]\n]\nExplanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"]\nAfter typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"]\nAfter typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"]\n```\n\n**Example 2:** \n```\nInput: products = [\"havana\"], searchWord = \"havana\"\nOutput: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n```\n\n**Example 3:**\n```\nInput: products = [\"havana\"], searchWord = \"tatiana\"\nOutput: [[],[],[],[],[],[],[]]\n```\n\n**Example 4:**\n```\nInput: products = [\"bags\",\"baggage\",\"banner\",\"box\",\"cloths\"], searchWord = \"bags\"\nOutput: [[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\"],[\"bags\"]]\n```",
    "body": "You are given an array of strings `products` and a string `searchWord`.\n\nDesign a system that suggests at most three `product` names from products after each character of `searchWord` is typed. \nSuggested products should have common prefix with `searchWord`. \nIf there are more than three products with a common prefix return the three **lexicographically** minimums products.\n\nReturn a list of lists of the suggested products after each character of searchWord is typed.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\nOutput: [\n[\"mobile\",\"moneypot\",\"monitor\"],\n[\"mobile\",\"moneypot\",\"monitor\"],\n[\"mouse\",\"mousepad\"],\n[\"mouse\",\"mousepad\"],\n[\"mouse\",\"mousepad\"]\n]\nExplanation: products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"]\nAfter typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"]\nAfter typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"]\n```\n\n**Example 2:** \n```\nInput: products = [\"havana\"], searchWord = \"havana\"\nOutput: [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\n```\n\n**Example 3:**\n```\nInput: products = [\"havana\"], searchWord = \"tatiana\"\nOutput: [[],[],[],[],[],[],[]]\n```\n\n**Example 4:**\n```\nInput: products = [\"bags\",\"baggage\",\"banner\",\"box\",\"cloths\"], searchWord = \"bags\"\nOutput: [[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\",\"banner\"],[\"baggage\",\"bags\"],[\"bags\"]]\n```",
    "solutions": {}
  },
  "serialize-and-deserialize-binary-tree": {
    "id": "serialize-and-deserialize-binary-tree",
    "title": "Serialize and Deserialize Binary Tree",
    "difficulty": "hard",
    "companies": [
      "facebook",
      "google",
      "linkedin",
      "uber"
    ],
    "topics": [
      "string",
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "design",
      "binary-tree"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "serialize-and-deserialize-binary-tree",
    "gfg": null,
    "leetid": 297,
    "content": "---\nlayout: post\ntitle: Serialize and Deserialize Binary Tree\ntopics: [string, tree, depth-first-search, breadth-first-search, design, binary-tree]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 297\ncompanies: [facebook, google, linkedin, uber]\ndifficulty: hard\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: serialize-and-deserialize-binary-tree\n---\nSerialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n \n---\n## Test Cases\n**Example 1:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" />\n\n```\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n* The number of nodes in the tree is in the range `[0, 10<sup>4</sup>]`.\n* `-1000 <= Node.val <= 1000`\n\n        ",
    "body": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n \n---\n## Test Cases\n**Example 1:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" />\n\n```\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n* The number of nodes in the tree is in the range `[0, 10<sup>4</sup>]`.\n* `-1000 <= Node.val <= 1000`\n\n        ",
    "solutions": {}
  },
  "set-intersection-size-at-least-two": {
    "id": "set-intersection-size-at-least-two",
    "title": "Set Intersection Size At Least Two",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "greedy",
      "sorting"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nlogn)",
    "sc": "O(1)",
    "leetcode": "set-intersection-size-at-least-two",
    "gfg": null,
    "leetid": 757,
    "content": "---\nlayout: post\ntitle: Set Intersection Size At Least Two\ntopics: [array, greedy, sorting]\nlangs: [java]\ntc: O(nlogn)\nsc: O(1)\nleetid: 757\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: set-intersection-size-at-least-two\n---\n\nAn integer interval `[a, b]` (for integers `a < b`) is a set of all consecutive integers from `a` to `b`, including `a` and `b`.\n\nFind the minimum size of a set S such that for every integer interval A in `intervals`, \nthe intersection of S with A has a size of at least two.\n\n---\n## How to Solve\n\nFirst sort the intervals, with their ending points from low to high\n\nWe deal with the sorted intervals one by one.\n1. If there is no number in this interval being chosen before, we pick up 2 biggest number in this interval. \n(the biggest number have the most possibility to be used by next interval)\n2. If there is one number in this interval being chosen before, we pick up the biggest number in this interval.\n3. If there are already two numbers in this interval being chosen before, we can skip this interval since the requirement has been fulfilled.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) intervals = [[1,3],[1,4],[2,5],[3,5]]\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nConsider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.\nAlso, there isn't a smaller size set that fulfills the above condition.\nThus, we output the size of this set, which is 3.\n```\n\n---\n\n**Input:**\n```\n(int[]) intervals = [[1,2],[2,3],[2,4],[4,5]]\n```\n\n**Output:**\n```\n(int) 5\n```\n\n**Explanation:**\n```\nAn example of a minimum sized set is {1, 2, 3, 4, 5}.\n```",
    "body": "An integer interval `[a, b]` (for integers `a < b`) is a set of all consecutive integers from `a` to `b`, including `a` and `b`.\n\nFind the minimum size of a set S such that for every integer interval A in `intervals`, \nthe intersection of S with A has a size of at least two.\n\n---\n## How to Solve\n\nFirst sort the intervals, with their ending points from low to high\n\nWe deal with the sorted intervals one by one.\n1. If there is no number in this interval being chosen before, we pick up 2 biggest number in this interval. \n(the biggest number have the most possibility to be used by next interval)\n2. If there is one number in this interval being chosen before, we pick up the biggest number in this interval.\n3. If there are already two numbers in this interval being chosen before, we can skip this interval since the requirement has been fulfilled.\n\n---\n\n## Test Cases\n\n**Input:**\n```\n(int[]) intervals = [[1,3],[1,4],[2,5],[3,5]]\n```\n\n**Output:**\n```\n(int) 3\n```\n\n**Explanation:**\n```\nConsider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.\nAlso, there isn't a smaller size set that fulfills the above condition.\nThus, we output the size of this set, which is 3.\n```\n\n---\n\n**Input:**\n```\n(int[]) intervals = [[1,2],[2,3],[2,4],[4,5]]\n```\n\n**Output:**\n```\n(int) 5\n```\n\n**Explanation:**\n```\nAn example of a minimum sized set is {1, 2, 3, 4, 5}.\n```",
    "solutions": {}
  },
  "set-matrix-zeroes": {
    "id": "set-matrix-zeroes",
    "title": "Set Matrix Zeroes",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "microsoft",
      "oracle"
    ],
    "topics": [
      "array",
      "hash-table",
      "matrix"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n<sup>2</sup>)",
    "sc": "O(1)",
    "leetcode": "set-matrix-zeroes",
    "gfg": null,
    "leetid": 73,
    "content": "---\nlayout: post\ntitle: Set Matrix Zeroes\ntopics: [array, hash-table, matrix]\nlangs: [java]\ntc: O(n<sup>2</sup>)\nsc: O(1)\nleetid: 73\ncompanies: [adobe, amazon, apple, bloomberg, facebook, microsoft, oracle]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: set-matrix-zeros\nleetcode: set-matrix-zeroes\n---\n\nGiven an `m x n` integer `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it in place.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" alt=\"image\" />\n\n```\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n```\n\n**Example 2:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" alt=\"Image\" />\n```\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n```",
    "body": "Given an `m x n` integer `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it in place.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" alt=\"image\" />\n\n```\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n```\n\n**Example 2:**\n\n<MdxImage src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" alt=\"Image\" />\n```\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n```",
    "solutions": {}
  },
  "shortest-path-in-binary-matrix": {
    "id": "shortest-path-in-binary-matrix",
    "title": "Shortest Path in Binary Matrix",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "breadth-first-search",
      "matrix"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(1)",
    "sc": "O(1)",
    "leetcode": "shortest-path-in-binary-matrix",
    "gfg": null,
    "leetid": 1091,
    "content": "---\nlayout: post\ntitle: Shortest Path in Binary Matrix\ntopics: [array, breadth-first-search, matrix]\nlangs: [java]\ntc: O(1)\nsc: O(1)\nleetid: 1091\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: shortest-path-in-binary-matrix\n---\n\nGiven an `n x n` binary matrix `grid`, return the length of the shortest clear path in the matrix. If there is no clear path, return `-1`.\n\nA clear path in a binary matrix is a path from the top-left cell (i.e., (`0`, `0`)) to the bottom-right cell (i.e., (`n - 1`, `n - 1`)) such that:\n- All the visited cells of the path are 0. \n- All the adjacent cells of the path are 8-directionally connected (i.e., they are different, and they share an edge or a corner).\n\nThe length of a clear path is the number of visited cells of this path.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: grid = [[0,1],[1,0]]\nOutput: 2\n```\n\n**Example 2:**\n\n```\nInput: grid = [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\n```",
    "body": "Given an `n x n` binary matrix `grid`, return the length of the shortest clear path in the matrix. If there is no clear path, return `-1`.\n\nA clear path in a binary matrix is a path from the top-left cell (i.e., (`0`, `0`)) to the bottom-right cell (i.e., (`n - 1`, `n - 1`)) such that:\n- All the visited cells of the path are 0. \n- All the adjacent cells of the path are 8-directionally connected (i.e., they are different, and they share an edge or a corner).\n\nThe length of a clear path is the number of visited cells of this path.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: grid = [[0,1],[1,0]]\nOutput: 2\n```\n\n**Example 2:**\n\n```\nInput: grid = [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\n```",
    "solutions": {}
  },
  "simplify-path": {
    "id": "simplify-path",
    "title": "Simplify Path",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "string",
      "stack"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "simplify-path",
    "gfg": null,
    "leetid": 71,
    "content": "---\nlayout: post\ntitle: Simplify Path\ndifficulty: medium\ntopics: [string, stack]\nlangs: [java, py]\ntc: O(n)\nsc: O(1)\ncompanies: [facebook]\nleetid: 71\nleetcode: simplify-path\ngfg: \ninterviewbit: \nhackerrank: \n---\nYou are given an *absolute* path for a Unix-style file system, which always begins with a slash `'/'`. Your task is to transform this absolute path into its **simplified canonical path**.\nThe *rules* of a Unix-style file system are as follows:\n\t\n* A single period `'.'` represents the current directory.\n\t\n* A double period `'..'` represents the previous/parent directory.\n\t\n* Multiple consecutive slashes such as `'//'` and `'///'` are treated as a single slash `'/'`.\n\t\n* Any sequence of periods that does **not match** the rules above should be treated as a **valid directory or** **file ****name**. For example, `'...' `and `'....'` are valid directory or file names.\nThe simplified canonical path should follow these *rules*:\n\t\n* The path must start with a single slash `'/'`.\n\t\n* Directories within the path must be separated by exactly one slash `'/'`.\n\t\n* The path must not end with a slash `'/'`, unless it is the root directory.\n\t\n* The path must not have any single or double periods (`'.'` and `'..'`) used to denote current or parent directories.\nReturn the **simplified canonical path**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation:\nThe trailing slash should be removed.\n```\n\n**Example 2:**\n```\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation:\nMultiple consecutive slashes are replaced by a single one.\n```\n\n**Example 3:**\n```\nInput: path = \"/home/user/Documents/../Pictures\"\nOutput: \"/home/user/Pictures\"\nExplanation:\nA double period \"..\" refers to the directory up a level (the parent directory).\n```\n\n**Example 4:**\n```\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation:\nGoing one level up from the root directory is not possible.\n```\n\n**Example 5:**\n```\nInput: path = \"/.../a/../b/c/../d/./\"\nOutput: \"/.../b/d\"\nExplanation:\n\"...\" is a valid name for a directory in this problem.\n```\n \n**Constraints:**\n\t\n* `1 <= path.length <= 3000`\n\t\n* `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.\n\t\n* `path` is a valid absolute Unix path.\n\n",
    "body": "You are given an *absolute* path for a Unix-style file system, which always begins with a slash `'/'`. Your task is to transform this absolute path into its **simplified canonical path**.\nThe *rules* of a Unix-style file system are as follows:\n\t\n* A single period `'.'` represents the current directory.\n\t\n* A double period `'..'` represents the previous/parent directory.\n\t\n* Multiple consecutive slashes such as `'//'` and `'///'` are treated as a single slash `'/'`.\n\t\n* Any sequence of periods that does **not match** the rules above should be treated as a **valid directory or** **file ****name**. For example, `'...' `and `'....'` are valid directory or file names.\nThe simplified canonical path should follow these *rules*:\n\t\n* The path must start with a single slash `'/'`.\n\t\n* Directories within the path must be separated by exactly one slash `'/'`.\n\t\n* The path must not end with a slash `'/'`, unless it is the root directory.\n\t\n* The path must not have any single or double periods (`'.'` and `'..'`) used to denote current or parent directories.\nReturn the **simplified canonical path**.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation:\nThe trailing slash should be removed.\n```\n\n**Example 2:**\n```\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation:\nMultiple consecutive slashes are replaced by a single one.\n```\n\n**Example 3:**\n```\nInput: path = \"/home/user/Documents/../Pictures\"\nOutput: \"/home/user/Pictures\"\nExplanation:\nA double period \"..\" refers to the directory up a level (the parent directory).\n```\n\n**Example 4:**\n```\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation:\nGoing one level up from the root directory is not possible.\n```\n\n**Example 5:**\n```\nInput: path = \"/.../a/../b/c/../d/./\"\nOutput: \"/.../b/d\"\nExplanation:\n\"...\" is a valid name for a directory in this problem.\n```\n \n**Constraints:**\n\t\n* `1 <= path.length <= 3000`\n\t\n* `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.\n\t\n* `path` is a valid absolute Unix path.\n\n",
    "solutions": {}
  },
  "single-number-ii": {
    "id": "single-number-ii",
    "title": "Single Number II",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "bit-manipulation"
    ],
    "langs": [
      "java",
      "cpp",
      "c"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "single-number-ii",
    "gfg": null,
    "leetid": 137,
    "content": "---\nlayout: post\ntitle: Single Number II\ntopics: [array, bit-manipulation]\nlangs: [java, cpp, c]\ntc: O(n)\nsc: O(1)\nleetid: 137\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: single-number-ii\n---\nGiven an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. *Find the single element and return it*.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [2,2,3,2]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 3 * 10<sup>4</sup>`\n\t\n* `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`\n\t\n* Each element in `nums` appears exactly **three times** except for one element which appears **once**.\n\n        ",
    "body": "Given an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. *Find the single element and return it*.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n \n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [2,2,3,2]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n```\n \n**Constraints:**\n\t\n* `1 <= nums.length <= 3 * 10<sup>4</sup>`\n\t\n* `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`\n\t\n* Each element in `nums` appears exactly **three times** except for one element which appears **once**.\n\n        ",
    "solutions": {}
  },
  "sliding-window-maximum": {
    "id": "sliding-window-maximum",
    "title": "Sliding Window Maximum",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "heap",
      "queue",
      "sliding-window"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(k)",
    "leetcode": "sliding-window-maximum",
    "gfg": null,
    "leetid": 239,
    "content": "---\nlayout: post\ntitle: Sliding Window Maximum\ntopics: [array, heap, queue, sliding-window]\nlangs: [java, py]\ntc: O(n)\nsc: O(k)\nleetid: 239\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: sliding-window-maximum\n---\n\nYou are given an array of integers nums, \nthere is a sliding window of size `k` which is moving from the very left of the array to the very right. \nYou can only see the `k` numbers in the window. \nEach time the sliding window moves right by one position.\n\nReturn the _max sliding window_.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [1,3,-1,-3,5,3,6,7]\n(int) k = 3\n```\n\n**Output:** \n```\n(int[]) [3,3,5,5,6,7]\n```\n\n**Explanation:**\n```\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [1]\n(int) k = 1\n```\n\n**Output:**\n```\n(int[]) [1]\n```",
    "body": "You are given an array of integers nums, \nthere is a sliding window of size `k` which is moving from the very left of the array to the very right. \nYou can only see the `k` numbers in the window. \nEach time the sliding window moves right by one position.\n\nReturn the _max sliding window_.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [1,3,-1,-3,5,3,6,7]\n(int) k = 3\n```\n\n**Output:** \n```\n(int[]) [3,3,5,5,6,7]\n```\n\n**Explanation:**\n```\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [1]\n(int) k = 1\n```\n\n**Output:**\n```\n(int[]) [1]\n```",
    "solutions": {}
  },
  "sort-colors": {
    "id": "sort-colors",
    "title": "Sort Colors",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "sorting",
      "two-pointers"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "sort-colors",
    "gfg": "sort-an-array-of-0s-1s-and-2s",
    "leetid": 75,
    "content": "---\nlayout: post\ntitle: Sort Colors\ntopics: [array, sorting, two-pointers]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 75\ncompanies: [facebook]\ngfg: sort-an-array-of-0s-1s-and-2s\ndifficulty: medium\nhackerrank: \ninterviewbit: sort-colors\nleetcode: sort-colors\nhellointerview: code/two-pointers/sort-colors\n---\n\nGiven an array `nums` with `n` objects colored red, white, or blue, \nsort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [2,0,2,1,1,0]\n```\n\n**Output:** \n```\n(int[]) [0,0,1,1,2,2]\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [2,0,1]\n```\n\n**Output:**\n```\n(int[]) [0,1,2]\n```\n",
    "body": "Given an array `nums` with `n` objects colored red, white, or blue, \nsort them **in-place** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[]) nums = [2,0,2,1,1,0]\n```\n\n**Output:** \n```\n(int[]) [0,0,1,1,2,2]\n```\n\n---\n\n**Input:**\n```\n(int[]) nums = [2,0,1]\n```\n\n**Output:**\n```\n(int[]) [0,1,2]\n```\n",
    "solutions": {}
  },
  "sort-list": {
    "id": "sort-list",
    "title": "Sort List",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "divide-and-conquer",
      "linked-list",
      "sorting",
      "two-pointers"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(nlogn)",
    "sc": "O(1)",
    "leetcode": "sort-list",
    "gfg": null,
    "leetid": 148,
    "content": "---\nlayout: post\ntitle: Sort List\ntopics: [divide-and-conquer, linked-list, sorting, two-pointers]\nlangs: [java, cpp]\ntc: O(nlogn)\nsc: O(1)\nleetid: 148\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: sort-list\n---\n\nGiven the `head` of a linked list, return the list after sorting it in ascending order.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n```\n\n**Example 2:**\n```\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n```",
    "body": "Given the `head` of a linked list, return the list after sorting it in ascending order.\n\n---\n\n## Test Cases\n\n**Example 1:**\n```\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n```\n\n**Example 2:**\n```\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n```",
    "solutions": {}
  },
  "split-array-largest-sum": {
    "id": "split-array-largest-sum",
    "title": "Split Array Largest Sum",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "dynamic-programming",
      "greedy"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n<sup>2</sup>m)",
    "sc": "O(nm)",
    "leetcode": "split-array-largest-sum",
    "gfg": null,
    "leetid": 410,
    "content": "---\nlayout: post\ntitle: Split Array Largest Sum\ntopics: [array, dynamic-programming, greedy]\nlangs: [java]\ntc: O(n<sup>2</sup>m)\nsc: O(nm)\nleetid: 410\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: split-array-largest-sum\n---\n\nGiven an array nums which consists of non-negative integers and an integer `m`, \nyou can split the array into `m` non-empty continuous subarrays.\n\nWrite an algorithm to minimize the largest sum among these `m` subarrays.\n\n---\n\n## How to Solve\n\n1. Fill the array `prefixSum`. The i<sup>th</sup> index of `prefixSum` will have the sum of integers in nums in the range `[0, i - 1]` with `prefix[0] = 0`.\n2. Initialize an array memo where `memo[currIndex][subarrayCount]` will store the result for the subproblem `(currIndex, subarrayCount)`. \n3. We need to find the value of `memo[0][m]` which represents the minimum largest subarray sum starting at index `0` with `m` subarrays. \n   1. But we only know what the result will be for the base cases. \n   2. To fill the memo array, we will iterate subarrayCount over the range `[1, m]` (starting at `1` because that is our base case) and iterate `currIndex` over the range `[0, n - 1]`.\n4. For each value of `subarrayCount` and `currIndex`, we will update `memo[subarrayCount][currIndex]`:\n   1. As the sum of the elements between `currIndex` and the end of the array if we are at a base case (`subarrayCount` equals 1).\n   2. Otherwise, we will use the recurrence relation and the results from previously solved subproblems to calculate `memo[subarrayCount][currIndex]`.\n5. Return the value stored at `memo[0][m]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [7,2,5,10,8], m = 2\nOutput: 18\nExplanation:\nThere are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8],\nwhere the largest sum among the two subarrays is only 18.\n```\n\n**Example 2:** \n```\nInput: nums = [1,2,3,4,5], m = 2\nOutput: 9\n```\n\n**Example 3:**\n```\nInput: nums = [1,4,4], m = 3\nOutput: 4\n```",
    "body": "Given an array nums which consists of non-negative integers and an integer `m`, \nyou can split the array into `m` non-empty continuous subarrays.\n\nWrite an algorithm to minimize the largest sum among these `m` subarrays.\n\n---\n\n## How to Solve\n\n1. Fill the array `prefixSum`. The i<sup>th</sup> index of `prefixSum` will have the sum of integers in nums in the range `[0, i - 1]` with `prefix[0] = 0`.\n2. Initialize an array memo where `memo[currIndex][subarrayCount]` will store the result for the subproblem `(currIndex, subarrayCount)`. \n3. We need to find the value of `memo[0][m]` which represents the minimum largest subarray sum starting at index `0` with `m` subarrays. \n   1. But we only know what the result will be for the base cases. \n   2. To fill the memo array, we will iterate subarrayCount over the range `[1, m]` (starting at `1` because that is our base case) and iterate `currIndex` over the range `[0, n - 1]`.\n4. For each value of `subarrayCount` and `currIndex`, we will update `memo[subarrayCount][currIndex]`:\n   1. As the sum of the elements between `currIndex` and the end of the array if we are at a base case (`subarrayCount` equals 1).\n   2. Otherwise, we will use the recurrence relation and the results from previously solved subproblems to calculate `memo[subarrayCount][currIndex]`.\n5. Return the value stored at `memo[0][m]`.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [7,2,5,10,8], m = 2\nOutput: 18\nExplanation:\nThere are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8],\nwhere the largest sum among the two subarrays is only 18.\n```\n\n**Example 2:** \n```\nInput: nums = [1,2,3,4,5], m = 2\nOutput: 9\n```\n\n**Example 3:**\n```\nInput: nums = [1,4,4], m = 3\nOutput: 4\n```",
    "solutions": {}
  },
  "string-to-integer-atoi": {
    "id": "string-to-integer-atoi",
    "title": "String to Integer Atoi",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "string"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "string-to-integer-atoi",
    "gfg": null,
    "leetid": 8,
    "content": "---\nlayout: post\ntitle: String to Integer Atoi\ntopics: [string]\nlangs: [java, cpp]\ntc: O(n)\nsc: O(1)\nleetid: 8\ncompanies: [facebook]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: string-to-integer-atoi\n---\n\nImplement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n\nThe algorithm for myAtoi(string s) is as follows:\n1. Read in and ignore any leading whitespace. \n2. Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. \n3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. \n4. Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). \n5. If the integer is out of the `32`-bit signed integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -2<sup>31</sup> should be clamped to -2<sup>31</sup>, and integers greater than 2<sup>31</sup> - 1 should be clamped to 2<sup>31</sup> - 1. \n6. Return the integer as the final result.\n\n_**Note:**_\n- Only the space character ' ' is considered a whitespace character.\n- Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-2^31, 2^31 - 1], the final result is 42.\n```\n\n**Example 2:** \n```\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-2^31, 2^31 - 1], the final result is -42.\n```\n\n**Example 3:**\n```\nInput: s = \"4193 with words 54\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.\n```",
    "body": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n\nThe algorithm for myAtoi(string s) is as follows:\n1. Read in and ignore any leading whitespace. \n2. Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. \n3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. \n4. Convert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). \n5. If the integer is out of the `32`-bit signed integer range [-2<sup>31</sup>, 2<sup>31</sup> - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -2<sup>31</sup> should be clamped to -2<sup>31</sup>, and integers greater than 2<sup>31</sup> - 1 should be clamped to 2<sup>31</sup> - 1. \n6. Return the integer as the final result.\n\n_**Note:**_\n- Only the space character ' ' is considered a whitespace character.\n- Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-2^31, 2^31 - 1], the final result is 42.\n```\n\n**Example 2:** \n```\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-2^31, 2^31 - 1], the final result is -42.\n```\n\n**Example 3:**\n```\nInput: s = \"4193 with words 54\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.\n```",
    "solutions": {}
  },
  "subarray-sum-equals-k": {
    "id": "subarray-sum-equals-k",
    "title": "Subarray Sum Equals K",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "hash-table"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "subarray-sum-equals-k",
    "gfg": null,
    "leetid": 560,
    "content": "---\nlayout: post\ntitle: Subarray Sum Equals K\ntopics: [array, hash-table]\nlangs: [java, py]\ntc: O(n)\nsc: O(n)\nleetid: 560\ndifficulty: medium\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: subarray-sum-equals-k\nmetacareers: 840934449713537\n---\n\nGiven an array of integers nums and an integer `k`, return the total number of continuous subarray whose sum equals to `k`.\n\n---\n## How to Solve\n\nThe idea behind this approach is as follows: \n\nIf the cumulative sum(represented by `sum[i]` for sum up to i<sup>th</sup> index) up to two indices is the same, \nthe sum of the elements lying in between those indices is zero. \nExtending the same thought further, if the cumulative sum up to two indices, say `i` and `j` is at a difference of `k` \ni.e. `if sum[i] - sum[j] = k`, the sum of elements lying between indices `i` and `j` is `k`.\n\nBased on these thoughts, we make use of a hashmap `map` which is used to store the cumulative sum up to all the indices possible along with the number of times the same sum occurs. \nWe store the data in the form: `(sum_i, no. of occurrences of sum_i)`. \nWe traverse over the array `nums` and keep on finding the cumulative sum. \nEvery time we encounter a new sum, we make a new entry in the hashmap corresponding to that sum. \nIf the same sum occurs again, we increment the count corresponding to that sum in the hashmap. \nFurther, for every sum encountered, we also determine the number of times the sum `sum-k` has occurred already, \nsince it will determine the number of times a subarray with sum `k` has occurred up to the current index. \nWe increment the `count` by the same amount.\n\nAfter the complete array has been traversed, the `count` gives the required result.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums = [1,1,1], k = 2\nOutput: 2\n```\n\n**Example 2:**\n```\nInput: nums = [1,2,3], k = 3\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= nums.length <= 2 * 104`\n* `-1000 <= nums[i] <= 1000`\n* `-107 <= k <= 107`",
    "body": "Given an array of integers nums and an integer `k`, return the total number of continuous subarray whose sum equals to `k`.\n\n---\n## How to Solve\n\nThe idea behind this approach is as follows: \n\nIf the cumulative sum(represented by `sum[i]` for sum up to i<sup>th</sup> index) up to two indices is the same, \nthe sum of the elements lying in between those indices is zero. \nExtending the same thought further, if the cumulative sum up to two indices, say `i` and `j` is at a difference of `k` \ni.e. `if sum[i] - sum[j] = k`, the sum of elements lying between indices `i` and `j` is `k`.\n\nBased on these thoughts, we make use of a hashmap `map` which is used to store the cumulative sum up to all the indices possible along with the number of times the same sum occurs. \nWe store the data in the form: `(sum_i, no. of occurrences of sum_i)`. \nWe traverse over the array `nums` and keep on finding the cumulative sum. \nEvery time we encounter a new sum, we make a new entry in the hashmap corresponding to that sum. \nIf the same sum occurs again, we increment the count corresponding to that sum in the hashmap. \nFurther, for every sum encountered, we also determine the number of times the sum `sum-k` has occurred already, \nsince it will determine the number of times a subarray with sum `k` has occurred up to the current index. \nWe increment the `count` by the same amount.\n\nAfter the complete array has been traversed, the `count` gives the required result.\n\n---\n## Test Cases\n\n**Example 1:**\n```\nInput: nums = [1,1,1], k = 2\nOutput: 2\n```\n\n**Example 2:**\n```\nInput: nums = [1,2,3], k = 3\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= nums.length <= 2 * 104`\n* `-1000 <= nums[i] <= 1000`\n* `-107 <= k <= 107`",
    "solutions": {}
  },
  "subsets": {
    "id": "subsets",
    "title": "Subsets",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "amazon",
      "bloomberg",
      "facebook",
      "goldman",
      "google",
      "twitter"
    ],
    "topics": [
      "array",
      "backtracking"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n2<sup>n</sup>)",
    "sc": "O(n)",
    "leetcode": "subsets",
    "gfg": null,
    "leetid": 78,
    "content": "---\nlayout: post\ntitle: Subsets\ntopics: [array, backtracking]\nlangs: [java, cpp]\ntc: O(n2<sup>n</sup>)\nsc: O(n)\nleetid: 78\ncompanies: [adobe, amazon, bloomberg, facebook, goldman, google, twitter]\ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: subsets\n---\n\nGiven an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**Example 2:** \n```\nInput: nums = [0]\nOutput: [[],[0]]\n```",
    "body": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**Example 2:** \n```\nInput: nums = [0]\nOutput: [[],[0]]\n```",
    "solutions": {}
  },
  "super-egg-drop": {
    "id": "super-egg-drop",
    "title": "Super Egg Drop",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "binary-search",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(KlogN)",
    "sc": "O(NK)",
    "leetcode": "super-egg-drop",
    "gfg": null,
    "leetid": 887,
    "content": "---\nlayout: post\ntitle: Super Egg Drop\ntopics: [binary-search, dynamic-programming]\nlangs: [java, py, cpp]\ntc: O(KlogN)\nsc: O(NK)\nleetid: 887\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: super-egg-drop\n---\n\nYou are given `K` identical eggs and you have access to a building with `N` floors labeled from `1` to `N`.\n\nYou know that there exists a floor `F` where `0 <= F <= N` such that any egg dropped at a floor higher than `F` will break, \nand any egg dropped at or below floor `F` will not break.\n\nEach move, \nyou may take an unbroken egg and drop it from any floor `X` (where `1 <= X <= N`). \nIf the egg breaks, you can no longer use it. \nHowever, if the egg does not break, you may **reuse** it in future moves.\n\nReturn the **_minimum number of moves_** that you need to determine with certainty what the value of `F` is.\n\n---\n\n## How to Solve\n\nConsider this problem in a different way:\n`dp[M][K]` means that, given `K` eggs and `M` moves,\nwhat is the maximum number of floor that we can check.\n\nThe dp equation is:\n```\ndp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1,\n```\n\nwhich means we take `1` move to a floor,\nif egg breaks, then we can check `dp[m - 1][k - 1]` floors.\nif egg doesn't breaks, then we can check `dp[m - 1][k]` floors.\n\n`dp[m][k]` is the number of combinations, and it increases exponentially to `N`\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int) k = 1\n(int) n = 2\n```\n\n**Output:** \n```\n(int) 2\n```\n\n**Explanation:**\n```\nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n```\n\n---\n\n**Input:** \n```\n(int) k = 2\n(int) n = 6\n```\n\n**Output:** \n```\n(int) 3\n```\n\n---\n\n**Input:**\n```\n(int) k = 3\n(int) n = 14\n```\n\n**Output:**\n```\n(int) 4\n```\n",
    "body": "You are given `K` identical eggs and you have access to a building with `N` floors labeled from `1` to `N`.\n\nYou know that there exists a floor `F` where `0 <= F <= N` such that any egg dropped at a floor higher than `F` will break, \nand any egg dropped at or below floor `F` will not break.\n\nEach move, \nyou may take an unbroken egg and drop it from any floor `X` (where `1 <= X <= N`). \nIf the egg breaks, you can no longer use it. \nHowever, if the egg does not break, you may **reuse** it in future moves.\n\nReturn the **_minimum number of moves_** that you need to determine with certainty what the value of `F` is.\n\n---\n\n## How to Solve\n\nConsider this problem in a different way:\n`dp[M][K]` means that, given `K` eggs and `M` moves,\nwhat is the maximum number of floor that we can check.\n\nThe dp equation is:\n```\ndp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1,\n```\n\nwhich means we take `1` move to a floor,\nif egg breaks, then we can check `dp[m - 1][k - 1]` floors.\nif egg doesn't breaks, then we can check `dp[m - 1][k]` floors.\n\n`dp[m][k]` is the number of combinations, and it increases exponentially to `N`\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int) k = 1\n(int) n = 2\n```\n\n**Output:** \n```\n(int) 2\n```\n\n**Explanation:**\n```\nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n```\n\n---\n\n**Input:** \n```\n(int) k = 2\n(int) n = 6\n```\n\n**Output:** \n```\n(int) 3\n```\n\n---\n\n**Input:**\n```\n(int) k = 3\n(int) n = 14\n```\n\n**Output:**\n```\n(int) 4\n```\n",
    "solutions": {}
  },
  "swap-nodes-in-pairs": {
    "id": "swap-nodes-in-pairs",
    "title": "Swap Nodes in Pairs",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "linked-list",
      "recursion"
    ],
    "langs": [
      "java",
      "cpp",
      "py",
      "c",
      "go"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "swap-nodes-in-pairs",
    "gfg": null,
    "leetid": 24,
    "content": "---\nlayout: post\ntitle: Swap Nodes in Pairs\ntopics: [linked-list, recursion]\nlangs: [java, cpp, py, c, go]\ntc: O(n)\nsc: O(1)\nleetid: 24\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: swap-nodes-in-pairs\n---\n\nGiven a linked list, swap every two adjacent nodes and return its head. \nYou must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\nExplanation:\n1->2->3->4      ->     2->1->4->3\n```\n\n**Example 2:** \n```\nInput: head = []\nOutput: []\n```",
    "body": "Given a linked list, swap every two adjacent nodes and return its head. \nYou must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\nExplanation:\n1->2->3->4      ->     2->1->4->3\n```\n\n**Example 2:** \n```\nInput: head = []\nOutput: []\n```",
    "solutions": {}
  },
  "task-scheduler": {
    "id": "task-scheduler",
    "title": "Task Scheduler",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "greedy",
      "hash-table"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "task-scheduler",
    "gfg": null,
    "leetid": 621,
    "content": "---\nlayout: post\ntitle: Task Scheduler\ntopics: [array, greedy, hash-table]\nlangs: [java]\ntc: O(n)\nsc: O(1)\nleetid: 621\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: task-scheduler\n---\n\nGiven a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. \nTasks could be done in any order. \nEach task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer `n` that represents the cool-down period between two same tasks (the same letter in the array), \nthat is that there must be at least `n` units of time between any two same tasks.\n\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\nOutput: 8\nExplanation: \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.\n```\n\n**Example 2:** \n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\nOutput: 6\nExplanation: On this case any permutation of size 6 would work since n = 0.\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\nAnd so on.\n```\n\n**Example 2:**\n```\nInput: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\nOutput: 16\nExplanation: \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n```",
    "body": "Given a characters array `tasks`, representing the tasks a CPU needs to do, where each letter represents a different task. \nTasks could be done in any order. \nEach task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\n\nHowever, there is a non-negative integer `n` that represents the cool-down period between two same tasks (the same letter in the array), \nthat is that there must be at least `n` units of time between any two same tasks.\n\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\nOutput: 8\nExplanation: \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.\n```\n\n**Example 2:** \n```\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\nOutput: 6\nExplanation: On this case any permutation of size 6 would work since n = 0.\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\nAnd so on.\n```\n\n**Example 2:**\n```\nInput: tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\nOutput: 16\nExplanation: \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n```",
    "solutions": {}
  },
  "text-justification": {
    "id": "text-justification",
    "title": "Text Justification",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "array",
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nm)",
    "sc": "O(n)",
    "leetcode": "text-justification",
    "gfg": "justify-the-given-text-based-on-the-given-width-of-each-line",
    "leetid": 68,
    "content": "---\nlayout: post\ntitle: Text Justification\ntopics: [array, string]\nlangs: [java]\ntc: O(nm)\nsc: O(n)\nleetid: 68\ncompanies: [facebook]\ngfg: justify-the-given-text-based-on-the-given-width-of-each-line\ndifficulty: hard\nhackerrank: \ninterviewbit: \nleetcode: text-justification\n---\n\nGiven an array of strings `words` and a width `maxWidth`, \nformat the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; \nthat is, pack as many words as you can in each line. \nPad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\n\nExtra spaces between `words` should be distributed as evenly as possible. \nIf the number of spaces on a line does not divide evenly between `words`, \nthe empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified and no extra space is inserted between words.\n\nNote:\n\nA `word` is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed `maxWidth`.\nThe input array `words` contains at least one word.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n```\n\n**Example 2:** \n```\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified becase it contains only one word.\n```\n\n**Example 3:**\n```\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n```",
    "body": "Given an array of strings `words` and a width `maxWidth`, \nformat the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; \nthat is, pack as many words as you can in each line. \nPad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\n\nExtra spaces between `words` should be distributed as evenly as possible. \nIf the number of spaces on a line does not divide evenly between `words`, \nthe empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified and no extra space is inserted between words.\n\nNote:\n\nA `word` is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed `maxWidth`.\nThe input array `words` contains at least one word.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\n```\n\n**Example 2:** \n```\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified becase it contains only one word.\n```\n\n**Example 3:**\n```\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n```",
    "solutions": {}
  },
  "the-skyline-problem": {
    "id": "the-skyline-problem",
    "title": "The Skyline Problem",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "divide-and-conquer",
      "heap"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nlogn)",
    "sc": "O(n)",
    "leetcode": "the-skyline-problem",
    "gfg": null,
    "leetid": 218,
    "content": "---\nlayout: post\ntitle: The Skyline Problem\ntopics: [array, divide-and-conquer, heap]\nlangs: [java]\ntc: O(nlogn)\nsc: O(n)\nleetid: 218\ndifficulty: hard\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: the-skyline-problem\n---\n\nA city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. \nGiven the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n\nThe geometric information of each building is given in the array `buildings` where\n<pre class=\"highlight\">\n<code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>\n</pre>\n\n\n- left<sub>i</sub> is the `x` coordinate of the left edge of the ith building.\n- right<sub>i</sub> is the `x` coordinate of the right edge of the ith building.\n- height<sub>i</sub> is the height of the ith building.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nThe skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. \nEach key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, \nwhich always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. \nAny ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\nNote: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[][]) buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n```\n\n**Output:** \n```\n(int[][]) [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n```",
    "body": "A city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. \nGiven the locations and heights of all the buildings, return the skyline formed by these buildings collectively.\n\nThe geometric information of each building is given in the array `buildings` where\n<pre class=\"highlight\">\n<code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>\n</pre>\n\n\n- left<sub>i</sub> is the `x` coordinate of the left edge of the ith building.\n- right<sub>i</sub> is the `x` coordinate of the right edge of the ith building.\n- height<sub>i</sub> is the height of the ith building.\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nThe skyline should be represented as a list of \"key points\" sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. \nEach key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, \nwhich always has a y-coordinate 0 and is used to mark the skyline's termination where the rightmost building ends. \nAny ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\nNote: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...,[2 3],[4 5],[7 5],[11 5],[12 7],...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...,[2 3],[4 5],[12 7],...]\n\n---\n\n## Test Cases\n\n**Input:** \n```\n(int[][]) buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n```\n\n**Output:** \n```\n(int[][]) [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n```",
    "solutions": {}
  },
  "top-k-frequent-elements": {
    "id": "top-k-frequent-elements",
    "title": "Top K Frequent Elements",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "hash-table",
      "divide-and-conquer",
      "sorting",
      "heap-priority-queue",
      "bucket-sort",
      "counting",
      "quickselect"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nlogn)",
    "sc": "O(n)",
    "leetcode": "top-k-frequent-elements",
    "gfg": null,
    "leetid": 347,
    "content": "---\nlayout: post\ntitle: Top K Frequent Elements\ntopics: [array, hash-table, divide-and-conquer, sorting, heap-priority-queue, bucket-sort, counting, quickselect]\nlangs: [java]\ntc: O(nlogn)\nsc: O(n)\nleetid: 347\ncompanies: \ndifficulty: medium\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: top-k-frequent-elements\n---\nGiven an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n```\n\n**Example 2:**\n```\nInput: nums = [1], k = 1\nOutput: [1]\n```\n\n**Constraints:**\n\t\n* `1 <= nums.length <= 10<sup>5</sup>`\n* `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`\n* `k` is in the range `[1, the number of unique elements in the array]`.\n* It is **guaranteed** that the answer is **unique**.\n**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.",
    "body": "Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.\n\n---\n## Test Cases\n**Example 1:**\n```\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n```\n\n**Example 2:**\n```\nInput: nums = [1], k = 1\nOutput: [1]\n```\n\n**Constraints:**\n\t\n* `1 <= nums.length <= 10<sup>5</sup>`\n* `-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>`\n* `k` is in the range `[1, the number of unique elements in the array]`.\n* It is **guaranteed** that the answer is **unique**.\n**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.",
    "solutions": {}
  },
  "trapping-rain-water": {
    "id": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "difficulty": "hard",
    "companies": [
      "facebook",
      "google",
      "amazon",
      "adobe"
    ],
    "topics": [
      "array",
      "stack",
      "two-pointers"
    ],
    "langs": [
      "java",
      "go",
      "c",
      "cpp",
      "py",
      "js",
      "ts",
      "cs"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "trapping-rain-water",
    "gfg": "trapping-rain-water",
    "leetid": 42,
    "content": "---\nlayout: post\ntitle: Trapping Rain Water\ntopics: [array, stack, two-pointers]\nlangs: [java, go, c, cpp, py, js, ts, cs]\ntc: O(n)\nsc: O(1)\nleetid: 42\ngfg: trapping-rain-water\ndifficulty: hard\ncompanies: [facebook, google, amazon, adobe]\nhackerrank: \ninterviewbit: container-with-most-water\nleetcode: trapping-rain-water\nhellointerview: code/two-pointers/container-with-most-water\n---\n\nGiven n non-negative integers representing an elevation map where the width of each bar is 1, \ncompute how much water it can trap after raining.\n\n---\n## Test Cases\n\n**Example 1:**\n<MdxImage src=\"code/rainwatertrap.png\" alt=\"Rain Water\" />\n\n```\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. \nIn this case, 6 units of rain water (blue section) are being trapped.\n```\n\n**Example 2:**\n```\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n```\n",
    "body": "Given n non-negative integers representing an elevation map where the width of each bar is 1, \ncompute how much water it can trap after raining.\n\n---\n## Test Cases\n\n**Example 1:**\n<MdxImage src=\"code/rainwatertrap.png\" alt=\"Rain Water\" />\n\n```\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. \nIn this case, 6 units of rain water (blue section) are being trapped.\n```\n\n**Example 2:**\n```\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n```\n",
    "solutions": {}
  },
  "valid-number": {
    "id": "valid-number",
    "title": "Valid Number",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "string"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(n)",
    "sc": "O(1)",
    "leetcode": "valid-number",
    "gfg": null,
    "leetid": 65,
    "content": "---\nlayout: post\ntitle: Valid Number\ntopics: [string]\nlangs: [java, cpp, py]\ntc: O(n)\nsc: O(1)\nleetid: 65\ndifficulty: hard\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: valid-number\n---\n\nA valid number can be split up into these components (in order):\n1. A decimal number or an integer.\n2. (Optional) An `'e'` or `'E'`, followed by an integer.\n\nA decimal number can be split up into these components (in order):\n1. (Optional) A sign character (either `'+'` or `'-'`).\n2. One of the following formats:\n   1. One or more digits, followed by a dot `'.'`.\n   2. One or more digits, followed by a dot `'.'`, followed by one or more digits.\n   3. A dot `'.'`, followed by one or more digits.\n   \nAn integer can be split up into these components (in order):\n1. (Optional) A sign character (either '+' or '-').\n2. One or more digits.\n\nFor example, \nall the following are valid numbers: \n`[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]`, \nwhile the following are not valid numbers: `[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]`.\n\nGiven a string `s`, return true if `s` is a valid number.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"e\"\nOutput: false\n```\n\n**Example 2:** \n```\nInput: s = \"5.\"\nOutput: true\n```",
    "body": "A valid number can be split up into these components (in order):\n1. A decimal number or an integer.\n2. (Optional) An `'e'` or `'E'`, followed by an integer.\n\nA decimal number can be split up into these components (in order):\n1. (Optional) A sign character (either `'+'` or `'-'`).\n2. One of the following formats:\n   1. One or more digits, followed by a dot `'.'`.\n   2. One or more digits, followed by a dot `'.'`, followed by one or more digits.\n   3. A dot `'.'`, followed by one or more digits.\n   \nAn integer can be split up into these components (in order):\n1. (Optional) A sign character (either '+' or '-').\n2. One or more digits.\n\nFor example, \nall the following are valid numbers: \n`[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]`, \nwhile the following are not valid numbers: `[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]`.\n\nGiven a string `s`, return true if `s` is a valid number.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"e\"\nOutput: false\n```\n\n**Example 2:** \n```\nInput: s = \"5.\"\nOutput: true\n```",
    "solutions": {}
  },
  "valid-sudoku": {
    "id": "valid-sudoku",
    "title": "Valid Sudoku",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "hash-table",
      "matrix"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(81)",
    "sc": "O(81)",
    "leetcode": "valid-sudoku",
    "gfg": null,
    "leetid": 36,
    "content": "---\nlayout: post\ntitle: Valid Sudoku\ntopics: [array, hash-table, matrix]\nlangs: [java]\ntc: O(81)\nsc: O(81)\nleetid: 36\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: valid-sudoku\n---\n\nDetermine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n- Each row must contain the digits 1-9 without repetition.\n- Each column must contain the digits 1-9 without repetition.\n- Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n_**Note:**_\n- A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n- Only the filled cells need to be validated according to the mentioned rules.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. \nSince there are two 8's in the top left 3x3 sub-box, it is invalid.\n```",
    "body": "Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n- Each row must contain the digits 1-9 without repetition.\n- Each column must contain the digits 1-9 without repetition.\n- Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n_**Note:**_\n- A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n- Only the filled cells need to be validated according to the mentioned rules.\n\n---\n\n## Test Cases\n\n**Example 1:** \n\n```\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n```\n\n**Example 2:**\n\n```\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. \nSince there are two 8's in the top left 3x3 sub-box, it is invalid.\n```",
    "solutions": {}
  },
  "vertical-order-traversal-of-a-binary-tree": {
    "id": "vertical-order-traversal-of-a-binary-tree",
    "title": "Vertical Order Traversal of a Binary Tree",
    "difficulty": "hard",
    "companies": [
      "facebook",
      "google"
    ],
    "topics": [
      "hash-table",
      "tree",
      "depth-first-search",
      "breadth-first-search",
      "sorting",
      "binary-tree"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "vertical-order-traversal-of-a-binary-tree",
    "gfg": null,
    "leetid": 1029,
    "content": "---\nlayout: post\ntitle: Vertical Order Traversal of a Binary Tree\ndifficulty: hard\ntopics: [hash-table, tree, depth-first-search, breadth-first-search, sorting, binary-tree]\nlangs: [java]\ntc: O(n)\nsc: O(n)\ncompanies: [facebook, google]\nleetid: 1029\nleetcode: vertical-order-traversal-of-a-binary-tree\ngfg: \ninterviewbit: \nhackerrank: \n---\nGiven the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.\nFor each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.\nThe **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\nReturn *the **vertical order traversal** of the binary tree*.\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\" style={{width: '431px', height: '304px'}} />\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\nExplanation:\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\n```\n\n**Example 2:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\" style={{width: '512px', height: '304px'}} />\n```\nInput: root = [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n```\n\n**Example 3:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\" style={{width: '512px', height: '304px'}} />\n```\nInput: root = [1,2,3,4,6,5,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[1, 1000]`.\n\t\n* `0 <= Node.val <= 1000`\n\n",
    "body": "Given the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.\nFor each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.\nThe **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.\nReturn *the **vertical order traversal** of the binary tree*.\n \n---\n## Test Cases\n**Example 1:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg\" style={{width: '431px', height: '304px'}} />\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\nExplanation:\nColumn -1: Only node 9 is in this column.\nColumn 0: Nodes 3 and 15 are in this column in that order from top to bottom.\nColumn 1: Only node 20 is in this column.\nColumn 2: Only node 7 is in this column.\n```\n\n**Example 2:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg\" style={{width: '512px', height: '304px'}} />\n```\nInput: root = [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nColumn -2: Only node 4 is in this column.\nColumn -1: Only node 2 is in this column.\nColumn 0: Nodes 1, 5, and 6 are in this column.\n          1 is at the top, so it comes first.\n          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.\nColumn 1: Only node 3 is in this column.\nColumn 2: Only node 7 is in this column.\n```\n\n**Example 3:**\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg\" style={{width: '512px', height: '304px'}} />\n```\nInput: root = [1,2,3,4,6,5,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n```\n \n**Constraints:**\n\t\n* The number of nodes in the tree is in the range `[1, 1000]`.\n\t\n* `0 <= Node.val <= 1000`\n\n",
    "solutions": {}
  },
  "where-will-the-ball-fall": {
    "id": "where-will-the-ball-fall",
    "title": "Where Will the Ball Fall",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "array",
      "depth-first-search",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(nm)",
    "sc": "O(m)",
    "leetcode": "where-will-the-ball-fall",
    "gfg": null,
    "leetid": 1706,
    "content": "---\nlayout: post\ntitle: Where Will the Ball Fall\ntopics: [array, depth-first-search, dynamic-programming]\nlangs: [java, cpp]\ntc: O(nm)\nsc: O(m)\nleetid: 1706\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: where-will-the-ball-fall\n---\n\nYou have a 2-D grid of size `m x n` representing a box, and you have `n` balls. The box is open on the top and bottom sides.\n\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n- A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`. \n- A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.\n\nWe drop one ball at the top of each column of the box. \nEach ball can get stuck in the box or fall out of the bottom. \nA ball gets stuck if it hits a `\"V\"` shaped pattern between two boards or if a board redirects the ball into either wall of the box.\n\nReturn an array answer of size `n` where `answer[i]` is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, \nor `-1` if the ball gets stuck in the box.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/ball.jpeg\" alt=\"Ball\" />\n\n**Example 1:** \n```\nInput: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\nOutput: [1,-1,-1,-1,-1]\nExplanation: This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n```\n\n**Example 2:** \n```\nInput: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\nOutput: [0,1,2,3,4,-1]\n```",
    "body": "You have a 2-D grid of size `m x n` representing a box, and you have `n` balls. The box is open on the top and bottom sides.\n\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n- A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`. \n- A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.\n\nWe drop one ball at the top of each column of the box. \nEach ball can get stuck in the box or fall out of the bottom. \nA ball gets stuck if it hits a `\"V\"` shaped pattern between two boards or if a board redirects the ball into either wall of the box.\n\nReturn an array answer of size `n` where `answer[i]` is the column that the ball falls out of at the bottom after dropping the ball from the ith column at the top, \nor `-1` if the ball gets stuck in the box.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/ball.jpeg\" alt=\"Ball\" />\n\n**Example 1:** \n```\nInput: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\nOutput: [1,-1,-1,-1,-1]\nExplanation: This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n```\n\n**Example 2:** \n```\nInput: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\nOutput: [0,1,2,3,4,-1]\n```",
    "solutions": {}
  },
  "wildcard-matching": {
    "id": "wildcard-matching",
    "title": "Wildcard Matching",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "dynamic-programming",
      "greedy",
      "string"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(n+m)",
    "sc": "O(m)",
    "leetcode": "wildcard-matching",
    "gfg": null,
    "leetid": 44,
    "content": "---\nlayout: post\ntitle: Wildcard Matching\ntopics: [dynamic-programming, greedy, string]\nlangs: [java, cpp]\ntc: O(n+m)\nsc: O(m)\nleetid: 44\ndifficulty: hard\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: \nleetcode: wildcard-matching\n---\n\nGiven an input string `(s)` and a pattern `(p)`, implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n- `'?'` Matches any single character.\n- `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:** \n```\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n```\n\n**Example 3:**\n```\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n```",
    "body": "Given an input string `(s)` and a pattern `(p)`, implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n- `'?'` Matches any single character.\n- `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n```\n\n**Example 2:** \n```\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n```\n\n**Example 3:**\n```\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n```",
    "solutions": {}
  },
  "word-break-ii": {
    "id": "word-break-ii",
    "title": "Word Break II",
    "difficulty": "hard",
    "companies": [
      "facebook"
    ],
    "topics": [
      "backtracking",
      "dynamic-programming",
      "hash-table",
      "string"
    ],
    "langs": [
      "java",
      "py"
    ],
    "tc": "O(2<sup>n</sup>)",
    "sc": "O(n)",
    "leetcode": "word-break-ii",
    "gfg": null,
    "leetid": 140,
    "content": "---\nlayout: post\ntitle: Word Break II\ntopics: [backtracking, dynamic-programming, hash-table, string]\nlangs: [java, py]\ntc: O(2<sup>n</sup>)\nsc: O(n)\nleetid: 140\ndifficulty: hard\ncompanies: [facebook]\ngfg: \nhackerrank: \ninterviewbit: word-break-ii\nleetcode: word-break-ii\n---\nGiven a string `s` and a dictionary of strings `wordDict`, \nadd spaces in `s` to construct a sentence where each word is a valid dictionary word. \nReturn all such possible sentences in any order.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\n```\n\n**Example 2:** \n```\nInput: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\nExplanation: Note that you are allowed to reuse a dictionary word.\n```\n\n**Example 3:**\n```\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []\n```",
    "body": "Given a string `s` and a dictionary of strings `wordDict`, \nadd spaces in `s` to construct a sentence where each word is a valid dictionary word. \nReturn all such possible sentences in any order.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\n```\n\n**Example 2:** \n```\nInput: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\nExplanation: Note that you are allowed to reuse a dictionary word.\n```\n\n**Example 3:**\n```\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []\n```",
    "solutions": {}
  },
  "word-break": {
    "id": "word-break",
    "title": "Word Break",
    "difficulty": "medium",
    "companies": [
      "facebook"
    ],
    "topics": [
      "string",
      "dynamic-programming"
    ],
    "langs": [
      "java",
      "cpp",
      "py"
    ],
    "tc": "O(n<sup>2</sup>)",
    "sc": "O(n)",
    "leetcode": "word-break",
    "gfg": "word-break-problem-dp-32",
    "leetid": 139,
    "content": "---\nlayout: post\ntitle: Word Break\ntopics: [string, dynamic-programming]\nlangs: [java, cpp, py]\ntc: O(n<sup>2</sup>)\nsc: O(n)\nleetid: 139\ngfg: word-break-problem-dp-32\ncompanies: [facebook]\ndifficulty: medium\nhackerrank: \ninterviewbit: word-break\nleetcode: word-break\n---\n\nGiven a string s and a dictionary of strings `wordDict`, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n---\n## Test Cases\n\n**Input:**\n\n    (String)    s = \"leetcode\"\n    (String[])  wordDict = [\"leet\",\"code\"]\n\n**Output:**\n\n    (boolean) true\n\n---\n\n**Input:**\n\n    (String)    s = \"applepenapple\"\n    (String[])  wordDict = [\"apple\",\"pen\"]\n\n**Output:**\n\n    (boolean) true\n\n**Explanation**\n\n    Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word.\n\n---\n\n**Input:**\n\n    (String)    s = \"catsandog\"\n    (String[])  wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\n**Output:**\n\n    (boolean) false",
    "body": "Given a string s and a dictionary of strings `wordDict`, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n---\n## Test Cases\n\n**Input:**\n\n    (String)    s = \"leetcode\"\n    (String[])  wordDict = [\"leet\",\"code\"]\n\n**Output:**\n\n    (boolean) true\n\n---\n\n**Input:**\n\n    (String)    s = \"applepenapple\"\n    (String[])  wordDict = [\"apple\",\"pen\"]\n\n**Output:**\n\n    (boolean) true\n\n**Explanation**\n\n    Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word.\n\n---\n\n**Input:**\n\n    (String)    s = \"catsandog\"\n    (String[])  wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\n**Output:**\n\n    (boolean) false",
    "solutions": {}
  },
  "word-ladder": {
    "id": "word-ladder",
    "title": "Word Ladder",
    "difficulty": "hard",
    "companies": [
      "linkedin",
      "facebook"
    ],
    "topics": [
      "hash-table",
      "string"
    ],
    "langs": [
      "java",
      "cpp"
    ],
    "tc": "O(m<sup>2</sup>n)",
    "sc": "O(m<sup>2</sup>n)",
    "leetcode": "word-ladder",
    "gfg": null,
    "leetid": 127,
    "content": "---\nlayout: post\ntitle: Word Ladder\ntopics: [hash-table, string]\nlangs: [java, cpp]\ntc: O(m<sup>2</sup>n)\nsc: O(m<sup>2</sup>n)\nleetid: 127\ndifficulty: hard\ncompanies: [linkedin, facebook]\ngfg: \nhackerrank: \ninterviewbit: word-ladder-i\nleetcode: word-ladder\n---\n\nA transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words \n```\nbeginWord -> s1 -> s2 -> ... -> sk\n```\nsuch that: \n- Every adjacent pair of words differs by a single letter. \n- Every s<sub>i</sub> for `1 <= i <= k` is in wordList. Note that beginWord does not need to be in wordList.\n- `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, \nreturn the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.\n\n---\n## Test Cases\n\n**Input:**\n\n    (String)    beginWord = \"hit\"\n    (String)    endWord = \"cog\"\n    (String[])  wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\n**Output:**\n\n      (int) 5\n\n---\n\n**Input:**\n\n    (String)    beginWord = \"hit\"\n    (String)    endWord = \"cog\"\n    (String[])  wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\n**Output:**\n\n      (int) 0",
    "body": "A transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words \n```\nbeginWord -> s1 -> s2 -> ... -> sk\n```\nsuch that: \n- Every adjacent pair of words differs by a single letter. \n- Every s<sub>i</sub> for `1 <= i <= k` is in wordList. Note that beginWord does not need to be in wordList.\n- `sk == endWord`\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, \nreturn the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.\n\n---\n## Test Cases\n\n**Input:**\n\n    (String)    beginWord = \"hit\"\n    (String)    endWord = \"cog\"\n    (String[])  wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\n**Output:**\n\n      (int) 5\n\n---\n\n**Input:**\n\n    (String)    beginWord = \"hit\"\n    (String)    endWord = \"cog\"\n    (String[])  wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\n**Output:**\n\n      (int) 0",
    "solutions": {}
  },
  "word-search-ii": {
    "id": "word-search-ii",
    "title": "Word Search II",
    "difficulty": "hard",
    "companies": [],
    "topics": [
      "array",
      "backtracking",
      "string",
      "trie"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(nm)",
    "sc": "O(w)",
    "leetcode": "word-search-ii",
    "gfg": "boggle-using-trie",
    "leetid": 212,
    "content": "---\nlayout: post\ntitle: Word Search II\ntopics: [array, backtracking, string, trie]\nlangs: [java]\ntc: O(nm)\nsc: O(w)\nleetid: 212\ngfg: boggle-using-trie\ndifficulty: hard\ncompanies: \nhackerrank: \ninterviewbit: \nleetcode: word-search-ii\n---\n\nGiven an `m x n` board of characters and a list of strings words, return all words on the board.\n\nEach word must be constructed from letters of sequentially **adjacent cells**, \nwhere adjacent cells are horizontally or vertically neighboring. \nThe same letter cell may not be used more than once in a word.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<table class=\"post-example-table\">\n    <tr>\n        <td class=\"green\">o</td>\n        <td class=\"green\">a</td>\n        <td>a</td>\n        <td>n</td>\n    </tr>\n    <tr>\n        <td>e</td>\n        <td class=\"red\">t</td>\n        <td class=\"red\">a</td>\n        <td class=\"red\">e</td>\n    </tr>\n    <tr>\n        <td>i</td>\n        <td class=\"green\">h</td>\n        <td>k</td>\n        <td>r</td>\n    </tr>\n    <tr>\n        <td>i</td>\n        <td>f</td>\n        <td>l</td>\n        <td>v</td>\n    </tr>\n</table>\n\n\n```\nInput: board = [\n    [\"o\",\"a\",\"a\",\"n\"],\n    [\"e\",\"t\",\"a\",\"e\"],\n    [\"i\",\"h\",\"k\",\"r\"],\n    [\"i\",\"f\",\"l\",\"v\"]\n], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n```\n\n**Example 2:** \n\n<table class=\"post-example-table\">\n    <tr>\n        <td>a</td>\n        <td>b</td>\n    </tr>\n    <tr>\n        <td>c</td>\n        <td>d</td>\n    </tr>\n</table>\n\n```\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []\n```",
    "body": "Given an `m x n` board of characters and a list of strings words, return all words on the board.\n\nEach word must be constructed from letters of sequentially **adjacent cells**, \nwhere adjacent cells are horizontally or vertically neighboring. \nThe same letter cell may not be used more than once in a word.\n\n---\n\n## Test Cases\n\n**Example 1:**\n\n<table class=\"post-example-table\">\n    <tr>\n        <td class=\"green\">o</td>\n        <td class=\"green\">a</td>\n        <td>a</td>\n        <td>n</td>\n    </tr>\n    <tr>\n        <td>e</td>\n        <td class=\"red\">t</td>\n        <td class=\"red\">a</td>\n        <td class=\"red\">e</td>\n    </tr>\n    <tr>\n        <td>i</td>\n        <td class=\"green\">h</td>\n        <td>k</td>\n        <td>r</td>\n    </tr>\n    <tr>\n        <td>i</td>\n        <td>f</td>\n        <td>l</td>\n        <td>v</td>\n    </tr>\n</table>\n\n\n```\nInput: board = [\n    [\"o\",\"a\",\"a\",\"n\"],\n    [\"e\",\"t\",\"a\",\"e\"],\n    [\"i\",\"h\",\"k\",\"r\"],\n    [\"i\",\"f\",\"l\",\"v\"]\n], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n```\n\n**Example 2:** \n\n<table class=\"post-example-table\">\n    <tr>\n        <td>a</td>\n        <td>b</td>\n    </tr>\n    <tr>\n        <td>c</td>\n        <td>d</td>\n    </tr>\n</table>\n\n```\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []\n```",
    "solutions": {}
  },
  "word-search": {
    "id": "word-search",
    "title": "Word Search",
    "difficulty": "medium",
    "companies": [
      "adobe",
      "amazon",
      "apple",
      "bloomberg",
      "facebook",
      "goldman",
      "google",
      "microsoft",
      "oracle",
      "twitter"
    ],
    "topics": [
      "array",
      "backtracking",
      "string"
    ],
    "langs": [
      "java",
      "py",
      "cpp"
    ],
    "tc": "O(nmw)",
    "sc": "O(n)",
    "leetcode": "word-search",
    "gfg": "word-ladder-length-of-shortest-chain-to-reach-a-target-word",
    "leetid": 79,
    "content": "---\nlayout: post\ntitle: Word Search\ntopics: [array, backtracking, string]\nlangs: [java, py, cpp]\ntc: O(nmw)\nsc: O(n)\nleetid: 79\ncompanies: [adobe, amazon, apple, bloomberg, facebook, goldman, google, microsoft, oracle, twitter]\ndifficulty: medium\ngfg: word-ladder-length-of-shortest-chain-to-reach-a-target-word\nhackerrank: \ninterviewbit: \nleetcode: word-search\n---\n\nGiven an `m x n` grid of characters `board` and a string `word`, \nreturn `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, \nwhere adjacent cells are horizontally or vertically neighboring. \nThe same letter cell may not be used more than once.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/word2.jpeg\" alt=\"Word Search\" />\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"ABCCED\"\n```\n\n**Output:**\n```\n(boolean) true\n```\n\n---\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"See\"\n```\n\n**Output:**\n```\n(boolean) true\n```\n\n---\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"ABCB\"\n```\n\n**Output:**\n```\n(boolean) false\n```",
    "body": "Given an `m x n` grid of characters `board` and a string `word`, \nreturn `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, \nwhere adjacent cells are horizontally or vertically neighboring. \nThe same letter cell may not be used more than once.\n\n---\n\n## Test Cases\n\n<MdxImage src=\"code/word2.jpeg\" alt=\"Word Search\" />\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"ABCCED\"\n```\n\n**Output:**\n```\n(boolean) true\n```\n\n---\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"See\"\n```\n\n**Output:**\n```\n(boolean) true\n```\n\n---\n\n**Input:**\n```\n(char[]) board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n(string) word = \"ABCB\"\n```\n\n**Output:**\n```\n(boolean) false\n```",
    "solutions": {}
  },
  "zigzag-conversion": {
    "id": "zigzag-conversion",
    "title": "Zigzag Conversion",
    "difficulty": "medium",
    "companies": [],
    "topics": [
      "string"
    ],
    "langs": [
      "java"
    ],
    "tc": "O(n)",
    "sc": "O(n)",
    "leetcode": "zigzag-conversion",
    "gfg": null,
    "leetid": 6,
    "content": "---\nlayout: post\ntitle: Zigzag Conversion\ntopics: [string]\nlangs: [java]\ntc: O(n)\nsc: O(n)\nleetid: 6\ndifficulty: medium\ncompanies: \ngfg: \nhackerrank: \ninterviewbit: \nleetcode: zigzag-conversion\n---\n\nThe string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR\"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n```\nstring convert(string s, int numRows);\n```\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n```\n\n**Example 2:** \n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```",
    "body": "The string `\"PAYPALISHIRING\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n```\nP   A   H   N\nA P L S I I G\nY   I   R\n```\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR\"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n```\nstring convert(string s, int numRows);\n```\n\n---\n\n## Test Cases\n\n**Example 1:** \n```\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n```\n\n**Example 2:** \n```\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n```",
    "solutions": {}
  }
}