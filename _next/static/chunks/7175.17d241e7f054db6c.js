"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7175],{97175:n=>{n.exports=JSON.parse('{"cpp":{"language":"cpp","code":"class Solution {\\npublic:\\n    string alienOrder(vector<string>& A) {\\n        unordered_map<int, unordered_set<int>> G;\\n        int indegree[26] = {};\\n        for (auto &s : A) {\\n            for (char c : s) G[c - \'a\'] = {};\\n        }\\n        for (int i = 1; i < A.size(); ++i) {\\n            int j = 0;\\n            for (; j < min(A[i - 1].size(), A[i].size()); ++j) {\\n                if (A[i - 1][j] == A[i][j]) continue;\\n                G[A[i - 1][j] - \'a\'].insert(A[i][j] - \'a\');\\n                break;\\n            }\\n            if (j == A[i].size() && j < A[i - 1].size()) return \\"\\";\\n        }\\n        for (auto &[from, tos] : G) {\\n            for (int to : tos) {\\n                indegree[to]++;\\n            }\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < 26; ++i) {\\n            if (G.count(i) && indegree[i] == 0) q.push(i);\\n        }\\n        string ans;\\n        while (q.size()) {\\n            int u = q.front();\\n            q.pop();\\n            ans += u + \'a\';\\n            for (int v : G[u]) {\\n                if (--indegree[v] == 0) q.push(v);\\n            }\\n        }\\n        return ans.size() == G.size() ? ans : \\"\\";\\n    }\\n};","subPath":"","fileName":"solution.cpp"},"java":{"language":"java","code":"class Solution {\\n    // Returns the order of characters in the alien language, or \\"\\" if invalid\\n    public String alienOrder(String[] words) {\\n        // Adjacency matrix for graph representation\\n        boolean[][] g = new boolean[26][26];\\n        // Set of present characters\\n        boolean[] s = new boolean[26];\\n        int cnt = 0;\\n        int n = words.length;\\n        // Mark all unique characters and build graph edges\\n        for (int i = 0; i < n - 1; ++i) {\\n            for (char c : words[i].toCharArray()) {\\n                if (cnt == 26) break;\\n                c -= \'a\';\\n                if (!s[c]) {\\n                    ++cnt;\\n                    s[c] = true;\\n                }\\n            }\\n            int m = words[i].length();\\n            for (int j = 0; j < m; ++j) {\\n                if (j >= words[i + 1].length()) return \\"\\"; // prefix case\\n                char c1 = words[i].charAt(j), c2 = words[i + 1].charAt(j);\\n                if (c1 == c2) continue;\\n                if (g[c2 - \'a\'][c1 - \'a\']) return \\"\\"; // cycle check\\n                g[c1 - \'a\'][c2 - \'a\'] = true;\\n                break;\\n            }\\n        }\\n        // Mark unique characters in the last word\\n        for (char c : words[n - 1].toCharArray()) {\\n            if (cnt == 26) break;\\n            c -= \'a\';\\n            if (!s[c]) {\\n                ++cnt;\\n                s[c] = true;\\n            }\\n        }\\n        // Calculate indegrees\\n        int[] indegree = new int[26];\\n        for (int i = 0; i < 26; ++i) {\\n            for (int j = 0; j < 26; ++j) {\\n                if (i != j && s[i] && s[j] && g[i][j]) {\\n                    ++indegree[j];\\n                }\\n            }\\n        }\\n        // Topological sort using Kahn\'s algorithm\\n        Deque<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < 26; ++i) {\\n            if (s[i] && indegree[i] == 0) {\\n                q.offerLast(i);\\n            }\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        while (!q.isEmpty()) {\\n            int t = q.pollFirst();\\n            ans.append((char) (t + \'a\'));\\n            for (int i = 0; i < 26; ++i) {\\n                if (i != t && s[i] && g[t][i]) {\\n                    if (--indegree[i] == 0) {\\n                        q.offerLast(i);\\n                    }\\n                }\\n            }\\n        }\\n        // If not all characters are used, return \\"\\"\\n        return ans.length() < cnt ? \\"\\" : ans.toString();\\n    }\\n}","subPath":"","fileName":"solution.java"},"py":{"language":"py","code":"import collections\\n\\n\\nclass Node(object):\\n  def __init__(self, val):\\n    self.val = val\\n    self.neighbors = []\\n\\n  def connect(self, node):\\n    self.neighbors.append(node)\\n\\n  def getNbrs(self):\\n    return self.neighbors\\n\\n\\nclass Solution(object):\\n  def alienOrder(self, words):\\n    \\"\\"\\"\\n    :type words: List[str]\\n    :rtype: str\\n    \\"\\"\\"\\n\\n    def dfs(root, graph, visited):\\n      visited[root] = 1\\n      for nbr in graph[root].getNbrs():\\n        if visited[nbr.val] == 0:\\n          if not dfs(nbr.val, graph, visited):\\n            return False\\n        elif visited[nbr.val] == 1:\\n          return False\\n\\n      visited[root] = 2\\n      self.ans += root\\n      return True\\n\\n    self.ans = \\"\\"\\n    graph = {}\\n    visited = collections.defaultdict(int)\\n    self.topNum = 0\\n    for i in range(0, len(words) - 1):\\n      a = words[i]\\n      b = words[i + 1]\\n      i = 0\\n      while i < len(a) and i < len(b):\\n        if a[i] != b[i]:\\n          nodeA = nodeB = None\\n          if a[i] not in graph:\\n            nodeA = Node(a[i])\\n            graph[a[i]] = nodeA\\n          else:\\n            nodeA = graph[a[i]]\\n          if b[i] not in graph:\\n            nodeB = Node(b[i])\\n            graph[b[i]] = nodeB\\n          else:\\n            nodeB = graph[b[i]]\\n          nodeA.connect(nodeB)\\n          break\\n        i += 1\\n      if i < len(a) and i >= len(b):\\n        return \\"\\"\\n\\n    for c in graph:\\n      if visited[c] == 0:\\n        if not dfs(c, graph, visited):\\n          return \\"\\"\\n\\n    unUsedSet = set()\\n    for word in words:\\n      for c in word:\\n        unUsedSet.add(c)\\n\\n    for c in unUsedSet:\\n      if c not in graph:\\n        self.ans += c\\n    return self.ans[::-1]","subPath":"","fileName":"solution.py"}}')}}]);