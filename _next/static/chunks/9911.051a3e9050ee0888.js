"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9911],{29911:n=>{n.exports=JSON.parse('{"cpp":{"language":"cpp","code":"class Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n = s.length();\\n        vector<bool> dp(n, false);\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<=i; j++) {\\n                string sub = s.substr(j, i-j+1);\\n                if (contains(wordDict, sub) && (j==0 || dp[j-1])) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n\\n    bool contains(vector<string> &v, string s) {\\n        return find(v.begin(), v.end(), s) != v.end();\\n    }\\n};","subPath":"","fileName":"solution.cpp"},"java":{"language":"java","code":"class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if (s == null || s.length() == 0) return false;\\n\\n        int n = s.length();\\n        Set<String> dict = new HashSet<>(wordDict);\\n        // dp[i] represents whether s[0...i] can be formed by dict\\n        boolean[] dp = new boolean[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= i; j++) {\\n                String sub = s.substring(j, i + 1);\\n\\n                if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1];\\n    }\\n}","subPath":"","fileName":"solution.java"},"py":{"language":"py","code":"class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp, st = [False]*n, set(wordDict)\\n        for i in range(n):\\n            for j in range(i+1):\\n                if s[j:i+1] in st and (j==0 or dp[j-1]):\\n                    dp[i] = True\\n                    break\\n        return dp[n-1]","subPath":"","fileName":"solution.py"}}')}}]);