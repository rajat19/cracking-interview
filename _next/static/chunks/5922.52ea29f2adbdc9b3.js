"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5922],{55922:n=>{n.exports=JSON.parse('{"cpp":{"language":"cpp","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) return head;\\n        ListNode *slow = head, *fast = head;\\n        while(fast->next != nullptr && fast->next->next != nullptr) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode *next = slow->next;\\n        slow->next = nullptr;\\n        ListNode *first = sortList(head);\\n        ListNode *second = sortList(next);\\n        return merge(first, second);\\n    }\\n    \\n    ListNode* merge(ListNode* first, ListNode* second) {\\n        ListNode *prev = new ListNode();\\n        ListNode *head = prev;\\n        while(first != nullptr || second != nullptr) {\\n            if (first == nullptr) {\\n                prev->next = second;\\n                second = second->next;\\n            }\\n            else if (second == nullptr) {\\n                prev->next = first;\\n                first = first->next;\\n            } else {\\n                if (first->val < second->val) {\\n                    prev->next = first;\\n                    first = first->next;\\n                } else {\\n                    prev->next = second;\\n                    second = second->next;\\n                }\\n            }\\n            prev = prev->next;\\n            prev->next = nullptr;\\n        }\\n        return head->next;\\n    }\\n};","subPath":"","fileName":"solution.cpp"},"java":{"language":"java","code":"/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode sortList(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode slow = head, fast = head;\\n        while(fast.next != null && fast.next.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode next = slow.next;\\n        slow.next = null;\\n        ListNode first = sortList(head);\\n        ListNode second = sortList(next);\\n        return merge(first, second);\\n    }\\n\\n    private ListNode merge(ListNode first, ListNode second) {\\n        ListNode prev = new ListNode();\\n        ListNode head = prev;\\n        while(first != null || second != null) {\\n            if (first == null) {\\n                prev.next = second;\\n                second = second.next;\\n            }\\n            else if (second == null) {\\n                prev.next = first;\\n                first = first.next;\\n            } else {\\n                if (first.val < second.val) {\\n                    prev.next = first;\\n                    first = first.next;\\n                } else {\\n                    prev.next = second;\\n                    second = second.next;\\n                }\\n            }\\n            prev = prev.next;\\n            prev.next = null;\\n        }\\n        return head.next;\\n    }\\n}","subPath":"","fileName":"solution.java"}}')}}]);