"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2178],{52178:n=>{n.exports=JSON.parse('{"java":{"language":"java","code":"class Solution {\\n    public List<List<Integer>> getSkyline(int[][] buildings) {\\n        int totalBuildings = buildings.length;\\n        BuildingPoint[] buildingPoints = new BuildingPoint[totalBuildings*2];\\n        int index = 0;\\n        for(int[] building: buildings) {\\n            buildingPoints[index++] = new BuildingPoint(building[0], building[2], true);\\n            buildingPoints[index++] = new BuildingPoint(building[1], building[2], false);\\n        }\\n        Arrays.sort(buildingPoints);\\n\\n        TreeMap<Integer, Integer> queue = new TreeMap<>();\\n        queue.put(0, 1);\\n        int prevMaxHeight = 0;\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for(BuildingPoint buildingPoint: buildingPoints) {\\n            if (buildingPoint.isStart) {\\n                queue.compute(buildingPoint.y, (key, value) -> value != null ? value + 1: 1);\\n            } else {\\n                queue.compute(buildingPoint.y, (key, value) -> value == 1 ? null: value - 1);\\n            }\\n            int currentMaxHeight = queue.lastKey();\\n            if (prevMaxHeight != currentMaxHeight) {\\n                result.add(Arrays.asList(buildingPoint.x, currentMaxHeight));\\n                prevMaxHeight = currentMaxHeight;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\nclass BuildingPoint implements Comparable<BuildingPoint>{\\n    int x;\\n    int y;\\n    boolean isStart;\\n    BuildingPoint(int x, int y, boolean isStart) {\\n        this.x = x;\\n        this.y = y;\\n        this.isStart = isStart;\\n    }\\n\\n    public  int compareTo(BuildingPoint o) {\\n        if (this.x != o.x) {\\n            return this.x - o.x;\\n        }\\n        // if two starts are compared, then higher y should be picked first\\n        // if two ends are compared, then lower y should be picked first\\n        // if one start and one end is compared, then start should appear before end\\n        int h1 = isStart ? -y : y;\\n        int h2 = o.isStart ? -o.y : o.y;\\n        return h1 - h2;\\n    }\\n\\n    public String toString() {\\n        return \\"{\\"+x+\\", \\"+y+\\", \\"+isStart+\\"}\\";\\n    }\\n}","subPath":"","fileName":"solution.java"}}')}}]);