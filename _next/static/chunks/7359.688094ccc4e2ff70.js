"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7359],{77359:e=>{e.exports=JSON.parse('{"cpp":{"language":"cpp","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* prev = new ListNode(0, head);\\n        ListNode* curr = prev;\\n        while(head != nullptr) {\\n            if (head->next != nullptr && head->val == head->next->val) {\\n                while(head->next != nullptr && head->val == head->next->val) {\\n                    head = head->next;\\n                }\\n                curr->next = head->next;\\n            } else {\\n                curr = curr->next;\\n            }\\n            head = head->next;\\n        }\\n        return prev->next;\\n    }\\n};","subPath":"","fileName":"solution.cpp"},"java":{"language":"java","code":"/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode prev = new ListNode(0, head);\\n        ListNode curr = prev;\\n        while(head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                while(head.next != null && head.val == head.next.val) {\\n                    head = head.next;\\n                }\\n                curr.next = head.next;\\n            } else {\\n                curr = curr.next;\\n            }\\n            head = head.next;\\n        }\\n        return prev.next;\\n    }\\n}","subPath":"","fileName":"solution.java"}}')}}]);