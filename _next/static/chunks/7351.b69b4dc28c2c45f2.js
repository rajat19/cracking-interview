"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7351],{37351:t=>{t.exports=JSON.parse('{"c":{"language":"c","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n\\nvoid flatten(struct TreeNode* root){\\n    if (!root) return;\\n    flatten(root->left);\\n    flatten(root->right);\\n    if (!root->left) return;\\n    struct TreeNode* right = root->right;\\n    struct TreeNode* left = root->left;\\n    root->left = NULL;\\n    root->right = left;\\n    while(left->right != NULL) {\\n        left = left->right;\\n    }\\n    left->right = right;\\n}","subPath":"","fileName":"solution.c"},"cpp":{"language":"cpp","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root == nullptr) return;\\n        flatten(root->left);\\n        flatten(root->right);\\n        if (root->left == nullptr) return;\\n        TreeNode* right = root->right;\\n        TreeNode* left = root->left;\\n        root->left = nullptr;\\n        root->right = left;\\n        while(left->right != nullptr) {\\n            left = left->right;\\n        }\\n        left->right = right;\\n    }\\n};","subPath":"","fileName":"solution.cpp"},"java":{"language":"java","code":"/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if (root == null) return;\\n        flatten(root.left);\\n        flatten(root.right);\\n        if (root.left != null) {\\n            TreeNode right = root.right;\\n            TreeNode left = root.left;\\n            root.left = null;\\n            root.right = left;\\n            while(left.right != null) {\\n                left = left.right;\\n            }\\n            left.right = right;\\n        }\\n    }\\n}","subPath":"","fileName":"solution.java"},"py":{"language":"py","code":"from typing import Optional\\n\\n\\n# Definition for a binary tree node.\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\"\\"\\"\\n        Do not return anything, modify root in-place instead.\\n        \\"\\"\\"\\n        if root is None:\\n            return\\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        if root.left is None:\\n            return\\n        right = root.right\\n        left = root.left\\n        root.left = None\\n        root.right = left\\n        while left.right is not None:\\n            left = left.right\\n        left.right = right","subPath":"","fileName":"solution.py"}}')}}]);