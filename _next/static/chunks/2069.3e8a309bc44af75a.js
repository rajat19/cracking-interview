"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2069],{82069:e=>{e.exports=JSON.parse('{"cpp":{"language":"cpp","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    queue<int> q;\\n    void inOrder(TreeNode* root, queue<int> &q) {\\n        if(root == NULL){\\n            return;\\n        }\\n        inOrder(root->left, q);\\n        q.push(root->val);\\n        inOrder(root->right, q);\\n    }\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        inOrder(root, q);\\n    }\\n\\n    int next() {\\n        if(!q.empty()){\\n            int frontNode = q.front();\\n            q.pop();\\n            return frontNode;\\n        }\\n        return 0;\\n    }\\n\\n    bool hasNext() {\\n        if(!q.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */","subPath":"","fileName":"solution.cpp"},"java":{"language":"java","code":"/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    private Deque<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new ArrayDeque<>();\\n        TreeNode next = root;\\n        while(next != null) {\\n            stack.offerLast(next);\\n            next = next.left;\\n        }\\n    }\\n\\n    public int next() {\\n        TreeNode removedNode = stack.pollLast();\\n        TreeNode next = removedNode.right;\\n        while(next != null) {\\n            stack.offerLast(next);\\n            next = next.left;\\n        }\\n        return removedNode.val;\\n    }\\n\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */","subPath":"","fileName":"solution.java"},"py":{"language":"py","code":"# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.lst = []\\n        self.index = 0\\n        if root:\\n            st = [root]\\n            while len(st) > 0:\\n                x = st.pop()\\n                self.lst.append(x.val)\\n                if x.left: st.append(x.left)\\n                if x.right: st.append(x.right)\\n            self.lst = sorted(self.lst)\\n            print(self.lst)\\n\\n    def next(self) -> int:\\n        \\"\\"\\"\\n        @return the next smallest number\\n        \\"\\"\\"\\n        x = self.lst[self.index]\\n        self.index += 1\\n        return x\\n\\n    def hasNext(self) -> bool:\\n        \\"\\"\\"\\n        @return whether we have a next smallest number\\n        \\"\\"\\"\\n        if len(self.lst) == 0: return False\\n        if self.index < len(self.lst):\\n            return True\\n        return False\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()","subPath":"","fileName":"solution.py"}}')}}]);